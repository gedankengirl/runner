Assets {
  Id: 17771149258410848072
  Name: "@CoreModules"
  PlatformAssetType: 5
  TemplateAsset {
    ObjectBlock {
      RootId: 16291094792229598910
      Objects {
        Id: 16291094792229598910
        Name: "@CoreModules"
        Transform {
          Scale {
            X: 1
            Y: 1
            Z: 1
          }
        }
        ParentId: 4781671109827199097
        ChildIds: 3989999382868994304
        ChildIds: 2709063500133343796
        UnregisteredParameters {
          Overrides {
            Name: "cs:_Base64"
            AssetReference {
              Id: 9544232931398361545
            }
          }
          Overrides {
            Name: "cs:_Bitarray"
            AssetReference {
              Id: 4327176263148897822
            }
          }
          Overrides {
            Name: "cs:_Deque"
            AssetReference {
              Id: 410319700329875550
            }
          }
          Overrides {
            Name: "cs:_Grid"
            AssetReference {
              Id: 12769054960477199651
            }
          }
          Overrides {
            Name: "cs:_Heap"
            AssetReference {
              Id: 2361961766352951098
            }
          }
          Overrides {
            Name: "cs:_Luapp"
            AssetReference {
              Id: 7243897883920053925
            }
          }
          Overrides {
            Name: "cs:_Maid"
            AssetReference {
              Id: 10304107291754736192
            }
          }
          Overrides {
            Name: "cs:_ReliableEvents"
            AssetReference {
              Id: 14454691258374778668
            }
          }
          Overrides {
            Name: "cs:_Snippets"
            AssetReference {
              Id: 4739659780833170311
            }
          }
          Overrides {
            Name: "cs:_Spr"
            AssetReference {
              Id: 7602836839952416252
            }
          }
          Overrides {
            Name: "cs:_SpringAnimator"
            AssetReference {
              Id: 15795618890956269941
            }
          }
          Overrides {
            Name: "cs:_StateMachine"
            AssetReference {
              Id: 15572707156245510975
            }
          }
          Overrides {
            Name: "cs:_Trampoline"
            AssetReference {
              Id: 3973205370573435669
            }
          }
          Overrides {
            Name: "cs:_Xoshiro256"
            AssetReference {
              Id: 9765507830262698727
            }
          }
        }
        Collidable_v2 {
          Value: "mc:ecollisionsetting:forceoff"
        }
        Visible_v2 {
          Value: "mc:evisibilitysetting:forceoff"
        }
        CameraCollidable {
          Value: "mc:ecollisionsetting:forceoff"
        }
        Folder {
          IsFilePartition: true
          FilePartitionName: "_CoreModules"
        }
      }
      Objects {
        Id: 3989999382868994304
        Name: "ClientContext"
        Transform {
          Location {
          }
          Rotation {
          }
          Scale {
            X: 1
            Y: 1
            Z: 1
          }
        }
        ParentId: 16291094792229598910
        ChildIds: 10159195518397696328
        Collidable_v2 {
          Value: "mc:ecollisionsetting:forceoff"
        }
        Visible_v2 {
          Value: "mc:evisibilitysetting:inheritfromparent"
        }
        CameraCollidable {
          Value: "mc:ecollisionsetting:inheritfromparent"
        }
        NetworkContext {
        }
      }
      Objects {
        Id: 10159195518397696328
        Name: "InitModules"
        Transform {
          Location {
          }
          Rotation {
          }
          Scale {
            X: 1
            Y: 1
            Z: 1
          }
        }
        ParentId: 3989999382868994304
        Collidable_v2 {
          Value: "mc:ecollisionsetting:inheritfromparent"
        }
        Visible_v2 {
          Value: "mc:evisibilitysetting:inheritfromparent"
        }
        CameraCollidable {
          Value: "mc:ecollisionsetting:inheritfromparent"
        }
        Script {
          ScriptAsset {
            Id: 6625644237715666445
          }
        }
      }
      Objects {
        Id: 2709063500133343796
        Name: "InitModules"
        Transform {
          Location {
          }
          Rotation {
          }
          Scale {
            X: 1
            Y: 1
            Z: 1
          }
        }
        ParentId: 16291094792229598910
        Collidable_v2 {
          Value: "mc:ecollisionsetting:inheritfromparent"
        }
        Visible_v2 {
          Value: "mc:evisibilitysetting:inheritfromparent"
        }
        CameraCollidable {
          Value: "mc:ecollisionsetting:inheritfromparent"
        }
        Script {
          ScriptAsset {
            Id: 6625644237715666445
          }
        }
      }
    }
    Assets {
      Id: 6625644237715666445
      Name: "InitModules"
      PlatformAssetType: 3
      TextAsset {
        Text: "local CONTAINER = Environment.IsClient() and script.parent.parent or script.parent\nlocal MODELES_G_KEY = \"<%ModulesCache%>\"\n_G[MODELES_G_KEY] = _G[MODELES_G_KEY] or {}\nlocal modules = _G[MODELES_G_KEY]\n\nfor mod_name, mod_muid in pairs(CONTAINER:GetCustomProperties()) do\n    if modules[mod_name] then\n        error(string.format(\"ERROR: namespace module name conflict: `%s`\", mod_name), 2)\n    end\n    modules[mod_name] = mod_muid\n\nend\n\n_G.req = function(module_name)\n    local muid = modules[module_name]\n    if not muid then\n        error(\"unknown module: \'\" .. module_name .. \"\'\", 2)\n    end\n    local t1 = os.clock()\n    local mod = require(muid)\n    local dt = os.clock() - t1\n    if dt >= 0.009 then\n        warn(string.format(\"[%s] long load time: %.1g ms\", module_name, dt*1000))\n    end\n    return mod\nend\n\n"
      }
    }
    Assets {
      Id: 9765507830262698727
      Name: "_Xoshiro256"
      PlatformAssetType: 3
      TextAsset {
        Text: "-- Copyright (C) 1994-2020 Lua.org, PUC-Rio.\n-- Copyright (C) 2021 by Andrew Zhilin <andrew.zhilin@gmail.com>\n-- Distributed under MIT license.\n--[===========================================================================[\n    `xoshiro256` is a pure Lua 5.3 implementation of xoshiro256**, all-purpose,\n    rock-solid random generator, that is fully compatible with Lua 5.4 API and\n    implementation of `math.random` and `math.randomseed`. It has a reasonable\n    performance and passes all random-related tests from Lua 5.4 test suite.\n\n    * xoshiro256.random([m[, n]])\n    When called without arguments, returns a pseudo-random float with uniform\n    distribution in the range [0,1). When called with two integers m and n,\n    xoshiro256.random returns a pseudo-random integer with uniform\n    distribution in the range [m, n]. The call xoshiro256.random(n),\n    for a positive n, is equivalent to xoshiro256.random(1,n). The call\n    math.random(0) produces an integer with all bits (pseudo)random.\n    This function uses the xoshiro256** algorithm to produce pseudo-random\n    64-bit integers, which are the results of calls with argument 0. Other\n    results (ranges and floats) are unbiased extracted from these integers.\n\n    * xoshiro256.randomseed([x[, y]])\n    When called with at least one argument, the integer parameters x and y\n    are joined into a 128-bit seed that is used to reinitialize the\n    pseudo-random generator; equal seeds produce equal sequences of numbers.\n    The default for y is zero.\n    When called with no arguments, generates a seed with a weak attempt for\n    randomness.\n    This function returns the two seed components that were effectively used,\n    so that setting them again repeats the sequence.\n    To ensure a required level of randomness to the initial state (or\n    contrarily, to have a deterministic sequence, for instance when debugging\n    a program), you should call xoshiro256.randomseed with explicit\n    arguments.\n--]===========================================================================]\nassert(_VERSION:find(\"Lua 5.3\"))\nlocal xoshiro256 = {}\ndo\n    local select, ult = select, math.ult\n    local DBL_CONV_MULT = 1/2^53 -- reference: http://prng.di.unimi.it/\n    local s0, s1, s2, s3 = 0x00, 0x00, 0x00, 0x00\n    local function next_rand()\n        local x, k = s1*5, 7\n        local result = (x << k | x >> (64 - k))*9\n        local t = s1 << 17\n        s2 = s2 ~ s0\n        s3 = s3 ~ s1\n        s1 = s1 ~ s2\n        s0 = s0 ~ s3\n        s2 = s2 ~ t\n        x, k = s3, 45\n        s3 = x << k | x >> (64 - k)\n        return result\n    end\n\n    local function randomseed(n1, n2)\n        n1 = n1 or os.time()\n        n2 = n2 or 0\n        s0, s1, s2, s3 = n1, 0xFF --[[to avoid a zero state]], n2, 0x00\n        for _=1, 16 do\n            next_rand() -- discard initial values to \"spread\" seed\n        end\n        return n1, n2\n    end\n\n    randomseed() -- initial seeding\n\n    -- Project the random integer \'ran\' into the interval [0, n].\n    -- Because \'ran\' has 2^B possible values, the projection can only be\n    -- uniform when the size of the interval is a power of 2 (exact\n    -- division). Otherwise, to get a uniform projection into [0, n], we\n    -- first compute \'lim\', the smallest Mersenne number not smaller than\n    -- \'n\'. We then project \'ran\' into the interval [0, lim].  If the result\n    -- is inside [0, n], we are done. Otherwise, we try with another \'ran\',\n    -- until we have a result inside the interval.\n    local function project(ran, n)\n        if n & (n + 1) == 0 then -- is \'n + 1\' a power of 2?\n            return ran & n -- no bias\n        else\n            -- compute the smallest (2^b - 1) not smaller than \'n\'\n            local lim = n\n            lim = lim | lim >> 1\n            lim = lim | lim >> 2\n            lim = lim | lim >> 4\n            lim = lim | lim >> 8\n            lim = lim | lim >> 16\n            lim = lim | lim >> 32\n            -- commented out for performance:\n            -- assert(lim & (lim + 1) == 0)\n            -- assert(lim >= n)\n            -- assert(ult(lim >> 1, n))\n            while true do\n                ran = ran & lim -- project \'ran\' into [0..lim]\n                if ult(n, ran) then -- not inside [0..n]? try again\n                    ran = next_rand()\n                else\n                    break\n                end\n            end\n            return ran\n        end\n    end\n\n    local function random(low, up, ...)\n        assert(select(\"#\", ...) == 0, \"too many arguments\")\n        local rv = next_rand()\n        local nargs = (low and up and 2) or (low and not up and 1) or 0\n        if nargs == 0 then\n            return (rv >> 11) * DBL_CONV_MULT -- converts uint64 to double at [0, 1)\n        elseif nargs == 1 then\n            up, low = low, 1 -- only upper limit\n            if up == 0 then return rv end\n        end\n        -- project rv into the interval [low, up]\n        assert(low <= up, \"interval is empty\")\n        local p = project(rv, up - low)\n        return p + low\n     end\n    -- exports\n    xoshiro256.random = random\n    xoshiro256.randomseed = randomseed\nend\n\n-------------------------------------------------------------------------------\nlocal function _test()\n    print(\"xoshiro256 -- testing ...\")\n    local random, max, min = xoshiro256.random, math.max, math.min\n\n    -- All below is a snippets from lua-5.4.2-tests/math.lua\n\n    local minint = math.mininteger\n    local maxint = math.maxinteger\n    local intbits = math.floor(math.log(maxint, 2) + 0.5) + 1\n    assert((1 << intbits) == 0)\n\n    assert(minint == 1 << (intbits - 1))\n    assert(maxint == minint - 1)\n\n    -- number of bits in the mantissa of a floating-point number\n    local floatbits = 24\n    do\n        local p = 2.0^floatbits\n        while p < p + 1.0 do\n            p = p * 2.0\n            floatbits = floatbits + 1\n        end\n    end\n\n    -- NOTE: we cut some corners assuming standard lua 5.3 64-bit runtime and IEEE 754 64-bit doubles\n    assert(floatbits == 53)\n    assert(intbits == 64)\n\n    local function isNaN (x)\n        return (x ~= x)\n    end\n\n    assert(isNaN(0/0))\n    assert(not isNaN(1/0))\n\n    do\n        local x = 2.0^floatbits\n        assert(x > x - 1.0 and x == x + 1.0)\n        print(string.format(\"* %d-bit integers, %d-bit (mantissa) floats\",\n                             intbits, floatbits))\n    end\n    assert(math.type(0) == \"integer\" and math.type(0.0) == \"float\"\n        and not math.type(\"10\"))\n\n\n    -- float equality\n    local function eq(a,b,limit)\n        if not limit then\n            if floatbits >= 50 then limit = 1E-11\n            else limit = 1E-5\n            end\n        end\n        -- a == b needed for +inf/-inf\n        return a == b or math.abs(a-b) <= limit\n    end\n\n    local function testnear (val, ref, tol)\n        return (math.abs(val - ref) < ref * tol)\n    end\n\n    -- low-level!! For the current implementation of random in Lua,\n    -- the first call after seed 1007 should return 0x7a7040a5a323c9d6\n\n    -- all computations should work with 32-bit integers\n    do\n        local h = 0x7a7040a5   -- higher half\n        local l = 0xa323c9d6   -- lower half\n        xoshiro256.randomseed(1007)\n        -- get the low \'intbits\' of the 64-bit expected result\n        local res = (h << 32 | l) & ~(~0 << intbits)\n        assert(random(0) == res)\n        xoshiro256.randomseed(1007, 0)\n        -- using higher bits to generate random floats; (the \'% 2^32\' converts\n        -- 32-bit integers to floats as unsigned)\n        local res\n        if floatbits <= 32 then\n            -- get all bits from the higher half\n            res = (h >> (32 - floatbits)) % 2^32\n        else\n            -- get 32 bits from the higher half and the rest from the lower half\n            res = (h % 2^32) * 2^(floatbits - 32) + ((l >> (64 - floatbits)) % 2^32)\n        end\n        local rand = random()\n        -- NOTE: there is no hexadecimal floating-point literals until lua 5.4, but tonumber works!\n        assert(eq(rand, tonumber[[0x0.7a7040a5a323c9d6]], 2^-floatbits))\n        assert(rand * 2^floatbits == res)\n    end\n\n    do\n        -- testing return of \'randomseed\'\n        local x, y = xoshiro256.randomseed()\n        local res = xoshiro256.random(0)\n        x, y = xoshiro256.randomseed(x, y)    -- should repeat the state\n        assert(xoshiro256.random(0) == res)\n        xoshiro256.randomseed(x, y)    -- again should repeat the state\n        assert(xoshiro256.random(0) == res)\n        -- keep the random seed for following tests\n    end\n\n    do   -- test random for floats\n        local randbits = math.min(floatbits, 64)   -- at most 64 random bits\n        local mult = 2^randbits      -- to make random float into an integral\n        local counts = {}    -- counts for bits\n        for i = 1, randbits do counts[i] = 0 end\n        local up = -math.huge\n        local low = math.huge\n        local rounds = 100 * randbits   -- 100 times for each bit\n        local totalrounds = 0\n        ::doagain::   -- will repeat test until we get good statistics\n        for i = 0, rounds do\n            local t = random()\n            assert(0 <= t and t < 1)\n            up = max(up, t)\n            low = min(low, t)\n            assert(t * mult % 1 == 0)    -- no extra bits\n            local bit = i % randbits     -- bit to be tested\n            if (t * 2^bit) % 1 >= 0.5 then    -- is bit set?\n                counts[bit + 1] = counts[bit + 1] + 1   -- increment its count\n            end\n        end\n        totalrounds = totalrounds + rounds\n        if not (eq(up, 1, 0.001) and eq(low, 0, 0.001)) then\n            goto doagain\n        end\n        -- all bit counts should be near 50%\n        local expected = (totalrounds / randbits / 2)\n        for i = 1, randbits do\n            if not testnear(counts[i], expected, 0.10) then\n                goto doagain\n            end\n        end\n        print(string.format(\"float random range in %d calls: [%f, %f]\",\n                            totalrounds, low, up))\n    end\n\n    do   -- test random for full integers\n        local up = 0\n        local low = 0\n        local counts = {}    -- counts for bits\n        for i = 1, intbits do counts[i] = 0 end\n        local rounds = 100 * intbits   -- 100 times for each bit\n        local totalrounds = 0\n        ::doagain::   -- will repeat test until we get good statistics\n        for i = 0, rounds do\n            local t = random(0)\n            up = max(up, t)\n            low = min(low, t)\n            local bit = i % intbits     -- bit to be tested\n            -- increment its count if it is set\n            counts[bit + 1] = counts[bit + 1] + ((t >> bit) & 1)\n        end\n        totalrounds = totalrounds + rounds\n        local lim = maxint >> 10\n        if not (maxint - up < lim and low - minint < lim) then\n            goto doagain\n        end\n        -- all bit counts should be near 50%\n        local expected = (totalrounds / intbits / 2)\n        for i = 1, intbits do\n            if not testnear(counts[i], expected, 0.10) then\n                goto doagain\n            end\n        end\n        print(string.format(\n           \"integer random range in %d calls: [minint + %.0fppm, maxint - %.0fppm]\",\n            totalrounds, (minint - low) / minint * 1e6,\n                         (maxint - up) / maxint * 1e6))\n    end\n\n    do\n        -- test distribution for a dice\n        local count = {0, 0, 0, 0, 0, 0}\n        local rep = 200\n        local totalrep = 0\n        ::doagain::\n        for i = 1, rep * 6 do\n            local r = random(6)\n            count[r] = count[r] + 1\n        end\n        totalrep = totalrep + rep\n        for i = 1, 6 do\n            if not testnear(count[i], totalrep, 0.05) then\n                goto doagain\n            end\n        end\n    end\n\n    do\n        local function aux (x1, x2)     -- test random for small intervals\n        local mark = {}; local count = 0   -- to check that all values appeared\n        while true do\n            local t = random(x1, x2)\n            assert(x1 <= t and t <= x2)\n            if not mark[t] then  -- new value\n                mark[t] = true\n                count = count + 1\n                if count == x2 - x1 + 1 then   -- all values appeared; OK\n                    goto ok\n                end\n            end\n        end\n        ::ok::\n        end\n\n        aux(-10,0)\n        aux(1, 6)\n        aux(1, 2)\n        aux(1, 13)\n        aux(1, 31)\n        aux(1, 32)\n        aux(1, 33)\n        aux(-10, 10)\n        aux(-10,-10)   -- unit set\n        aux(minint, minint)   -- unit set\n        aux(maxint, maxint)   -- unit set\n        aux(minint, minint + 9)\n        aux(maxint - 3, maxint)\n    end\n\n    do\n        local function aux(p1, p2)       -- test random for large intervals\n            local max = minint\n            local min = maxint\n            local n = 100\n            local mark = {}; local count = 0   -- to count how many different values\n            ::doagain::\n        for _ = 1, n do\n            local t = random(p1, p2)\n            if not mark[t] then  -- new value\n                assert(p1 <= t and t <= p2)\n                max = math.max(max, t)\n                min = math.min(min, t)\n                mark[t] = true\n                count = count + 1\n            end\n        end\n            -- at least 80% of values are different\n            if not (count >= n * 0.8) then\n            goto doagain\n            end\n            -- min and max not too far from formal min and max\n            local diff = (p2 - p1) >> 4\n            if not (min < p1 + diff and max > p2 - diff) then\n            goto doagain\n            end\n        end\n        aux(0, maxint)\n        aux(1, maxint)\n        aux(3, maxint // 3)\n        aux(minint, -1)\n        aux(minint // 2, maxint // 2)\n        aux(minint, maxint)\n        aux(minint + 1, maxint)\n        -- aux(minint, maxint - 1)\n        aux(0, 1 << (intbits - 5))\n    end\n\n    assert(not pcall(random, 1, 2, 3))    -- too many arguments\n    -- empty interval\n    assert(not pcall(random, minint + 1, minint))\n    assert(not pcall(random, maxint, maxint - 1))\n    assert(not pcall(random, maxint, minint))\n\n    print(\"xoshiro256 -- ok\")\nend\n\n\nlocal CORE_ENV = CoreString and CoreMath\n\nlocal function _test_perf()\n\n    -- PERF: 1000000   math.random ints        time: 0.1780s mem: 0.00K\n    -- PERF: 1000000   xoshiro256.lua ints     time: 1.3688s mem: 1.02K\n    -- PERF: 1000000   math.random double      time: 0.1410s mem: 0.00K\n    -- PERF: 1000000   xoshiro256.lua double   time: 0.6312s mem: 0.95K\n\n    --[==[\n        local clock do\n            if not CORE_ENV then\n                local ok, socket = pcall(require, \"socket\")\n                clock = ok and socket.gettime or os.clock\n            else\n                clock = os.clock\n            end\n        end\n        local function perfn(tag, times, thunk)\n            if not CORE_ENV then\n                collectgarbage(\"collect\")\n                collectgarbage(\"stop\")\n            end\n            local m1 = collectgarbage(\"count\")\n            local t1 = clock()\n            local result = nil\n            for i = 1, times do\n                result = thunk()\n            end\n            local t2 = clock()\n            local m2 = collectgarbage(\"count\")\n            if not CORE_ENV then\n                collectgarbage(\"restart\")\n            end\n            local tmstr = string.format(\"time: %0.4fs mem: %0.2fK\", t2 - t1, m2 - m1)\n            if times <= 1 then\n                print(\"REPF:\", tag, tmstr)\n            else\n                print(string.format(\"PERF: %d\", times), tag, tmstr)\n            end\n            return result\n        end\n\n        local N = CORE_ENV and 1000 or 1000000\n        perfn(\"math.random ints\", N, function()\n            math.random(12345, 1234567890)\n        end)\n        perfn(\"xoshiro256.lua ints\", N, function()\n            xoshiro256.random(123451, 1234567890)\n        end)\n        perfn(\"math.random double\", N, function()\n            math.random()\n        end)\n        perfn(\"xoshiro256.lua double\", N, function()\n            xoshiro256.random()\n        end)\n    --]==]\nend\n\nif not CORE_ENV then -- Core has too low instruction limit\n    _test()\nend\n-- _test_perf()\n\nreturn xoshiro256\n"
      }
    }
    Assets {
      Id: 3973205370573435669
      Name: "_Trampoline"
      PlatformAssetType: 3
      TextAsset {
        Text: "local Trampoline = {}\nTrampoline.__index = Trampoline\n\nfunction Trampoline.New(func, interval)\n    interval = interval or 0\n    return setmetatable({\n        _first=0,\n        _last=-1,\n        _func = func,\n        _task = nil,\n        _last_tx = 0,\n        _interval=interval}, Trampoline)\nend\n\nfunction Trampoline:_empty()\n    return self._first > self._last\nend\n\nfunction Trampoline:_push(arg)\n    self._last = self._last + 1\n    self[self._last] = arg\nend\n\nfunction Trampoline:_pop()\n    local first = self._first\n    local arg = self[first]\n    self[first] = nil\n    self._first = first + 1\n    return arg\nend\n\nfunction Trampoline:__call(arg)\n    local tx_allowed = time() - self._last_tx > self._interval\n    local in_trampoline = not self:_empty()\n    if tx_allowed then\n        self._last_tx = time()\n        local ok = self._func(arg)\n        if not ok then\n            self:_push(arg)\n        end\n    else\n        self:_push(arg)\n    end\n    if not self:_empty() and not in_trampoline then\n        self.task = Task.Spawn(function()\n            -- warn(\"trampoline START\")\n            while not self:_empty() do\n                local parg = self:_pop()\n                local ok, msg = self._func(parg)\n                if ok then\n                    self._last_tx = time()\n                    Task.Wait(self._interval)\n                else\n                    if msg then warn(\"[Trampoline] \" .. msg) end\n                    self:_push(parg)\n                    Task.Wait()\n                end\n            end\n            --warn(\"trampoline END\")\n            self._task = nil\n        end, self._interval - (time() - self._last_tx))\n    end\nend\n\nfunction Trampoline:Destroy()\n    if self.task then self.task:Cancel() end\n    for i = self.first, self.last do self[i] = nil end\nend\n\nreturn Trampoline"
      }
    }
    Assets {
      Id: 15572707156245510975
      Name: "_StateMachine"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    Slightly abstracted state-machine from Mergelandia\n    Predefined state callbacks (all optional):\n        Check :: state -> bool\n        Enter :: state, ... -> nil (+event)\n        Exit  :: state -> nil      (+event)\n        Update :: state, dt -> nil\n]]\n\nlocal REvents = _G.req(\"_ReliableEvents\")\nlocal Maid = _G.req(\"_Maid\")\nlocal StateMachine = {type=\"StateMachine\"}\nStateMachine.__index = StateMachine\n\nlocal State = {type=\"StateMachine.State\"}\nState.__index = State\nlocal START = setmetatable({name=\"_START\"}, State)\n\n-- @param name: string\nfunction StateMachine.New(name)\n    assert(name and type(name) == \"string\")\n    return setmetatable({\n        name = name,\n        states = {},\n        _maid = Maid.New(),\n        currentState = START,\n    }, StateMachine)\nend\n\n-- handlers :: {key = [handle1, handle2, ...]\n-- example: {[\"ability_primary\"] = {\"HandleLeftMouseDown\", \"HandleLeftMouseUp\"}, ...}\n-- usage: PLAYER.bindingPressedEvent:Connect(function(_,binding) MapToStateHandler(binding, 1) end)\nfunction StateMachine:SetBindingHandlers(handlers)\n    self.handlers = handlers\nend\n\nfunction StateMachine:MapToStateHandler(binding, handlerIndex, ...)\n    assert(handlerIndex and type(handlerIndex) == \"number\")\n    if not self.handlers[binding] then return end\n    local handler = self.handlers[binding][handlerIndex]\n    if self.currentState and self.currentState[handler] then\n        self.currentState[handler](self.currentState, ...)\n    end\nend\n\nfunction StateMachine:Connect(connectable, callback, event)\n    if connectable == Events then\n        self._maid:GiveTask(connectable.Connect(event, callback))\n    else\n        self._maid:GiveTask(connectable:Connect(callback))\n    end\nend\n\nlocal function _spawnUpdate(self, update)\n    return Task.Spawn(function()\n        while true do\n            local dt = Task.Wait()\n            local ok, m = pcall(update, self, dt)\n            if not ok then warn(string.format(\"result:%q message:%q\", ok, m)) end\n        end\n    end)\nend\n\n-- @arg nextState: State|string\nfunction StateMachine:GoToState(nextState, ...)\n    assert(nextState)\n    nextState = getmetatable(nextState) == State and nextState or self.states[nextState]\n    if nextState.Check and not nextState:Check() then return end\n    local previousState = self.currentState\n    if previousState and previousState.name == nextState then return end\n    if previousState and previousState.Exit then\n        REvents.Broadcast(previousState.exiting_event)\n        previousState:Exit()\n        REvents.Broadcast(previousState.exited_event)\n    end\n    self.currentState = nextState\n    if nextState.Enter then\n        REvents.Broadcast(nextState.entering_event)\n        nextState:Enter(previousState, ...)\n        REvents.Broadcast(nextState.entered_event)\n    end\n    self._maid.update = nextState.Update and _spawnUpdate(nextState, nextState.Update)\nend\n\nfunction StateMachine:AddState(name)\n    local state = setmetatable({\n        name=name,\n        _sm = self,\n        entering_event = string.format(\"%s:%s:Entering\", self.name, name),\n        exiting_event = string.format(\"%s:%s:Exiting\", self.name, name),\n        entered_event = string.format(\"%s:%s:Entered\", self.name, name),\n        exited_event = string.format(\"%s:%s:Exited\", self.name, name),\n        }, State)\n    self.states[name] = state\n    return state\nend\n\nfunction StateMachine:Destroy()\n    self._maid:Destroy()\nend\n\nreturn StateMachine"
      }
    }
    Assets {
      Id: 15795618890956269941
      Name: "_SpringAnimator"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    *Spring Animator* - \'fire and forget\' animation system with Core(TM) flavor.\n    Based on closed form ODE solver for damped harmonic oscillator (spring).\n    Copyright (C) 2021 Andrew Zhilin <andrew.zhilin@gmail.com>\n    https://github.com/zoon\n\n    Inspired by https://github.com/Fraktality/spr\n    Copyright (c) 2020 Parker Stebbins. All rights reserved.\n\n    Distributed under the MIT license.\n\n    NOTE: I\'m not happy with API, in the future we should use spr\'s wrap-unwrap technique and lua arrays.\n]]\n\n-- mostly for testing in console\nlocal CORE_ENV = CoreMath and CoreString\nlocal _DUMMY = CORE_ENV and World.GetRootObject()\n\nlocal EPS = 0.001 -- 0.0001 will stay awake a little longer\nlocal MIN_OFFSET_SQ = EPS*EPS\nlocal MIN_VELOCITY_SQ = EPS\n\nlocal PI_2 = 2*math.pi\nlocal exp, sqrt, sin, cos = math.exp, math.sqrt, math.sin, math.cos\nlocal ceil, floor = math.ceil, math.floor\nlocal _noop = function() return end\nlocal _weak_key_mt = {__mode=\"k\"}\nlocal _weak_val_mt = {__mode=\"v\"}\n\n-- @ spring_solver :: dt, damping, omega, pos, vel, goal -> pos\', vel\'\n-- Closed form ODE solver for damped harmonic oscillator.\n-- Taken from https://github.com/Fraktality/Spring\n--   dt: Delta time.\n--   dumping: Dumping factor.\n--     damping < 1 Underdamping: overshoots and converges on the goal.\n--     damping = 1 Critical damping: converges on the goal without overshooting.\n--     damping > 1 Overdamping: converges on the goal without overshooting, but slower.\n--   omega: angular frequency (2PI*frequency)\n-- pos, vel, goal: state veriables of \'number\' or \'vectorish\' type.\nlocal function spring_solver(dt, dumping, omega, pos, vel, goal)\n    local offset = pos - goal\n    local decay = exp(-dumping*omega*dt)\n\n    local pos_1, vel_1\n\n    if dumping == 1 then -- Critically damped\n        pos_1 = (offset*(1 + omega*dt) + vel*dt)*decay + goal\n        vel_1 = (vel*(1 - omega*dt) - offset*(omega*omega*dt))*decay\n\n    elseif dumping < 1 then -- Underdamped\n        local c = sqrt(1 - dumping*dumping)\n\n        local i = cos(omega*c*dt)\n        local j = sin(omega*c*dt)\n\n        -- Damping ratios approaching 1 can cause division by small numbers.\n        -- To fix that, group terms around z=j/c and find an approximation for z.\n        -- Start with the definition of z:\n        --    z = sin(dt*f*c)/c\n        -- Substitute a=dt*f:\n        --    z = sin(a*c)/c\n        -- Take the Maclaurin expansion of z with respect to c:\n        --    z = a - (a^3*c^2)/6 + (a^5*c^4)/120 + O(c^6)\n        --    z \342\211\210 a - (a^3*c^2)/6 + (a^5*c^4)/120\n        -- Rewrite in Horner form:\n        --    z \342\211\210 a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6\n\n        local z\n        if c > EPS then\n            z = j/c\n        else -- uncommon case\n            local a = dt*omega\n            z = a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6\n        end\n\n        -- Frequencies approaching 0 present a similar problem.\n        -- We want an approximation for y as f approaches 0, where:\n        --    y = sin(dt*f*c)/(f*c)\n        -- Substitute b=dt*c:\n        --    y = sin(b*c)/b\n        -- Now reapply the process from z.\n\n        local y\n        if omega*c > EPS then\n            y = j/(omega*c)\n        else -- uncommon case\n            local b = omega*c\n            y = dt + ((dt*dt)*(b*b)*(b*b)/20 - b*b)*(dt*dt*dt)/6\n        end\n\n        pos_1 = (offset*(i + dumping*z) + vel*y)*decay + goal\n        vel_1 = (vel*(i - z*dumping) - offset*(z*omega))*decay\n\n    else -- Overdamped\n        local c = sqrt(dumping*dumping - 1)\n\n        local r1 = -omega*(dumping - c)\n        local r2 = -omega*(dumping + c)\n\n        local co2 = (vel - offset*r1)/(2*omega*c)\n        local co1 = offset - co2\n\n        local e1 = co1*exp(r1*dt)\n        local e2 = co2*exp(r2*dt)\n\n        pos_1 = e1 + e2 + goal\n        vel_1 = e1*r1 + e2*r2\n    end\n\n    return pos_1, vel_1\nend\n\n-----------------------------------------------------------------------------\n-- Utility\n-----------------------------------------------------------------------------\n-- forward declaration\nlocal MinHeap = {}\nMinHeap.__index = MinHeap\nfunction MinHeap.New() return setmetatable({_n = 0, _pq= {}}, MinHeap) end\n\nlocal function _typeof(v)\n    local lua_type = type(v)\n    return (lua_type == \"userdata\" or lua_type == \"table\") and v.type and v.type or lua_type\nend\n\nlocal function _type(val, type, msg)\n    local tval = _typeof(val)\n    if tval == type then return true end\n    return false, string.format(\"%s(argument \'%s\' should be \'%s\')\", (msg..\": \") or \"\", tval, type)\nend\n\nlocal function _round_vec2(vec2)\n    local x, y = vec2.x, vec2.y\n    x = x >= 0 and floor(x + .5) or ceil(x - .5)\n    y = y >= 0 and floor(y + .5) or ceil(y - .5)\n    return x, y\nend\n\n-- Lerps color, maps t:[0,2] -> [0,1]\nlocal function _lerp_color_02(a, b, t)\n    t = t < 1 and t or 2 - t\n    return Color.Lerp(a, b, t)\nend\n\n-- Lerps numbers, maps t:[0,2] -> [0,1]\nlocal function _lerp_02(a, b, t)\n    t = t < 1 and t or 2 - t\n    return CoreMath.Lerp(a, b, t)\nend\n\n-- _SETTING_METHODS :: {[propkey] = {[get]=, [set]=, [wrap]=, [unwrap]=, [add]=, [lerp]=}}\n-- all deductable methods optional\nlocal _SETTING_METHODS = not CORE_ENV and {} or {\n    -- offset, size rotationAngle fo UIControl\n    offset = {\n        get=function(obj) return Vector2.New(obj.x, obj.y) end,\n        set=function(obj, vec2) obj.x, obj.y = _round_vec2(vec2) end,\n    },\n    size = {\n        get=function(obj) return Vector2.New(obj.width, obj.height) end,\n        set=function(obj, vec2) obj.width, obj.height = _round_vec2(vec2) end,\n    },\n    rotationAngle = {\n        get=function(obj) return obj.rotationAngle end,\n        set=function(obj, val) obj.rotationAngle = val end,\n    },\n    WorldRotation = {\n        wrap = function(rot) return Quaternion.New(rot) end,\n        unwrap = function(quat) return Rotation.New(quat) end,\n        add = function(q1, q2) return q1*q2 end,\n    },\n    Rotation = {\n        wrap = function(rot) return Quaternion.New(rot) end,\n        unwrap = function(quat) return Rotation.New(quat) end,\n        add = function(q1, q2) return q1*q2 end,\n    },\n    alpha = {\n        get=function(obj) local c = obj:GetColor() return c.a end,\n        set=function(obj, a) local c = obj:GetColor() c.a = a obj:SetColor(c) end,\n        lerp = _lerp_02\n    },\n    Color = {\n        -- CoreObject does not have Get/SetColor, CoreMesh does\n        get=function(obj)\n            return obj:GetColor()\n        end,\n        set=function(obj, c) obj:SetColor(c) end,\n        lerp = _lerp_color_02\n    },\n    -- `U` Prefix for \"User defined objects\"\n    UPosition = {\n        get=function(obj) return obj:GetPosition() end,\n        set=function(obj, v) obj:SetPosition(v) end,\n    },\n    UScale = {\n        get=function(obj) return obj:GetScale() end,\n        set=function(obj, v) obj:SetScale(v) end,\n    }\n}\n\nlocal function _get_setting_methods(propkey, instance)\n    instance = instance or _DUMMY -- NOTE: there is no dummy for UIControl\n    if not _SETTING_METHODS[propkey] then _SETTING_METHODS[propkey] = {} end\n    local methods = _SETTING_METHODS[propkey]\n    methods.get = methods.get or assert(instance[\"Get\" .. propkey], \"not found Get\" .. propkey)\n    methods.set = methods.set or assert(instance[\"Set\" .. propkey], \"not found Set\" .. propkey)\n    if not methods.lerp then\n        local val = methods.wrap and methods.wrap(methods.get(instance)) or methods.get(instance)\n        methods.lerp = assert(type(val) == \"number\" and CoreMath.Lerp or val.Lerp or val.Slerp, \"not found Lerp\")\n    end\n    return methods\nend\n\n-----------------------------------------------------------------------------\n-- SpringParams\n-----------------------------------------------------------------------------\nlocal SpringParams = {type=\"SpringParams\"}\nSpringParams.__index = SpringParams\n\n-- @SpringParams.New :: dampingRatio, frequency -> new SpringParams\n-- Encapsulates spring solver parameters.\n--  dampingRatio < 1 Underdamping: overshoots and converges on the goal.\n--  dampingRatio = 1 Critical damping: converges on the goal without overshooting.\n--  dampingRatio > 1 Overdamping: converges on the goal without overshooting, but slower.\n--  frequency: frequency in Hz.\nfunction SpringParams.New(dampingRatio, frequency, ...)\n    assert(select(\"#\", ...) == 0, \"too many arguments\")\n    assert(frequency >= EPS, frequency)\n    assert(_type(dampingRatio, \"number\", \"dampingRatio\"))\n    dampingRatio = dampingRatio >= 0 and dampingRatio or 0\n    return setmetatable({frequency=frequency, angularFrequency=PI_2*frequency, dampingRatio=dampingRatio}, SpringParams)\nend\n\n-- @ SpringParams.RandomizeFrequency: self[, factor=0.05] -> new SpringParams\n-- factor: randomizing factor, default: +-5%\nfunction SpringParams:RandomizeFrequency(factor)\n    factor = factor or 0.05\n    factor = math.max(0, math.min(factor, 1 - EPS))\n    if factor == 0 then return self:Copy() end\n    local r = 2*math.random() - 1 -- [-1, 1)\n    factor = r*factor\n    local d, f = self.dampingRatio, self.frequency\n    f = f + f*factor\n    return SpringParams.New(d, f)\nend\n\nfunction SpringParams:Copy()\n    return SpringParams.New(self.dampingRatio, self.frequency)\nend\n\n-----------------------------------------------------------------------------\n-- Spring: low-level explicit-state spring with update method\n-----------------------------------------------------------------------------\nlocal Spring = {type=\"Spring\"}\nSpring.__index = Spring\n\nlocal D_IDX, O_IDX, P_IDX,V_IDX, G_IDX = 1, 2, 3, 4, 5\n\n-- @Spring.New :: spring_params, position -> new Spring\n-- Creates new Spring in equlibrium state.\nfunction Spring.New(spring_params, position, ...)\n    assert(select(\"#\", ...) == 0, \"too many arguments\")\n    local tpos = _typeof(position)\n    if tpos ~= \"number\" and not (position.__mul and position.__sub) then\n        error(string.format(\"\'%s\' not supported multiplication and substraction\", tpos))\n    end\n    assert(_type(spring_params, SpringParams.type, \"spring_params\"))\n    local d, omega = spring_params.dampingRatio, spring_params.angularFrequency\n    local self = {nil, nil, nil, nil, nil}\n    self[D_IDX] = d\n    self[O_IDX] = omega\n    self[P_IDX] = position\n    self[V_IDX] = position*0\n    self[G_IDX] = position\n    return setmetatable(self, Spring)\nend\n\n-- internal Spring._unpack :: self -> dumping, omega, pos, vel, goal\nfunction Spring:_unpack()\n    -- 2x faster then table.unpack\n    return self[D_IDX], self[O_IDX], self[P_IDX], self[V_IDX], self[G_IDX]\nend\n\n-- internal Spring._set_pos_vel :: self, pos, vel ^-> nil\nfunction Spring:_set_pos_vel(pos,vel)\n    self[P_IDX], self[V_IDX] = pos, vel\nend\n\n-- @ Spring.Update :: self, dt ^-> pos\', vel\', goal\nfunction Spring:Update(dt)\n    local p, v = spring_solver(dt, self[D_IDX], self[O_IDX], self[P_IDX], self[V_IDX], self[G_IDX])\n    -- update state\n    self:_set_pos_vel(p, v)\n    return p, v\nend\n\n-- @ Spring.SetGoal :: self, goal ^-> self\nfunction Spring:SetGoal(goal)\n    self[G_IDX] = goal\n    return self\nend\n\nfunction Spring:SetPosition(position)\n    self[P_IDX] = position\n    return self\nend\n\nfunction Spring:SetVelocity(velocity)\n    self[V_IDX] = velocity\n    return self\nend\n\n-- @ Spring.SetGoalByOffset :: self, offset ^-> self\nfunction Spring:SetGoalByOffset(offset)\n    self[G_IDX] = self[P_IDX] + offset\nend\n\n-- @ Spring.SetParams :: self[, dumping, frequency] ^-> self\nfunction Spring:SetParams(dumping, frequency)\n    if dumping then self[D_IDX] = dumping end\n    if frequency then self[O_IDX] = PI_2*frequency end\n    return self\nend\n\n-- @ Spring.SetParams :: self, spring_params ^-> self\nfunction Spring:SetSpringParams(spring_params)\n    assert(_type(spring_params, SpringParams.type, \"spring_params\"))\n    self[D_IDX], self[O_IDX] = spring_params.dampingRatio, spring_params.angularFrequency\n    return self\nend\n\n-- @ Spring.GetPosition :: self -> position, velocity\nfunction Spring:GetPosition()\n    return self[P_IDX]\nend\n\nfunction Spring:GetVelocity()\n    return self[V_IDX]\nend\n\n-- @ Spring.GetAngularFrequency :: self -> omega\nfunction Spring:GetAngularFrequency()\n    return self[O_IDX]\nend\n\n-- @ Spring.AddImpulse :: self, velocity ^-> self\nfunction Spring:AddImpulse(velocity)\n    self[V_IDX] = self[V_IDX] + velocity\n    return self\nend\n\n-- @ Spring.Nudge :: self, radius ^-> self\n-- Adds impulse to radius direction, with undumped amplitude = 2*radius\nfunction Spring:Nudge(radius)\n    self[V_IDX] = self[V_IDX] + self[O_IDX]*radius\n    return self\nend\n\n-----------------------------------------------------------------------------\n-- Spring Animator - fire-and-forget property animator with chaining support\n-----------------------------------------------------------------------------\nlocal SpringAnimator = {type=\"SpringAnimator\"}\nSpringAnimator.__index = SpringAnimator\n-- `less` operator for scheduler\nfunction SpringAnimator.__lt(spr_anim1, spr_anim2) return spr_anim1._run_at < spr_anim2._run_at end\n\n---------------------------------------\n-- Spring Animator Internals\n---------------------------------------\n\n-- _springStates ::  {[instance(weak)] = {[property] = state}\nlocal _sa_states = setmetatable({}, _weak_key_mt)\nlocal _sa_scheduler = MinHeap.New()\nlocal _sa_states_active = false\nlocal _sa_scheduler_active = false\n\n-- forward declaration\nlocal _sa_worker, _sa_scheduler_worker\n\nlocal function _activate_sa_thread()\n    if not _sa_states_active then\n        _sa_states_active = true\n        Task.Spawn(_sa_worker)\n    end\nend\n\nlocal function _activate_sa_scheduler()\n    if not _sa_scheduler_active then\n        _sa_scheduler_active = true\n        Task.Spawn(_sa_scheduler_worker)\n    end\nend\n\nlocal function _sa_scheduler_add(spr_anim)\n    _sa_scheduler:Push(spr_anim)\n    _activate_sa_scheduler()\nend\n\nlocal function _sa_scheduler_remove(instance, propkey)\n    _sa_scheduler:_for_each(function(spr_anim)\n        if spr_anim:_get_instance() == instance and (not propkey or spr_anim._propkey == propkey) then\n            spr_anim._instance[1] = nil -- nil instance for (lazy) remove it later\n            local ok, msg = pcall(spr_anim._onCancel)\n            if not ok then warn(msg) end\n        end\n    end)\nend\n\nlocal function _sa_states_add(spr_anim)\n    if not spr_anim then return end\n    assert(_type(spr_anim, SpringAnimator.type, \"spr_anim\"))\n    local instance = spr_anim:_get_instance()\n    if not instance then return end\n    local propkey = spr_anim._propkey\n    if not _sa_states[instance] then\n        _sa_states[instance] = {}\n    end\n    local states = _sa_states[instance]\n    -- call `onCancel` on previous animation of this property\n    if states[propkey] then\n        local ok, msg = pcall(states[propkey]._onCancel)\n        if not ok then warn(msg) end\n        states[propkey] = nil\n    end\n    -- try to remove from scheduler too\n    _sa_scheduler_remove(instance, propkey)\n    -- actualize origin and goal\n    local methods = spr_anim._methods\n    local get, wrap, add = methods.get, methods.wrap, methods.add\n    local value = get(instance)\n    value = wrap and wrap(value) or value\n    spr_anim._origin = value\n    if spr_anim._goal then\n        spr_anim._goal = wrap and wrap(spr_anim._goal) or spr_anim._goal\n    elseif spr_anim._offset then\n        local offset = spr_anim._offset\n        offset = wrap and wrap(offset) or offset\n        spr_anim._goal = add and add(spr_anim._origin, offset) or spr_anim._origin + offset\n    elseif not spr_anim._goal then -- equilibrium, no goal was set\n        spr_anim._goal = spr_anim._origin\n    end\n    states[propkey] = spr_anim\n    _activate_sa_thread()\nend\n\n_sa_worker = function()\n    local _unpack = Spring._unpack\n    local _set_pos_vel = Spring._set_pos_vel\n    local _animations_to_run = {}\n    local _on_finish_to_run = {}\n\n    while _sa_states_active do\n        local dt = Task.Wait()\n        -- clean up invalid instances\n        for instance, _ in pairs(_sa_states) do\n            if instance and instance.IsValid and not instance:IsValid() then\n                -- it seems reasonble do not try to call \'onCancel\' here\n                _sa_states[instance] = nil\n            end\n        end\n        for instance, animations in pairs(_sa_states) do\n            for propkey, anim in pairs(animations) do\n                -- for our normalized offsets, p should be *precisely* at [0, 2], and goal at `1`\n                local spring = anim._spring\n                local d, o, p0, v0, _ = _unpack(spring)\n                local p, v = spring_solver(dt, d, o, p0, v0, 1)\n                -- clamp p to [0, 2] sharp - miniscule overshoots possible with zero dumping\n                p = p < 0 and 0 or p\n                p = p > 2 and 2 or p\n                local finish = v*v < MIN_VELOCITY_SQ and (p - 1)*(p - 1) < MIN_OFFSET_SQ\n                local t = not finish and p or 1\n                local lerp, set, unwrap = anim._methods.lerp, anim._methods.set, anim._methods.unwrap\n                local origin, goal = anim._origin, anim._goal\n                local value = anim._swap and lerp(goal, origin, t) or lerp(origin, goal, t)\n                value = unwrap and unwrap(value) or value\n                set(instance, value)\n\n                if not finish then\n                    _set_pos_vel(spring, p, v)\n                else -- finished\n                    animations[propkey] = nil\n                    -- move to next in chain/cycle\n                    if anim._next then\n                        anim._next:Reset()\n                        -- we can\'t mess with tables from within cycle\n                        _animations_to_run[#_animations_to_run+1] = anim._next\n                    end\n                    -- we can\'t mess with tables from within cycle\n                    _on_finish_to_run[#_on_finish_to_run+1] = anim._onFinish\n                end\n            end\n        end\n        -- call pending onFinish callbacks\n        for i = 1, #_on_finish_to_run do\n            local onFinish = _on_finish_to_run[i]\n            _on_finish_to_run[i] = nil\n            local ok, msg = pcall(onFinish)\n            if not ok then warn(\"ERROR: onFinish: \" .. msg) end\n        end\n        -- add pending animations\n        for i=1, #_animations_to_run do\n            local spr_anim = _animations_to_run[i]\n            _animations_to_run[i] = nil\n            spr_anim:Run()\n        end\n        -- clean-up finished instances\n        for instance, animations in pairs(_sa_states) do\n            if not next(animations) then _sa_states[instance] = nil end\n        end\n        if not next(_sa_states) then\n            _sa_states_active = false\n            break\n        end\n    end\nend\n\n_sa_scheduler_worker = function()\n    while not _sa_scheduler:IsEmpty() do\n        local spr_anim = _sa_scheduler:Peek()\n        if not spr_anim:_get_instance() then -- i.e marked to remove by scheduler or instance destroyed\n            _sa_scheduler:Pop()\n        elseif spr_anim._run_at <= time() then\n            _sa_scheduler:Pop()\n            spr_anim._run_at = 0\n            _sa_states_add(spr_anim)\n        else\n            Task.Wait(0.1) -- will check ~10 times per second\n        end\n    end\n    _sa_scheduler_active = false\nend\n\n---------------------------------------\n-- Spring Animator Public methods\n---------------------------------------\n-- TODO: add periodic params randomization: delay, freq\n-- TODO: cycle breaker\n-- TODO: smart properties support\n\n-- @ SpringAnimator.New :: SpringParams, instance, proprkey, random_cactor -> new SpringAnimator\n-- instance :: `CoreObject`, `UIControl` or user-object with according API.\n-- Constructs animation object and sets animation `origin` to current value of instance property.\n-- Supported propkeys for `CoreObject`: \'[World]Position\', \'[World]Rotation\', \'Scale\', \'Color\', \'alpha\'\n-- Supprted propkeys for `UIControl`: \'size\', \'offset\', \'rotationAndle\', \'Color\', \'alpha\'\nfunction SpringAnimator.New(spring_params, instance, propkey, random_factor)\n    assert(_type(spring_params, SpringParams.type, \"spring_params\"))\n    assert(instance and (type(instance) == \"userdata\" or type(instance) == \"table\"), \"no instance\")\n    if instance.IsValid and not instance:IsValid() then\n        error(\"invalid object instance\")\n    end\n    assert(_type(propkey, \"string\", \"propkey\"))\n    local self = spring_params:ToAnim(random_factor, random_factor)\n    self(instance)\n    -- target -----------------------------------\n    self._propkey = propkey\n    self._methods = _get_setting_methods(self._propkey, instance)\n    self._origin = nil\n    self._goal = nil\n    self._offset = nil\n    self._swap = false\n    return self\nend\n\n-- To make `SpringAnimator` from `SpringParams`\nfunction SpringParams:ToAnim(randomize, factor)\n    local anim = setmetatable({}, SpringAnimator)\n    anim._instance = setmetatable({}, _weak_val_mt)\n    local params = randomize and self:RandomizeFrequency(factor) or self:Copy()\n    anim._spring = Spring.New(params, 0)\n    -- save state for reset\n    anim._p0 = anim._spring:GetPosition()\n    anim._v0 = anim._spring:GetVelocity()\n    -- etc. -------------------------------------\n    anim._next = nil\n    anim._onFinish = _noop\n    anim._onCancel = _noop\n    anim._periodic_delay = 0\n    anim._run_at = 0\n    return anim\nend\n\n-- Next 4 methods are the new API\nfunction SpringAnimator:Target(propkey, goal)\n    self._propkey = propkey\n    self._methods = _get_setting_methods(self._propkey, self:_get_instance())\n    self:SetGoal(goal)\n    return self\nend\n\nfunction SpringAnimator:Offset(propkey, offset)\n    self._propkey = propkey\n    self._methods = _get_setting_methods(self._propkey, self:_get_instance())\n    self:SetGoalByOffset(offset)\n    return self\nend\n\nfunction SpringAnimator:Impulse(propkey, radius)\n    self._propkey = propkey\n    self._methods = _get_setting_methods(self._propkey, self:_get_instance())\n    self:Nudge(radius)\n    return self\nend\n\n-- To bind instance with premade SpringAnimator\n-- local premade = SpringParams.New(1,1):ToAnim():Impulse(50*Vector3.UP)\n-- ... premade(self._geo):Run()\nfunction SpringAnimator:__call(instance)\n    assert(instance)\n    self._instance[1] = instance\n    return self\nend\n\n-- @ SpringAnimator.SetPeriodicDelay :: self, delay:sec ^-> self\n-- Every time when animation run, it will wait `delay` second in scheduler.\nfunction SpringAnimator:SetPeriodicDelay(delay)\n    self._periodic_delay = delay\n    return self\nend\n\nfunction SpringAnimator:GetPeriodicDelay()\n    return self._periodic_delay, self._run_at\nend\n\n-- `onFinish` callback alled every time when animator reach equlibrium state (finished).\nfunction SpringAnimator:SetOnFinish(onFinish)\n    self._onFinish = onFinish\n    return self\nend\n\n-- `onCancel` callback called by SpringAnimator:Stop and for shcheduled animations by SpringAnimator:Finalize.\nfunction SpringAnimator:SetOnCancel(onCancel)\n    self._onCancel = onCancel\nend\n\n-- @ SpringAnimator.Chain :: self, SpringAnimator, ... ^-> self\n-- Runs next animation in chain when previous animation finished.\nfunction SpringAnimator:Chain(...)\n    local n = select(\"#\", ...)\n    assert(n > 0, \"no arguments to chain\")\n    assert(not self._next, \"already chained or cycled\")\n    local prev = self\n    for i = 1, n do\n        local spr_anim = select(i, ...)\n        assert(_type(spr_anim, SpringAnimator.type, \"spr_anim\"))\n        prev._next = spr_anim\n        prev = spr_anim\n    end\n    return self\nend\n\n-- @ SpringAnimator.Cycle :: self, SpringAnimator, ... ^-> self\n-- Chain with cycle, will be switched to next animation forever.\nfunction SpringAnimator:Cycle(...)\n    self:Chain(...)\n    local n = select(\"#\", ...)\n    local last = select(n, ...)\n    last._next = self\n    return self\nend\n\n-- @ SpringAnimator.Run :: self[, delay] ^-> nil\n-- Starts animation next frame or after `delay`, will add `delay` to `periodic delay` for this run.\nfunction SpringAnimator:Run(delay)\n    assert(self._periodic_delay)\n    delay = delay or 0\n    delay = self._periodic_delay + delay\n    if delay <= 0 then\n        _sa_states_add(self)\n    else\n        self._run_at = time() + delay\n        _sa_scheduler_add(self)\n    end\n    return self\nend\n\n-- @ SpringAnimator.Stop :: instance[, propkey]\n-- Stops animation (or all animations) of instance and lives instance as is.\n-- Removes animation from scheduler if it wasn\'t started.\n-- Calls `OnCancel` for each stopped or removed animation.\nfunction SpringAnimator.Stop(instance, propkey)\n    assert(instance.type ~= SpringAnimator.type, \"SpringAnimator.Stop is a static method: use `.` istead of `:`\")\n    local anims = _sa_states[instance]\n    if anims then\n        for pk, spr_anim in pairs(anims) do\n            if not propkey or propkey == pk then\n                local ok, msg = pcall(spr_anim._onCancel)\n                if not ok then warn(msg) end\n                anims[pk] = nil\n            end\n        end\n    end\n    -- remove from scheduler too (it\'s seems reasonable)\n    _sa_scheduler_remove(instance, propkey)\nend\n\n-- @ SpringAnimator.Finalize :: instance[, propkey] ^-> nil\n-- Forces animation (or all animations of instance) to reach the goal next frame.\n-- Removes animations from scheduler if it wasn\'t started, calls `OnCancel` for each removed animation.\nfunction SpringAnimator.Finalize(instance, propkey)\n    assert(instance.type ~= SpringAnimator.type, \"SpringAnimator.Stop is a static method: use `.` istead of `:`\")\n    local anims = _sa_states[instance]\n    if anims then\n        for pk, spr_anim in pairs(anims) do\n            if not propkey or propkey == pk then\n                spr_anim._spring:_set_pos_vel(1, 0)\n            end\n        end\n    end\n    -- remove from scheduler before it starts (it\'s seems reasonable)\n    _sa_scheduler_remove(instance, propkey)\nend\n\n-- Resets animation state (position and velocity).\nfunction SpringAnimator:Reset()\n    self._spring:_set_pos_vel(self._p0, self._v0)\n    return self\nend\n\nfunction SpringAnimator:_get_instance()\n    local instance  = self._instance and self._instance[1]\n    if instance and instance._IsValid and not instance:IsValid() then return nil end\n    return instance\nend\n\n-- Sets animation `goal` to goal value\nfunction SpringAnimator:SetGoal(goal)\n    self._goal = goal\n    return self\nend\n\n-- Sets animation goal by adding `offset` to itanstance\'s `origin` property value.\nfunction SpringAnimator:SetGoalByOffset(offset)\n    self._offset = offset\n    return self\nend\n\n-- Adds impulse to radius direction, with undumped amplitude = 2*radius\nfunction SpringAnimator:Nudge(radius)\n    self._offset = radius\n    -- swap origin and goal, set state to (p = 1, v = -omega)\n    self._swap = true\n    local omega = self._spring:GetAngularFrequency()\n    self._spring:_set_pos_vel(1, -omega)\n    -- save state for reset\n    self._p0 = self._spring:GetPosition()\n    self._v0 = self._spring:GetVelocity()\n    return self\nend\n\n-----------------------------------------------------------------------------\n-- Rest of definitions\n-----------------------------------------------------------------------------\ndo\n    local insert = table.insert\n    -- internal hacky method\n    function MinHeap:_for_each(callback)\n        local array, n = self._pq, self._n\n        for i = 1, n do\n            local el = array[i]\n            callback(el)\n        end\n    end\n    function MinHeap:Peek()\n        return self._pq[1]\n    end\n    function MinHeap:Count()\n        return self._n\n    end\n    function MinHeap:IsEmpty()\n        return self._n == 0\n    end\n    local function swim(k, pq)\n        while true do\n            local parent = math.floor(k/2)\n            if k > 1 and pq[k] < pq[parent] then\n                local temp = pq[k]\n                pq[k] = pq[parent]\n                pq[parent] = temp\n                k = parent\n            else\n              break\n            end\n        end\n    end\n    function MinHeap:Push(el)\n        local n = self._n + 1\n        self._n = n\n        local pq = self._pq\n        insert(pq, n, el)\n        swim(n, pq)\n        return self\n    end\n    local function sink(n, pq)\n        local k = 1\n        while 2*k <= n do\n            local child = 2*k\n            if child < n and pq[child + 1] < pq[child] then\n                child = child + 1\n            end\n            if not (pq[child] < pq[k]) then\n                break\n            end\n            local temp = pq[k]\n            pq[k] = pq[child]\n            pq[child] = temp\n            k = child\n        end\n    end\n    function MinHeap:Pop()\n        local n = self._n\n        if n == 0 then\n            return nil\n        end\n        local pq = self._pq\n        local result = pq[1]\n        pq[1] = pq[n]\n        pq[n] = nil\n        n = n - 1\n        sink(n, pq)\n        self._n = n\n        return result\n    end\n    function MinHeap:Clear()\n        local n = self._n\n        if n == 0 then return end\n        for i = n, 1, -1 do\n            self._pq[i] = nil\n        end\n        assert(#self._pq == 0)\n        self._n = 0\n    end\nend\n\n-- self test\nlocal function _self_test()\n    -- @ spring_solver :: dt, damping, omega, pos, vel, goal -> pos\', vel\', in_equilibrium\n    local d, f = 1, 1*PI_2\n    local p1, v1 = spring_solver(0.5, d, f, 0, 0, 1)\n    assert(math.abs(p1 - 0.82102555358593) < EPS)\n    assert(math.abs(v1 - 0.85300855576888) < EPS)\n    local p2, v2= spring_solver(0.5, d, f, p1, v1, 1)\n    assert(math.abs(p2 - 0.98639906853443) < EPS)\n    assert(math.abs(v2 - 0.07372368401459) < EPS)\n    d = 0.5\n    p1, v1 = spring_solver(0.5, d, f, 0, 0, 1)\n    assert(math.abs(p1 - 1.1406996741435) < EPS)\n    assert(math.abs(v1 - 0.61621768737322) < EPS)\n    p2, v2 = spring_solver(0.5, d, f, p1, v1, 1)\n    assert(math.abs(p2 - 0.98982212901474) < EPS)\n    assert(math.abs(v2 - -0.23383824515613) < EPS)\n\n    d = 1.5\n    p1, v1 = spring_solver(0.5, d, f, 0, 0, 1)\n    assert(math.abs(p1 - 0.75020554281012) < EPS)\n    assert(math.abs(v1 - 0.60014052697326) < EPS)\n    p2, v2= spring_solver(0.5, d, f, p1, v1, 1)\n    assert(math.abs(p2 - 0.92474819921701) < EPS)\n    assert(math.abs(v2 - 0.1806013825691) < EPS)\n\n    d, f = 1, 2*PI_2\n    p1, v1= spring_solver(0.5, d, f, 0, 0, 1)\n    assert(math.abs(p1 - 0.98639906853443) < EPS)\n    assert(math.abs(v1 - 0.14744736802918) < EPS)\n    p2, v2 = spring_solver(0.5, d, f, p1, v1, 1)\n    assert(math.abs(p2 - 0.99995268942114) < EPS) -- sleeps\n    assert(math.abs(v2 - 0.00055069903147113) < EPS)\n\n    -- Heap\n    local pq = MinHeap.New()\n    pq:Push(3):Push(1):Push(2):Push(4):Push(5)\n    assert(pq:Count() == 5 and #pq._pq == 5)\n    local out = {}\n    while not pq:IsEmpty() do\n        out[#out+1] = pq:Pop()\n    end\n    assert(pq:IsEmpty() and #pq._pq == 0)\n    assert(out[1] == 1 and out[2] == 2 and out[3] == 3 and out[4] == 4 and out[5] == 5)\n\n    --\n    print(\"spring animator -- ok\")\nend\n_self_test()\n\n-- exports\nSpringAnimator.SpringParams = SpringParams\nSpringAnimator.Spring = Spring\n-- export solver as-is\nSpringAnimator.spring_solver = spring_solver\nreturn SpringAnimator\n"
      }
    }
    Assets {
      Id: 7602836839952416252
      Name: "_Spr"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n   Copyright (c) 2020 Parker Stebbins. All rights reserved.\n   License & docs can be found at https://github.com/Fraktality/spr\n   Core version by https://github.com/zoon\n]]\n\nwarn(\"~~~~> _Spr.lua is DEPRECATED!\"..\'\\n\'..CoreDebug.GetStackTrace())\n\nlocal Spr = {}\nSpr.__index = Spr\n\nlocal pi = math.pi\nlocal exp = math.exp\nlocal sin = math.sin\nlocal cos = math.cos\nlocal sqrt = math.sqrt\nlocal EPS = 1e-5\nlocal SLEEP_OFFSET_SQ_LIMIT = 1e-4^2 -- (1/3840)^2\nlocal SLEEP_VELOCITY_SQ_LIMIT = 1e-2^2\n\n--[[\n    step: (dt, d, f, p, v) -> (p, v, sleep)\n    dt: simulation time step\n     `d`: damping ratio\n       * d < 1 Underdamping: overshoots and converges on the target.\n       * d = 1 Critical damping: converges on the target without overshooting.\n       * d > 1 Overdamping: converges on the target without overshooting, but slower.\n     `f`: undumped frequency in Hz\n     `p` and `v`: state veriables (position and velocity)\n    Note: goal is always equal to 1\n]]\nlocal function step(dt, d, f, p, v)\n    f = f*2*pi -- Hz -> Rad/s\n    local g = 1\n    local o = p - g\n\n    if d == 1 then -- critically damped\n        local q = exp(-f*dt)\n        local w = dt*q\n\n        local c0 = q + w*f\n        local c2 = q - w*f\n        local c3 = w*f*f\n\n        p = o*c0 + v*w + g\n        v = v*c2 - o*c3\n    elseif d < 1 then -- underdamped\n        local q = exp(-d*f*dt)\n        local c = sqrt(1 - d*d)\n\n        local i = cos(dt*f*c)\n        local j = sin(dt*f*c)\n\n        -- Damping ratios approaching 1 can cause division by very small numbers.\n        -- To mitigate that, group terms around z=j/c and find an approximation for z.\n        -- Start with the definition of z:\n        --    z = sin(dt*f*c)/c\n        -- Substitute a=dt*f:\n        --    z = sin(a*c)/c\n        -- Take the Maclaurin expansion of z with respect to c:\n        --    z = a - (a^3*c^2)/6 + (a^5*c^4)/120 + O(c^6)\n        --    z \342\211\210 a - (a^3*c^2)/6 + (a^5*c^4)/120\n        -- Rewrite in Horner form:\n        --    z \342\211\210 a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6\n\n        local z\n        if c > EPS then\n            z = j/c\n        else\n            local a = dt*f\n            z = a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6\n        end\n\n        -- Frequencies approaching 0 present a similar problem.\n        -- We want an approximation for y as f approaches 0, where:\n        --    y = sin(dt*f*c)/(f*c)\n        -- Substitute b=dt*c:\n        --    y = sin(b*c)/b\n        -- Now reapply the process from z.\n\n        local y\n        if f*c > EPS then\n            y = j/(f*c)\n        else\n            local b = f*c\n            y = dt + ((dt*dt)*(b*b)*(b*b)/20 - b*b)*(dt*dt*dt)/6\n        end\n        p = (o*(i + z*d) + v*y)*q + g\n        v = (v*(i - z*d) - o*(z*f))*q\n    else -- overdamped\n        local c = sqrt(d*d - 1)\n\n        local r1 = -f*(d - c)\n        local r2 = -f*(d + c)\n\n        local ec1 = exp(r1*dt)\n        local ec2 = exp(r2*dt)\n\n        local co2 = (v - o*r1)/(2*f*c)\n        local co1 = ec1*(o - co2)\n\n        p = co1 + co2*ec2 + g\n        v = co1*r1 + co2*ec2*r2\n    end\n    o = p - g\n    return p, v, o*o < SLEEP_OFFSET_SQ_LIMIT and v*v < SLEEP_VELOCITY_SQ_LIMIT\nend\n\nfunction Spr.New(dumping, frequency)\n    dumping, frequency = dumping or 1, frequency or 1\n    assert(dumping >= 0 and frequency >= 0)\n    return setmetatable({dumping=dumping, frequency=frequency}, Spr)\nend\n\nlocal _springStates = setmetatable({}, {__mode=\"k\"})\n\nlocal function _getPropValue(obj, propkey)\n    local m = \'Get\' .. propkey\n    assert(propkey and obj[m])\n    return obj[m](obj)\nend\n\nlocal function _setPropValue(obj, propkey, value)\n    if propkey:find(\"Rotation\") then value = Rotation.New(value) end\n    local m = \'Set\' .. propkey\n    assert(propkey and obj[m])\n    obj[m](obj, value)\nend\n\nlocal function _getLerp(prop)\n    local type = type(prop)\n    if type == \'userdata\' then return prop.Lerp or prop.Slerp end\n    if type == \'number\' then return CoreMath.Lerp end\nend\n\nlocal _ACTIVE = false\nlocal function _trampoline()\n    print(\"!~~~> Spr trampoline STARTED\", Task.GetCurrent(), time())\n    while _ACTIVE do\n        local dt = Task.Wait()\n        -- pre clean-up unvalid objects\n        for obj, _ in pairs(_springStates) do\n            if not obj:IsValid() then _springStates[obj] = nil end\n        end\n        -- run step\n        for obj, states in pairs(_springStates) do\n            for propkey, pstate in pairs(states) do\n                -- step: (dt, d, f, p, v) -> (p, v, sleep)\n                local p, v, sleep = step(dt, pstate.d, pstate.f, pstate.p, pstate.v)\n                _setPropValue(obj, propkey, pstate.lerp(pstate.origin, pstate.goal, not sleep and p or 1))\n                if sleep then\n                    states[propkey] = nil\n                    if pstate.onsleep then\n                        local onsleep = pstate.onsleep\n                        pstate.onsleep = nil\n                        assert(type(onsleep) == \'function\', \"onsleep should be a function\")\n                        onsleep()\n                    end\n                else\n                    pstate.p = p\n                    pstate.v = v\n                end\n            end\n        end\n        -- post clean-up finished objects\n        for obj, states in pairs(_springStates) do\n            if not next(states) then\n                _springStates[obj] = nil\n            end\n        end\n        if not next(_springStates) then\n            _ACTIVE = false\n        end\n    end\n    print(\"!~~~> Spr trampoline STOPPED\", Task.GetCurrent(), time())\nend\n\nlocal function activate()\n    if _ACTIVE then return end\n    _ACTIVE = true\n    Task.Spawn(_trampoline)\nend\n\n--[[\nTODO: some schema for extending + random stream (?)\nlocal params = {\n    StartDelay = {},  -- delay or range [from, to]\n    IterationDelay = {}, -- delay of range [from, to]\n    RandomizeDumping = {}, -- factor of [from,to] range\n    RandomizeFrequency = {}, -- factor of [from,to] range\n    Iterations = -1, -- count or -1 for infinite\n    PingPong = true, -- bool\n    OnSleap = function() end\n}\n--]]\n\n-- TODO: smarts\nfunction Spr:Target(obj, propkey, goal, onsleep)\n    assert(propkey and type(propkey) == \'string\', \"no propkey\")\n    if not _springStates[obj] then\n        _springStates[obj] = {}\n    end\n    local states = _springStates[obj]\n    if not states[propkey] then\n        states[propkey] = {}\n        activate()\n    end\n    local rot = propkey:find(\"Rotation\")\n    local pstate = states[propkey]\n    local current_value = _getPropValue(obj, propkey)\n    pstate.d = self.dumping\n    pstate.f = self.frequency\n    pstate.origin = not rot and current_value or Quaternion.New(current_value)\n    pstate.goal = not rot and goal or Quaternion.New(goal)\n    pstate.lerp = assert(_getLerp(pstate.origin), \"no Lerp\")\n    pstate.p = 0\n    pstate.v = 0\n    pstate.onsleep = onsleep\n    return current_value\nend\n\nfunction Spr:Randomize(factor)\n    factor = factor or 0.05\n    factor = factor*(2*math.random() - 1)\n    local d, f = self.dumping, self.frequency\n    f = f*(1 + factor)\n    return Spr.New(d, f)\nend\n\n-- stops animating of prop or all props\nfunction Spr.Stop(obj, propkey)\n    if not propkey then _springStates[obj] = nil end\n    local states = _springStates[obj]\n    if states then states[propkey] = nil end\nend\n\n-- sets animation to reach the goal in 1 frame\nfunction Spr.Finalize(obj, propkey)\n    local states = _springStates[obj]\n    if not states then return end\n    for pk, ps in pairs(states) do\n        if not propkey or propkey == pk then\n            ps.p = 1\n            ps.v = 0\n        end\n    end\nend\n\n-- self test\nlocal function _self_test()\n    local d, f = 1, 1\n    local p1, v1, s1 = step(0.5, d, f, 0, 0)\n    assert(not s1 and math.abs(p1 - 0.82102555358593) < EPS)\n    assert(math.abs(v1 - 0.85300855576888) < EPS)\n    local p2, v2, s2 = step(0.5, d, f, p1, v1)\n    assert(not s2 and math.abs(p2 - 0.98639906853443) < EPS)\n    assert(math.abs(v2 - 0.07372368401459) < EPS)\n    d = 0.5\n    p1, v1, s1 = step(0.5, d, f, 0, 0)\n    assert(not s1 and math.abs(p1 - 1.1406996741435) < EPS)\n    assert(math.abs(v1 - 0.61621768737322) < EPS)\n    p2, v2, s2 = step(0.5, d, f, p1, v1)\n    assert(not s2 and math.abs(p2 - 0.98982212901474) < EPS)\n    assert(math.abs(v2 - -0.23383824515613) < EPS)\n    d = 1.5\n    p1, v1, s1 = step(0.5, d, f, 0, 0)\n    assert(not s1 and math.abs(p1 - 0.75020554281012) < EPS)\n    assert(math.abs(v1 - 0.60014052697326) < EPS)\n    p2, v2, s2 = step(0.5, d, f, p1, v1)\n    assert(not s2 and math.abs(p2 - 0.92474819921701) < EPS)\n    assert(math.abs(v2 - 0.1806013825691) < EPS)\n    d, f = 1, 2\n    p1, v1, s1 = step(0.5, d, f, 0, 0)\n    assert(not s1 and math.abs(p1 - 0.98639906853443) < EPS)\n    assert(math.abs(v1 - 0.14744736802918) < EPS)\n    p2, v2, s2 = step(0.5, d, f, p1, v1)\n    assert(s2 and math.abs(p2 - 0.99995268942114) < EPS) -- sleeps\n    assert(math.abs(v2 - 0.00055069903147113) < EPS)\n\nend\n_self_test()\n\n-- exports\nSpr.step = step\nif Environment and Environment.IsServer() then\n    Spr = {step = step}\nend\nreturn Spr"
      }
    }
    Assets {
      Id: 4739659780833170311
      Name: "_Snippets"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    Lua 5.3 bits, little snippets and notes\n    * https://www.ilikebigbits.com/2015_03_04_plane_from_points.html\n    * What in C is (i % N) in Lua must become ((i-1)%N + 1).\n    * [de]serialize set of ints: utf8.char <-> utf8.codepoint. Max int = 2^21 (~2E+6).\n    * TODO: For inspiration: https://github.com/rxi/lume/blob/master/lume.lua\n    * math.random :: (nil) -> [0,1) | (a:int, b:int) -> [a,b] | (n:int) -> [1, n]\n--]]\n\nlocal CORE_ENV = CoreString and CoreMath\n\nlocal PI_2 = 2*math.pi\n\nlocal pairs, ipairs = pairs, ipairs\nlocal rand = math.random\nlocal abs, sqrt, cos, sin, log = math.abs, math.sqrt, math.cos, math.sin, math.log\nlocal ceil, floor = math.ceil, math.floor\nmath.randomseed(os.time())\n\nlocal snippets = {}\n\nlocal clock do\n    if not CORE_ENV then\n        local ok, socket = pcall(require, \"socket\")\n        clock = ok and socket.gettime or os.clock\n    else\n        clock = os.clock\n    end\nend\nsnippets.clock = clock\n\n-- formatting\nfunction snippets.formatOrdinal(n)\n    assert(n >= 1)\n    local num = string.format(\"%d\", n//1)\n    local last2 = string.sub(num, -2)\n    if last2 == \"11\" then return num .. \"th\" end\n    if last2 == \"12\" then return num .. \"th\" end\n    if last2 == \"13\" then return num .. \"th\" end\n    local last = string.sub(num, -1)\n    if last == \"1\" then return num .. \"st\" end\n    if last == \"2\" then return num .. \"nd\" end\n    if last == \"3\" then return num .. \"rd\" end\n    return num .. \'th\'\nend\n\n-- timestamps\nlocal os_time, os_date = os.time, os.date\nlocal function utc_timestamp()\n    return os_time(os_date\"!*t\")\nend\n\nlocal function format_timestamp(timestamp)\n    local d = os_date(\"!*t\", timestamp)\n    return string.format(\"%04d-%02d-%02d %02d:%02d:%02d\", d.year, d.month, d.day, d.hour, d.min, d.sec)\nend\nsnippets.utc_timestamp = utc_timestamp\nsnippets.format_timestamp = format_timestamp\n\n-- rounds toward zero\nfunction snippets.round(x)\n    return x >= 0 and floor(x + 0.5) or ceil(x - 0.5)\nend\n\n-- ZigZag encoding for negative integers\n-- https://en.wikipedia.org/wiki/Variable-length_quantity#Zigzag_encoding\nlocal function zigzag_encode(i)\n    assert(abs(i) < 0x80000000, \"abs(i) >= 2^31\") -- 2^31\n    return (i << 1 & 0xFFFFFFFF) ~ (i >> 31 & 0xFFFFFFFF)\nend\n\nlocal function zigzag_decode(i)\n    return (i >> 1) ~ -(i & 1)\nend\n\nsnippets.zigzag_encode = zigzag_encode\nsnippets.zigzag_decode = zigzag_decode\n\n\n-- Table optimizations\n-- ar_swap_remove: remove and swap with last element of array, O(1) and 10x faster then table.remove\nfunction snippets.array_swap_remove(ar, idx)\n    local n = #ar\n    local res = ar[idx]\n    ar[idx] = ar[n]\n    ar[n] = nil\n    return res\nend\n\nfunction snippets.table_clear(t)\n    -- NOTE: idiomatic way to `erase & modify` table (using `pairs` will cause errors if `t[k] = nil` has side effects to `t`)\n    local k, v = next(t)\n    while v ~= nil do\n        t[k] = nil\n        -- use k, v and modify table here ...\n        k, v = next(t)\n    end\nend\n\nfunction snippets.array_clear(ar)\n    local n = #ar\n    for i=n, 1, -1 do ar[i] = nil end\nend\n\n -- Fisher-YatesS shaffle (https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)\nfunction snippets.array_shuffle(ar)\n\tfor i = #ar, 2, -1 do\n\t\tlocal r = rand(i)\n\t\tar[i], ar[r] = ar[r], ar[i]\n\tend\n\treturn ar\nend\n\n\n-- insertion sort: stable, effective for near-sorted arrays\ndo\n    local function _less(lhs, rhs) return lhs < rhs end\n\n    function snippets.array_sort(array, compare)\n        compare = compare or _less\n        local n = #array\n        for i = 2, n do\n            local key = array[i]\n            local j = i - 1\n            while j > 0 and compare(key, array[j]) do\n                array[j + 1] = array[j]\n                j = j - 1\n            end\n            array[j + 1] = key\n        end\n        return array\n    end\nend\n-- pythonic uniform\nlocal function uniform(a, b)\n    assert(a < b, \"empty interval\")\n    return a + (b-a)*rand()\nend\nsnippets.uniform = uniform\n\n-- gamma-corrected: rand^gamma, practical range for gamma: [3, 0.3]\nfunction snippets.skewed(a, b, gamma)\n    assert(a < b, \"empty interval\")\n    assert(gamma and type(gamma) == \"number\", \"gamma undefined\")\n    local r = rand()\n    return a + (b-a)*r^gamma\nend\n\n-- https://eli.thegreenplace.net/2010/01/22/weighted-random-generation-in-python\nfunction snippets.weightedchoice(t)\n    local sum = 0\n    for _, w in pairs(t) do sum = sum + w end\n    local rnd = uniform(0, sum)\n    for k, w in pairs(t) do\n        rnd = rnd - w\n        if rnd < 0 then return k end\n    end\nend\n\ndo\n    local NIBBLES = {[0]=\n        \"0000\", \"0001\", \"0010\", \"0011\",\n        \"0100\", \"0101\", \"0110\", \"0111\",\n        \"1000\", \"1001\", \"1010\", \"1011\",\n        \"1100\", \"1101\", \"1110\", \"1111\",\n    }\n\n    -- converts integer to binary string\n    function snippets.bitstr(v, sep, width, out)\n        assert(math.type(v) == \"integer\")\n        width = width or 32\n        assert(math.type(width) == \"integer\" and width%8 == 0, \"`width` should be 8, 16, 24, 32 or 64\")\n        sep, out = sep or \' \', out or {}\n        for b=(width//8 - 1), 0, -1 do\n            local byte = v >> 8*b & 0xFF\n            out[#out+1] = NIBBLES[byte >> 4 & 0xF]\n            out[#out+1] = NIBBLES[byte & 0xF]\n        end\n        return table.concat(out, sep)\n    end\nend\n\nlocal popcount32, popcount64 do\n    -- https://en.wikipedia.org/wiki/Hamming_weight\n    -- NOTE: popcount (without assert) 50% faster then 8-bit table lookup\n\n    popcount64 = function(i64)\n        -- assert(math.type(i64) == \"integer\")\n        i64 = i64 - (i64 >> 1) & 0x5555555555555555\n        i64 = (i64 & 0x3333333333333333) + ((i64 >> 2) & 0x3333333333333333)\n        i64 = (i64 + (i64 >> 4)) & 0x0F0F0F0F0F0F0F0F\n        return (i64 * 0x0101010101010101) >> 56\n    end\n\n    popcount32 = function(i32)\n        -- assert(math.type(i32) == \"integer\" and i32 >= -2147483648 and i32 <= 2147483647)\n        i32 = i32 - ((i32 >> 1) & 0x55555555)\n        i32 = (i32 & 0x33333333) + ((i32 >> 2) & 0x33333333)\n        i32 = (i32 + (i32 >> 4)) & 0x0F0F0F0F\n        return ((i32 * 0x01010101) & 0xFFFFFFFF) >> 24\n    end\nend\n\nsnippets.popcount32 = popcount32\nsnippets.popcount64 = popcount64\n\n-- measure the time and memory consumption of the thunk execution\nlocal function perfn(tag, times, thunk)\n    if not CORE_ENV then\n        collectgarbage(\"collect\")\n        collectgarbage(\"stop\")\n    end\n    local m1 = collectgarbage(\"count\")\n    local t1 = clock()\n    local result = nil\n    for i = 1, times do\n        result = thunk()\n    end\n    local t2 = clock()\n    local m2 = collectgarbage(\"count\")\n    if not CORE_ENV then\n        collectgarbage(\"restart\")\n    end\n    local tmstr = string.format(\"time: %0.4fs mem: %0.2fK\", t2 - t1, m2-m1)\n    if times <= 1 then\n        print(\"REPF:\", tag, tmstr)\n    else\n        print(string.format(\"PERF: %d\", times), tag, tmstr)\n    end\n    return result\nend\n\nlocal function perf(tag, thunk)\n    return perfn(tag, 1, thunk)\nend\n\nsnippets.perfn = perfn\nsnippets.perf = perf\n\n-- https://community.khronos.org/t/zoom-to-fit-screen/59857/12\nfunction snippets.fitSphereToCamera(r, fov)\n    local scr = UI.GetScreenSize()\n    local halfMinFov = 0.5 * math.rad(fov)\n    local aspect = scr.x/scr.y\n    if aspect < 1 then\n        halfMinFov = math.atan(aspect * math.tan(halfMinFov))\n    end\n    return r / math.sin(halfMinFov)\nend\n\n-- assumes obj attached to local view (in Core sence)\nfunction snippets.ScreenPosition(obj, w3d, w2d, fov, x, y, tocam)\n    local res = UI.GetScreenSize()\n    local wx, wy = res.x, res.y\n    fov, x, y = fov or 90, x or wx//2, y or wy//2\n    local xf = math.tan(fov*math.pi/360)\n    local yf = xf * wy / wx\n    local depth = 0.5*w3d/w2d*wx/xf\n    local xo = xf*depth*(x/wx*2 - 1)\n    local yo = -yf*depth*(y/wy*2 - 1)\n    local offset = Vector3.New(depth, xo, yo)\n    obj:SetPosition(offset)\n    if tocam then\n        obj:SetRotation(Rotation.New(-offset, Vector3.UP))\n    end\nend\n\n-- table deepcopy from lua wiki\nlocal function deepcopy(orig)\n    local orig_type = type(orig)\n    local copy\n    if orig_type == \'table\' then\n        copy = {}\n        for orig_key, orig_value in next, orig, nil do\n            copy[deepcopy(orig_key)] = deepcopy(orig_value)\n        end\n        setmetatable(copy, deepcopy(getmetatable(orig)))\n    elseif orig_type == \'userdata\' then\n        local new = orig.New or orig.new -- TODO: should we allow shared references to CoreObjects?\n        assert(new, \"there is no copy constructor for `userdata`\")\n        copy = new(orig)\n    else -- number, string, boolean, etc\n        copy = orig\n    end\n    return copy\nend\nsnippets.deepcopy = deepcopy\n\n\n-----------------------------------------------------------------------------\n-- Core specific\n-----------------------------------------------------------------------------\n\n-- pass value to observer before subscribe, like Rx\'s subject\nfunction snippets.Subject(obj, networkedProperty, callback)\n    assert(CORE_ENV)\n    local wrapped = function(coreObject, propertyName)\n        if networkedProperty == propertyName then\n             callback(coreObject:GetCustomProperty(networkedProperty))\n        end\n    end\n    wrapped(obj, networkedProperty)\n    return obj.networkedPropertyChangedEvent:Connect(wrapped)\nend\n\n-- call thunk immediately (not at the end of frame) in it\'s own thread\nlocal FAST_SPAWN_INTERNAL_EVENT = \"%%fastSpawn\"\nfunction snippets.fastSpawn(thunk)\n    local connection do\n        connection = Events.Connect(FAST_SPAWN_INTERNAL_EVENT, function()\n            connection:Disconnect()\n            thunk()\n        end)\n    end\n    Events.Broadcast(FAST_SPAWN_INTERNAL_EVENT)\nend\n\nreturn snippets"
      }
    }
    Assets {
      Id: 14454691258374778668
      Name: "_ReliableEvents"
      PlatformAssetType: 3
      TextAsset {
        Text: "local ReliableEvents = {}\r\nReliableEvents.__index = ReliableEvents\r\n\r\nlocal pack, unpack = table.pack, table.unpack\r\n\r\n-- simple queue from PIL\r\nlocal queue = {}\r\nqueue.__index = queue\r\nfunction queue.new()\r\n    return setmetatable({first=0, last=-1, q = {}}, queue)\r\nend\r\nfunction queue:empty()\r\n    return self.first > self.last\r\nend\r\nfunction queue:push(val)\r\n    local last = self.last + 1\r\n    self.last = last\r\n    self.q[last] = val\r\nend\r\nfunction queue:pop()\r\n    local first = self.first\r\n    local result = self.q[first]\r\n    self.q[first] = nil\r\n    self.first = first + 1\r\n    return result\r\nend\r\nfunction queue:peek()\r\n    return self.q[self.first]\r\nend\r\n\r\n-----------------------------------------------------------------------------\r\n-- Client-Server events\r\n-----------------------------------------------------------------------------\r\nlocal BroadcastFactory do\r\n\r\n    local txqueue = queue:new()\r\n    local FEWEST_WARNINGS_INTERVAL = 0.90 -- empirical constant\r\n\r\n    local function retry()\r\n        Task.Spawn(function()\r\n            while not txqueue:empty() do\r\n                local message = txqueue:peek()\r\n                local broadcast = Events[message.method]\r\n                local result, _ = broadcast(unpack(message))\r\n                if result == BroadcastEventResultCode.EXCEEDED_RATE_LIMIT then\r\n                    Task.Wait(FEWEST_WARNINGS_INTERVAL)\r\n                else\r\n                    txqueue:pop()\r\n                end\r\n            end\r\n        end)\r\n    end\r\n\r\n    local function _push_event(method, ...)\r\n        local event = pack(...)\r\n        event.method = method\r\n        txqueue:push(event)\r\n    end\r\n\r\n    BroadcastFactory = function(method)\r\n        return function (...)\r\n            local event = select(1, ...)\r\n            if not event or type(event) ~= \"string\" then\r\n                warn(\"ERROR: first argumenst have to be \'event\' string\\n\" .. CoreDebug.GetStackTrace())\r\n                return\r\n            end\r\n            if txqueue:empty() then\r\n                local result, _ = Events[method](...)\r\n                if result == BroadcastEventResultCode.EXCEEDED_RATE_LIMIT then\r\n                    _push_event(method, ...)\r\n                    retry()\r\n                end\r\n            else\r\n                _push_event(method, ...)\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\n-----------------------------------------------------------------------------\r\n-- Local events\r\n-----------------------------------------------------------------------------\r\nlocal Broadcast do\r\n\r\n    local txqueue = queue:new()\r\n    local _in_trampoline = false\r\n\r\n    -- for the nested events, we broadcast them in breadth-first order\r\n    Broadcast = function(...)\r\n        local event = select(1, ...)\r\n        if not event or type(event) ~= \"string\" then\r\n            warn(\"Bad argument to brodcast\\n\" .. CoreDebug.GetStackTrace())\r\n            return\r\n        end\r\n        if not _in_trampoline then\r\n        _in_trampoline = true\r\n            Events.Broadcast(...)\r\n        else\r\n            txqueue:push(pack(...))\r\n            return -- !\r\n        end\r\n        while not txqueue:empty() do\r\n            Events.Broadcast(unpack(txqueue:pop()))\r\n        end\r\n        _in_trampoline = false\r\n    end\r\nend\r\n\r\n-- exports\r\nReliableEvents.BroadcastToServer = BroadcastFactory(\"BroadcastToServer\")\r\nReliableEvents.BroadcastToPlayer = BroadcastFactory(\"BroadcastToPlayer\")\r\nReliableEvents.BroadcastToAllPlayers = BroadcastFactory(\"BroadcastToAllPlayers\")\r\nReliableEvents.Broadcast = Broadcast\r\n\r\n_test = function()\r\n    do -- test order of nested events\r\n        local out = {}\r\n        Events.Connect(\"_x_Test_A\", function()\r\n            ReliableEvents.Broadcast(\"_x_Test_B\", \"A\")\r\n            ReliableEvents.Broadcast(\"_x_Test_C\", \"A\")\r\n            out[#out+1] = \"A\"\r\n        end)\r\n        Events.Connect(\"_x_Test_B\", function()\r\n            ReliableEvents.Broadcast(\"_x_Test_C\", \"B\")\r\n            out[#out+1] = \"B\"\r\n        end)\r\n        Events.Connect(\"_x_Test_C\", function()\r\n            out[#out+1] = \"C\"\r\n        end)\r\n        ReliableEvents.Broadcast(\"_x_Test_A\")\r\n        assert(out[1] == \"A\" and out[2] == \"B\" and out[3] == \"C\" and out[4] == \"C\")\r\n    end\r\n    print(\"reliable events -- ok\")\r\nend\r\n\r\n_test()\r\n\r\nreturn ReliableEvents\r\n"
      }
    }
    Assets {
      Id: 10304107291754736192
      Name: "_Maid"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    * License: MIT\n    * Based on Quenty\'s Maid:\n        https://github.com/Quenty/NevermoreEngine/blob/version2/Modules/Shared/Events/Maid.lua\n    * Manages the cleaning of events and other things.\n    * Useful for encapsulating state and make deconstructors easy.\n    * Adapted for Core by zoon (https://github.com/zoon).\n    * Supports (and do all necessary checks for):\n        - regular callbacks (call them on Maid:Destroy())\n        - CoreObject (:Destroy)\n        - Events and Hooks (:Disconnect)\n        - Tasks (:Cancel)\n        - any type that realize any of this methods\n    * Usage (in Core):\n    local Maid = require(`some_muid:Maid.lua`)\n    -- will call _maid:OnDestroy() when this `script` is destroyed\n    local _maid = Maid.New(script)\n    ...\n    _maid.cool_event_connection = Events.Connect(\"MyCoolEvent\", OnMyCoolEvent)\n    -- diconnect MyCoolEvent after 1 sec\n    Task.Wait(1)\n    _maid.cool_event_connection = nil\n    -- will destroy spawned object when _maid:Destroy() is called\n    _maid:GiveTask(World.SpawnAsset(SOME_TEMPLATE))\n    _maid.my_cool_pet = World.SpawnAssets(BRONZE_PET_TEMPLATE)\n    ...\n    -- will destroy instance of BRONZE_PET_TEMPLATE and keep the ref to SILVER_PET_TEMPLATE instance\n    _maid.my_cool_pet = World.SpawnAssets(SILVER_PET_TEMPLATE)\n    * Quenty has a good post about Maid:\n    https://medium.com/roblox-development/how-to-use-a-maid-class-on-roblox-to-manage-state-651bf74de98b\n    * For people with Unity background: Maid is like Rx\'s CompositeDisposable on steroids.\n]]\n\nlocal CORE_ENV = CoreString and CoreMath\nlocal stacktrace = (CORE_ENV and CoreDebug.GetStackTrace) or debug.traceback\nlocal warn = warn or print\n\nlocal Maid = {type=\"Maid\"}\nMaid.__index = Maid\n\n--- Returns a new Maid object that can be connected to `destroyEvent` of any Core object\n-- @return Maid\nfunction Maid.New(coreObject)\n    local self = setmetatable({_tasks = {}}, Maid)\n    if CORE_ENV and coreObject then\n        self:GiveTask(coreObject.destroyEvent:Connect(self))\n    elseif coreObject then\n        warn(\"Outside Core argument will be ignored\")\n    end\n    return self\nend\n\n--- Returns Maid[key] if not part of Maid metatable\n-- @return Maid[key] value\nfunction Maid:__index(index)\n    if Maid[index] then\n        return Maid[index]\n    else\n        return self._tasks[index]\n    end\nend\n\nlocal function _cleanupTask(task)\n    if task == nil then return end\n\n    if type(task) == \"function\" then\n        task()\n    elseif type(task) == \'userdata\' and CORE_ENV then\n        -- Core types:\n        if (task:IsA(\"EventListener\") or task:IsA(\"HookListener\")) and task.isConnected then\n            task:Disconnect()\n        elseif task:IsA(\"CoreObject\") and task:IsValid() then\n            task:Destroy()\n        elseif task:IsA(\"Task\") then\n            task:Cancel()\n        end\n    else\n        -- user types, assume thet `table type` or `userdata type` are not Core objects\n        if task.Disconnect then\n            task:Disconnect()\n        elseif task.Cancel then\n            task:Cancel()\n        elseif task.Destroy then\n            task:Destroy()\n        end\n    end\nend\n\nlocal function _check(task)\n    if task and (type(task) == \"table\" or type(task) == \"userdata\") and\n        not (task.Destroy or task.Cancel or task.Disconnect) then\n        warn(\"[Maid][Warning] - Gave task without Destroy|Cancel|Disconnect\\n\\n\" .. stacktrace())\n    end\n    return task\nend\n\n--- Add a task to clean up. Tasks given to a maid will be cleaned when\n--  maid[index] is set to a different value.\n-- @usage\n-- Maid[key] = (function)         Adds a task to perform\n-- Maid[key] = (event connection) Manages an event connection\n-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.\n-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method\n-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,\n--                                it is destroyed.\nfunction Maid:__newindex(index, newTask)\n    if Maid[index] ~= nil then\n        error((\"\'%s\' is reserved\"):format(tostring(index)), 2)\n    end\n\n    local tasks = self._tasks\n    local oldTask = tasks[index]\n\n    if oldTask == newTask then\n        return\n    end\n    tasks[index] = _check(newTask)\n    _cleanupTask(oldTask)\nend\n\nfunction Maid:__call()\n    self:Destroy()\nend\n\n--- Same as indexing, but uses an incremented number as a key.\n-- @param task An item to clean\n-- @treturn number taskId\nfunction Maid:GiveTask(task)\n    if self.type ~= \"Maid\" then\n        error(\"Maid -- don\'t forget `:`\", 2)\n    end\n    if not task then\n        error(\"Maid -- task cannot be false or nil\", 2)\n    end\n    local taskId = #self._tasks+1\n    self[taskId] = task\n\n    return taskId\nend\n\n--[[ TODO: implement promise module and wire it here\nfunction Maid:GivePromise(promise)\n    if not promise:IsPending() then\n        return promise\n    end\n    local newPromise = promise.resolved(promise)\n    local id = self:GiveTask(newPromise)\n    -- Ensure GC\n    newPromise:Finally(function()\n        self[id] = nil\n    end)\n    return newPromise\nend\n--]]\n\n--- Cleans up all tasks\nfunction Maid:Destroy()\n    local tasks = self._tasks\n\n    -- Clear out tasks table completely, even if cleaning up tasks adds more tasks to this maid\n    local index, task = next(tasks)\n    while task ~= nil do\n        tasks[index] = nil\n        _cleanupTask(task)\n        index, task = next(tasks)\n    end\nend\n\n-- --------------------------------------------------------------------------\n\nlocal function _test()\n    do -- resursive tasks\n        local m = Maid.New()\n        local inner1, inner2\n        m:GiveTask({Destroy = function()\n            inner1 = true\n            m.x = function() inner2 = true end\n        end})\n        m:Destroy()\n        assert(inner1)\n        assert(inner2)\n    end\n    print(\"maid -- ok\")\nend\n_test()\n\n-- extra export: clean-up or destroy something with all nessesary checks\nMaid.safeDestroy = _cleanupTask\n\n-- alias\nMaid.Reset = Maid.Destroy\n\nreturn Maid"
      }
    }
    Assets {
      Id: 7243897883920053925
      Name: "_Luapp"
      PlatformAssetType: 3
      TextAsset {
        Text: "--------------------------------------------------------------------------\n--  An attempt to write robust pretty-printer for lua structures.\n--\n--  @author: andrew_zhilin@yahoo.com\n--  @Copyright (C) 2008-2021 by zOOn\n--  https://github.com/zoon/luapp\n--------------------------------------------------------------------------\n-- compiled from hlua, unreadable ^_^\nlocal RESPECT_TOSTRING_MT = true -- hacky for lua 5.2+\nlocal format, gsub = string.format, string.gsub\nlocal function errfmt(argn,varargs,...)\n  local MAX_TAB = 5\n  local args = {...}\n  local argslen = select(\"#\", ...)\n  argslen = (argn and argn>argslen) and argn or argslen\n  local function get_type(_u0)\n    if type(_u0) == \'table\' or type(_u0) == \'userdata\' then\n      local mt = getmetatable(_u0)\n      if mt and mt.type and type(mt.type) == \'function\' then\n        return _u0:type()\n      else return type(_u0)\n      end\n    else return type(_u0)\n    end\n  end\n  local function atom(x)\n    if type(x) == \'string\' then return format(\'%q:%s\',x,\'string\')\n    else return format(\'%s:%s\',tostring(x),get_type(x))\n    end\n  end\n  local function key(x)\n    if type(x) == \'number\' then return \"\"\n    else return \'[\'..atom(x) ..\']=\'\n    end\n  end\n  local function one_arg(i,x)\n    local what = \'arg#\'..i ..\":\\t\"\n    if type(x) == \'table\' then\n      local n = 0\n      what = what ..\'{\'\n      for k,v in pairs(x) do\n        what = what ..(key(k) ..atom(v) ..\',\')\n        n = n+1\n        if n == MAX_TAB then what = what ..\" ...\" break end\n      end\n      what = what ..\'}:\'..get_type(x)\n    else what = what ..atom(x)\n    end\n    what = what ..\'\\n\'\n    return what\n  end\n  local res = \'pattern-match error:\\n\'\n  if varargs ~= false then\n    res = res ..\'varargs possible after arg#\'..argn ..\'.\\n\'\n  end\n  if argn ~= 0 then\n    res = res ..argn ..\' args were expected, in fact we got:\\n\'\n  end\n  for i=1,argslen do res = res ..one_arg(i,args[i]) end\n  if debug and type(debug) == \'table\' then\n    return res ..(gsub(debug.traceback\"\",\'\\t\',\'\')) ..\'\\n\'\n  else return res\n  end\nend\n\n-- zpp\nlocal error = error\nlocal tostring = tostring\nlocal rep = string.rep\nlocal min,max = math.min,math.max\nlocal type = type\nlocal spaces = function(_u53) return rep(\" \",_u53) end\nlocal compose = function(f,g)\n  return function(x) return f(g(x)) end\nend\nlocal identity = function(...) return ... end\nlocal function i2list(_u54)\n  local res = \'<#null>\'\n  for i=#_u54,1,-1 do res = {_u54[i];res}; end\n  return res\nend\nlocal function foldl(_u55,_u56,_u57)\n  if \'<#null>\' == _u57 then return _u56\n  else\n    if type(_u57) == \'table\' and #_u57 == 2 then\n      return foldl(_u55,_u55(_u56,_u57[1]),_u57[2])\n    else error(errfmt(3,false,_u55,_u56,_u57))\n    end\n  end\nend\nlocal Doc_mt = {}\nDoc_mt.__index = Doc_mt\nlocal function Doc(_u58)\n  if type(_u58) == \'table\' and (#_u58 == 2 and\n     _u58.tag ~= nil and (_u58.tag == \'Cat\' or\n     _u58.tag == \'Nest\') or #_u58 == 1 and _u58.tag ~= nil and\n     (_u58.tag == \'Text\' or _u58.tag == \'Break\' or\n     _u58.tag == \'Group\' or _u58.tag == \'Column\' or\n     _u58.tag == \'Nesting\') or #_u58 == 0 and _u58.tag ~= nil and\n     _u58.tag == \'Empty\')\n  then\n    return setmetatable(_u58,Doc_mt)\n  else error(errfmt(1,false,_u58))\n  end\nend\nlocal Empty = Doc{tag=\'Empty\'}\nlocal isDoc = function(_u59)\n  if type(_u59) == \'table\' then\n    return getmetatable(_u59) == Doc_mt\n  else return false\n  end\nend\nlocal empty = Empty\nlocal text = function(_u60)\n  return Doc{tag=\'Text\';tostring(_u60)}\nend\nlocal nest = function(_u61,_u62)\n  if type(_u61) == \'number\' and isDoc(_u62) then\n    return Doc{tag=\'Nest\';_u61;_u62}\n  else error(errfmt(2,false,_u61,_u62))\n  end\nend\nlocal group = function(_u63)\n  if isDoc(_u63) then return Doc{tag=\'Group\';_u63}\n  else error(errfmt(1,false,_u63))\n  end\nend\nlocal column = function(_u64)\n  if type(_u64) == \'function\' then return Doc{tag=\'Column\';_u64}\n  else error(errfmt(1,false,_u64))\n  end\nend\nlocal nesting = function(_u65)\n  if type(_u65) == \'function\' then\n    return Doc{tag=\'Nesting\';_u65}\n  else error(errfmt(1,false,_u65))\n  end\nend\nlocal line = Doc{tag=\'Break\';\" \"}\nlocal linebreak = Doc{tag=\'Break\';\"\"}\nlocal space = text\" \"\nlocal softline = group(line)\nlocal softbreak = group(linebreak)\nlocal function cat(_u66,_u67)\n  if _u66 == Empty then\n    if isDoc(_u67) then return _u67\n    else\n      if isDoc(_u66) and _u67 == Empty then return _u66\n      else error(errfmt(2,false,_u66,_u67))\n      end\n    end\n  else\n    if isDoc(_u66) then\n      if _u67 == Empty then return _u66\n      else\n        if isDoc(_u67) then return Doc{tag=\'Cat\';_u66;_u67}\n        else error(errfmt(2,false,_u66,_u67))\n        end\n      end\n    else error(errfmt(2,false,_u66,_u67))\n    end\n  end\nend\nlocal function catspace(_u68,_u69)\n  return cat(_u68,(cat(space,_u69)))\nend\nlocal function above(_u70,_u71)\n  return cat(_u70,(cat(linebreak,_u71)))\nend\nlocal function abovespace(_u72,_u73)\n  return cat(_u72,(cat(line,_u73)))\nend\nlocal function abovesoft(_u74,_u75)\n  return cat(_u74,(cat(softbreak,_u75)))\nend\nlocal function abovesoftspace(_u76,_u77)\n  return cat(_u76,(cat(softline,_u77)))\nend\nlocal function foldDoc(_u79,_u80)\n  if type(_u79) == \'function\' and isDoc(_u80) then\n    return function(_u78)\n      if type(_u78) == \'table\' and #_u78 == 2 or \'<#null>\' == _u78\n      then\n        return foldl(_u79,_u80,_u78)\n      else error(errfmt(1,false,_u78))\n      end\n    end\n  else error(errfmt(2,false,_u79,_u80))\n  end\nend\nlocal function separateWith(_u84,_u85)\n  if isDoc(_u84) and type(_u85) == \'function\' then\n    return function(_u83)\n      if \'<#null>\' == _u83 then return empty\n      else\n        if type(_u83) == \'table\' and #_u83 == 2 then\n          if \'<#null>\' == _u83[2] then return _u85(_u83[1])\n          else\n            return foldDoc(function(_u81,_u82)\n                            return cat(_u81,(cat(_u85(_u82),_u84)))\n                          end\n                          ,_u85(_u83[1]))(_u83[2])\n          end\n        else error(errfmt(1,false,_u83))\n        end\n      end\n    end\n  else error(errfmt(2,false,_u84,_u85))\n  end\nend\nlocal function ifoldDoc(_u87)\n  if type(_u87) == \'function\' then\n    return function(_u86)\n      if type(_u86) == \'table\' then\n        if #_u86 == 0 then return empty\n        else\n          if #_u86 == 1 then return _u86[1]\n          else\n            if #_u86 >= 1 then\n              local seed = _u86[1]\n              for i=2,#_u86 do seed = _u87(seed,_u86[i]); end\n              return seed\n            else error(errfmt(1,false,_u86))\n            end\n          end\n        end\n      else error(errfmt(1,false,_u86))\n      end\n    end\n  else error(errfmt(1,false,_u87))\n  end\nend\nlocal function iseparateWith(_u89,_u90)\n  if isDoc(_u89) and type(_u90) == \'function\' then\n    return function(_u88)\n      if type(_u88) == \'table\' then\n        if #_u88 == 0 then return empty\n        else\n          if #_u88 == 1 then return _u90(_u88[1])\n          else\n            local seed = empty\n            for i=1,(#_u88-1) do\n              seed = cat(seed,(cat(_u90(_u88[i]),_u89)))\n            end\n            return cat(seed,_u90(_u88[#_u88]))\n          end\n        end\n      else error(errfmt(1,false,_u88))\n      end\n    end\n  else error(errfmt(2,false,_u89,_u90))\n  end\nend\nlocal align = function(doc)\n  return column(function(k)\n    return nesting(function(i) return nest(k-i,doc) end)\n  end)\nend\nlocal hang = function(i,doc) return align(nest(i,doc)) end\nlocal indent = function(i,doc)\n  return hang(i,cat(text(spaces(i)),doc))\nend\nlocal width = function(_u91,_u92)\n  if isDoc(_u91) and type(_u92) == \'function\' then\n    return column(function(k1)\n      return cat(_u91,column(function(k2) return _u92(k2-k1) end))\n    end)\n  else error(errfmt(2,false,_u91,_u92))\n  end\nend\nlocal fillBreak = function(_u94,_u95)\n  if type(_u94) == \'number\' and isDoc(_u95) then\n    return width(_u95\n                ,function(_u93)\n                  if _u93>_u94 then return nest(_u94,linebreak)\n                  else return text(spaces(_u94-_u93))\n                  end\n                end)\n  else error(errfmt(2,false,_u94,_u95))\n  end\nend\nlocal fill = function(_u97,_u98)\n  if type(_u97) == \'number\' and isDoc(_u98) then\n    return width(_u98\n                ,function(_u96)\n                  if _u96 >= _u97 then return empty\n                  else return text(spaces(_u97-_u96))\n                  end\n                end)\n  else error(errfmt(2,false,_u97,_u98))\n  end\nend\nlocal FL,BR = {\'Flat\'},{\'Break\'}\nlocal function layout(_u110,_u111,_u112)\n  if isDoc(_u110) then\n    _u111 = _u111 or 160\n    _u112 = _u112 or 0.8\n    local ribbon = max(min((_u111*_u112),_u111),0)\n    local function fits(_u99,_u100,_u101)\n      if _u99<0 then return false\n      else\n        if \'<#null>\' == _u101 then return true\n        else\n          if type(_u101) == \'table\' and #_u101 == 2 and\n             type(_u101[1]) == \'table\' and #_u101[1] == 3\n          then\n            if _u101[1][3] == Empty then return fits(_u99,_u100,_u101[2])\n            else\n              if type(_u101[1][3]) == \'table\' then\n                if #_u101[1][3] == 2 then\n                  if _u101[1][3].tag ~= nil then\n                    if _u101[1][3].tag == \'Cat\' then\n                      return fits(_u99\n                                 ,_u100\n                                 ,{{_u101[1][1];_u101[1][2];_u101[1][3][1]}\n                                  ;{{_u101[1][1];_u101[1][2];_u101[1][3][2]}\n                                   ;_u101[2]}})\n                    else\n                      if _u101[1][3].tag == \'Nest\' then\n                        return fits(_u99\n                                   ,_u100\n                                   ,{{_u101[1][1]+_u101[1][3][1]\n                                     ;_u101[1][2]\n                                     ;_u101[1][3][2]}\n                                    ;_u101[2]})\n                      else return error(tostring(_u101))\n                      end\n                    end\n                  else return error(tostring(_u101))\n                  end\n                else\n                  if #_u101[1][3] == 1 and _u101[1][3].tag ~= nil then\n                    if _u101[1][3].tag == \'Text\' then\n                      return fits(_u99-#_u101[1][3][1]\n                                 ,_u100+#_u101[1][3][1]\n                                 ,_u101[2])\n                    else\n                      if _u101[1][2] == FL then\n                        if _u101[1][3].tag == \'Break\' then\n                          return fits(_u99-#_u101[1][3][1]\n                                     ,_u100+#_u101[1][3][1]\n                                     ,_u101[2])\n                        else\n                          if _u101[1][3].tag == \'Group\' then\n                            return fits(_u99\n                                       ,_u100\n                                       ,{{_u101[1][1]\n                                         ;_u101[1][2]\n                                         ;_u101[1][3][1]}\n                                        ;_u101[2]})\n                          else\n                            if _u101[1][3].tag == \'Column\' then\n                              return fits(_u99\n                                         ,_u100\n                                         ,{{_u101[1][1]\n                                           ;_u101[1][2]\n                                           ;_u101[1][3][1](_u100)}\n                                          ;_u101[2]})\n                            else\n                              if _u101[1][3].tag == \'Nesting\' then\n                                return fits(_u99\n                                           ,_u100\n                                           ,{{_u101[1][1]\n                                             ;_u101[1][2]\n                                             ;_u101[1][3][1](_u101[1][1])}\n                                            ;_u101[2]})\n                              else return error(tostring(_u101))\n                              end\n                            end\n                          end\n                        end\n                      else\n                        if _u101[1][2] == BR and _u101[1][3].tag == \'Break\'\n                        then\n                          return true\n                        else\n                          if _u101[1][3].tag == \'Group\' then\n                            return fits(_u99\n                                       ,_u100\n                                       ,{{_u101[1][1]\n                                         ;_u101[1][2]\n                                         ;_u101[1][3][1]}\n                                        ;_u101[2]})\n                          else\n                            if _u101[1][3].tag == \'Column\' then\n                              return fits(_u99\n                                         ,_u100\n                                         ,{{_u101[1][1]\n                                           ;_u101[1][2]\n                                           ;_u101[1][3][1](_u100)}\n                                          ;_u101[2]})\n                            else\n                              if _u101[1][3].tag == \'Nesting\' then\n                                return fits(_u99\n                                           ,_u100\n                                           ,{{_u101[1][1]\n                                             ;_u101[1][2]\n                                             ;_u101[1][3][1](_u101[1][1])}\n                                            ;_u101[2]})\n                              else return error(tostring(_u101))\n                              end\n                            end\n                          end\n                        end\n                      end\n                    end\n                  else return error(tostring(_u101))\n                  end\n                end\n              else return error(tostring(_u101))\n              end\n            end\n          else return error(tostring(_u101))\n          end\n        end\n      end\n    end\n    local function push(_u102,_u103)\n      _u102[#_u102+1] = _u103\n      return _u102\n    end\n    local function nl(_u104,_u105)\n      return push(_u104,(\'\\n\'..spaces(_u105)))\n    end\n    local function best(_u106,_u107,_u108,_u109)\n      if \'<#null>\' == _u109 then return _u106\n      else\n        if type(_u109) == \'table\' and #_u109 == 2 and\n           type(_u109[1]) == \'table\' and #_u109[1] == 3\n        then\n          if _u109[1][3] == Empty then\n            return best(_u106,_u107,_u108,_u109[2])\n          else\n            if type(_u109[1][3]) == \'table\' then\n              if #_u109[1][3] == 2 then\n                if _u109[1][3].tag ~= nil then\n                  if _u109[1][3].tag == \'Cat\' then\n                    return best(_u106\n                               ,_u107\n                               ,_u108\n                               ,{{_u109[1][1];_u109[1][2];_u109[1][3][1]}\n                                ;{{_u109[1][1];_u109[1][2];_u109[1][3][2]}\n                                 ;_u109[2]}})\n                  else\n                    if _u109[1][3].tag == \'Nest\' then\n                      return best(_u106\n                                 ,_u107\n                                 ,_u108\n                                 ,{{_u109[1][1]+_u109[1][3][1]\n                                   ;_u109[1][2]\n                                   ;_u109[1][3][2]}\n                                  ;_u109[2]})\n                    else error(errfmt(4,false,_u106,_u107,_u108,_u109))\n                    end\n                  end\n                else error(errfmt(4,false,_u106,_u107,_u108,_u109))\n                end\n              else\n                if #_u109[1][3] == 1 and _u109[1][3].tag ~= nil then\n                  if _u109[1][3].tag == \'Text\' then\n                    return best(push(_u106,_u109[1][3][1])\n                               ,_u107\n                               ,_u108+#_u109[1][3][1]\n                               ,_u109[2])\n                  else\n                    if _u109[1][2] == FL then\n                      if _u109[1][3].tag == \'Break\' then\n                        return best(push(_u106,_u109[1][3][1])\n                                   ,_u107\n                                   ,_u108+#_u109[1][3][1]\n                                   ,_u109[2])\n                      else\n                        if _u109[1][3].tag == \'Group\' then\n                          return best(_u106\n                                     ,_u111\n                                     ,_u108\n                                     ,{{_u109[1][1];FL;_u109[1][3][1]}\n                                      ;_u109[2]})\n                        else\n                          if _u109[1][3].tag == \'Column\' then\n                            return best(_u106\n                                       ,_u107\n                                       ,_u108\n                                       ,{{_u109[1][1]\n                                         ;_u109[1][2]\n                                         ;_u109[1][3][1](_u108)}\n                                        ;_u109[2]})\n                          else\n                            if _u109[1][3].tag == \'Nesting\' then\n                              return best(_u106\n                                         ,_u107\n                                         ,_u108\n                                         ,{{_u109[1][1]\n                                           ;_u109[1][2]\n                                           ;_u109[1][3][1](_u109[1][1])}\n                                          ;_u109[2]})\n                            else\n                              error(errfmt(4,false,_u106,_u107,_u108,_u109))\n                            end\n                          end\n                        end\n                      end\n                    else\n                      if _u109[1][2] == BR then\n                        if _u109[1][3].tag == \'Break\' then\n                          return best(nl(_u106,_u109[1][1])\n                                     ,_u109[1][1]\n                                     ,_u109[1][1]\n                                     ,_u109[2])\n                        else\n                          if _u109[1][3].tag == \'Group\' then\n                            do\n                              local ribbonleft = min((_u111-_u108)\n                                                    ,(ribbon-_u108+_u107))\n                              if fits(ribbonleft\n                                     ,_u108\n                                     ,{{_u109[1][1];FL;_u109[1][3][1]}\n                                      ;_u109[2]})\n                              then\n                                return best(_u106\n                                           ,_u107\n                                           ,_u108\n                                           ,{{_u109[1][1];FL;_u109[1][3][1]}\n                                            ;_u109[2]})\n                              else\n                                return best(_u106\n                                           ,_u107\n                                           ,_u108\n                                           ,{{_u109[1][1];BR;_u109[1][3][1]}\n                                            ;_u109[2]})\n                              end\n                            end\n                          else\n                            if _u109[1][3].tag == \'Column\' then\n                              return best(_u106\n                                         ,_u107\n                                         ,_u108\n                                         ,{{_u109[1][1]\n                                           ;_u109[1][2]\n                                           ;_u109[1][3][1](_u108)}\n                                          ;_u109[2]})\n                            else\n                              if _u109[1][3].tag == \'Nesting\' then\n                                return best(_u106\n                                           ,_u107\n                                           ,_u108\n                                           ,{{_u109[1][1]\n                                             ;_u109[1][2]\n                                             ;_u109[1][3][1](_u109[1][1])}\n                                            ;_u109[2]})\n                              else\n                                error(errfmt(4\n                                            ,false\n                                            ,_u106\n                                            ,_u107\n                                            ,_u108\n                                            ,_u109))\n                              end\n                            end\n                          end\n                        end\n                      else\n                        if _u109[1][3].tag == \'Column\' then\n                          return best(_u106\n                                     ,_u107\n                                     ,_u108\n                                     ,{{_u109[1][1]\n                                       ;_u109[1][2]\n                                       ;_u109[1][3][1](_u108)}\n                                      ;_u109[2]})\n                        else\n                          if _u109[1][3].tag == \'Nesting\' then\n                            return best(_u106\n                                       ,_u107\n                                       ,_u108\n                                       ,{{_u109[1][1]\n                                         ;_u109[1][2]\n                                         ;_u109[1][3][1](_u109[1][1])}\n                                        ;_u109[2]})\n                          else error(errfmt(4,false,_u106,_u107,_u108,_u109))\n                          end\n                        end\n                      end\n                    end\n                  end\n                else error(errfmt(4,false,_u106,_u107,_u108,_u109))\n                end\n              end\n            else error(errfmt(4,false,_u106,_u107,_u108,_u109))\n            end\n          end\n        else error(errfmt(4,false,_u106,_u107,_u108,_u109))\n        end\n      end\n    end\n    return table.concat(best({},0,0,{{0;BR;_u110};\'<#null>\'}))\n  else error(errfmt(3,false,_u110,_u111,_u112))\n  end\nend\nlocal zpp = {}\nzpp.__index = zpp\nzpp.layout = layout\nzpp.isDoc = isDoc\nzpp.empty = empty\nzpp.text = text\nzpp.nest = nest\nzpp.group = group\nzpp.column = column\nzpp.nesting = nesting\nzpp.line = line\nzpp.linebreak = linebreak\nzpp.softline = group(line)\nzpp.softbreak = group(linebreak)\nzpp.space = space\nzpp.cat = cat\nzpp.catspace = catspace\nzpp.abovespace = abovespace\nzpp.above = above\nzpp.abovesoftspace = abovesoftspace\nzpp.abovesoft = abovesoft\nzpp.lparen = text\'(\'\nzpp.rparen = text\')\'\nzpp.langle = text\'<\'\nzpp.rangle = text\'>\'\nzpp.lbrace = text\'{\'\nzpp.rbrace = text\'}\'\nzpp.lbracket = text\'[\'\nzpp.rbracket = text\']\'\nzpp.backtick = text\'`\'\nzpp.squote = text\"\'\"\nzpp.dquote = text\'\"\'\nzpp.semi = text\';\'\nzpp.colon = text\':\'\nzpp.comma = text\',\'\nzpp.dot = text\'.\'\nzpp.slash = text\'/\'\nzpp.backslash = text\'\\\\\'\nzpp.assign = text\'=\'\nzpp.foldDoc = foldDoc\nzpp.separateWith = separateWith\nzpp.ifoldDoc = ifoldDoc\nzpp.iseparateWith = iseparateWith\nzpp.indent = indent\nzpp.align = align\nzpp.hang = hang\nzpp.fill = fill\nzpp.fillBreak = fillBreak\nDoc_mt.type = (function() return \"Doc\" end)\nDoc_mt.__tostring = layout\nDoc_mt.__add = cat\nDoc_mt.__sub = catspace\nDoc_mt.__div = abovespace\nDoc_mt.__mul = above\nzpp.compose = compose\nzpp.identity = identity\nzpp.i2list = i2list\n\n-- luapp\nlocal pairs = pairs\nlocal ipairs = ipairs\nlocal find = string.find\nlocal sort = table.sort\nlocal insert = table.insert\nlocal lbracket = zpp.lbracket\nlocal rbracket = zpp.rbracket\nlocal langle = zpp.langle\nlocal rangle = zpp.rangle\nlocal dot = zpp.dot\nlocal assign = zpp.assign\nlocal backtick = zpp.backtick\nlocal dcolon = text\" ::\"\nlocal consnull = text\"[]\"\nlocal consnullsp = text\" [] \"\nlocal TAG = \'tag\'\nlocal function encloseSep(_u2,_u3,_u4)\n  if isDoc(_u2) and isDoc(_u3) and isDoc(_u4) then\n    return function(_u1)\n      if type(_u1) == \'table\' then\n        return _u2+align(group(iseparateWith(_u4+line\n                                            ,identity)(_u1)))+_u3\n      else error(errfmt(1,false,_u1))\n      end\n    end\n  else error(errfmt(3,false,_u2,_u3,_u4))\n  end\nend\nlocal tabled = encloseSep(zpp.lbrace,zpp.rbrace,zpp.comma)\nlocal listed_proper = encloseSep(zpp.lbracket\n                                ,zpp.rbracket\n                                ,zpp.comma)\nlocal function listed(_u5,_u6)\n  if _u6 == nil then return listed_proper(_u5)\n  else\n    return encloseSep(empty,empty,dcolon){listed_proper(_u5);_u6}\n  end\nend\nlocal angles = function(x) return langle+x+rangle end\nlocal brackets = function(x) return lbracket+x+rbracket end\nlocal brkangles = function(x)\n  return lbracket+langle+x+rangle+rbracket\nend\nlocal function lua2doc(_u27,_u28)\n  if _u28 == nil or type(_u28) == \'string\' then\n    local root_path = text(_u28 or \'<#>\')\n    local key,value\n    local tracker = {}\n    local function isLikeId(_u7)\n      return type(_u7) == \'string\' and find(_u7,\"^[%a_][%a%d_]*$\")\n    end\n    local function sort_pairs_by_key(_u10,_u11)\n      if type(_u10) == \'table\' and #_u10 == 2 and\n         type(_u11) == \'table\' and #_u11 == 2\n      then\n        do\n          local _u8,_u9 = _u10[1],_u11[1]\n          if type(_u8) == \'number\' then\n            if type(_u9) == \'number\' then return _u8<_u9\n            else return true\n            end\n          else\n            if type(_u8) == \'string\' then\n              if type(_u9) == \'string\' then return _u8<_u9\n              else return not (type(_u9) == \'number\')\n              end\n            else\n              if type(_u9) == \'string\' or type(_u9) == \'number\' then\n                return false\n              else return type(_u8)<type(_u9)\n              end\n            end\n          end\n        end\n      else error(errfmt(2,false,_u10,_u11))\n      end\n    end\n    local function str2doc(_u12)\n      return text(format(\"%q\",_u12))\n    end\n    local function render_path(_u13)\n      if _u13 == nil then return empty\n      else\n        local res = empty; for i=#_u13,1,-1 do res = res+_u13[i]; end\n        return res\n      end\n    end\n    local function get_addr(_u14)\n      local obj = tostring(_u14)\n      local _,_,addr = find(obj,\': (.+)$\')\n      return addr or obj\n    end\n    local function prepare_table(_u17)\n      if type(_u17) == \'table\' then\n        local res,tag,len = {},nil,0\n        for i,_ in ipairs(_u17) do len = i; end\n        for k,v in pairs(_u17) do\n          do\n            local _u15,_u16 = k,v\n            if _u15 == TAG and type(_u16) == \'string\' then tag = _u16\n            else insert(res,{k;v})\n            end\n          end\n        end\n        sort(res,sort_pairs_by_key)\n        tag = tag and backtick+text(tag) or empty\n        return len,res,tag\n      else error(errfmt(1,false,_u17))\n      end\n    end\n    local function render_nonarray_part(_u18,_u19,_u20,...)\n      local last_i = _u18\n      for i=_u18,#_u19 do\n        last_i = i\n        local sorted_k,sorted_v = _u19[i][1],_u19[i][2]\n        if sorted_k == 1 then break end\n        local new_key,is_id = key(sorted_k)\n        local new_path_el = is_id and dot+new_key or new_key\n        _u20[i] = (new_key+assign+value(sorted_v,new_path_el,...))\n      end\n      return last_i\n    end\n    local function table2doc(_u22,...)\n      if type(_u22) == \'table\' then\n        local length,sorted,tag = prepare_table(_u22)\n        local res = {}\n        local ii = 1\n        do\n          local _u21 = sorted\n          if type(_u21) == \'table\' and #_u21 >= 1 and\n             type(_u21[1]) == \'table\' and #_u21[1] == 2 and\n             type(_u21[1][1]) == \'number\' and _u21[1][1] ~= 1\n          then\n            ii = render_nonarray_part(ii,sorted,res,...)\n          else\n          end\n        end\n        for i=ii,ii+length-1 do\n          res[i] = value((sorted[i] or {})[2],key(i),...)\n        end\n        render_nonarray_part(ii+length,sorted,res,...)\n        return tag+tabled(res)\n      else error(errfmt(1,true,_u22,...))\n      end\n    end\n    local function list2doc(_u23,_u24,...)\n      if \'<#null>\' == _u23 then return _u24\n      else\n        if type(_u23) == \'table\' and #_u23 == 2 then\n          do\n            _u24[#_u24+1] = value(_u23[1],key(1),...)\n            return list2doc(_u23[2],_u24,key(2),...)\n          end\n        else return _u24,value(_u23,...)\n        end\n      end\n    end\n    function key(_u25)\n      if type(_u25) == \'table\' then\n        if #_u25 == 2 and (\'<#null>\' == _u25[2] or\n           type(_u25[2]) == \'table\' and #_u25[2] == 2)\n        then\n          return brkangles(text(\'pair: \'..get_addr(_u25)))\n        else return brkangles(text(_u25))\n        end\n      else\n        if type(_u25) == \'number\' then return brackets(text(_u25))\n        else\n          if \'<#null>\' == _u25 then return brackets(consnullsp)\n          else\n            if isLikeId(_u25) then return text(_u25),\"ID\"\n            else\n              if type(_u25) == \'string\' then return brackets(str2doc(_u25))\n              else\n                if _u25 == nil then return error\'nil key?\'\n                else return brkangles(text(_u25))\n                end\n              end\n            end\n          end\n        end\n      end\n    end\n    function value(_u26,...)\n      if type(_u26) == \'table\' then\n        if RESPECT_TOSTRING_MT and _u26.__tostring then return text(tostring(_u26)) end\n        if tracker[_u26] then return tracker[_u26]\n        else\n          if #_u26 == 2 and (\'<#null>\' == _u26[2] and not _u26[TAG] or\n             type(_u26[2]) == \'table\' and #_u26[2] == 2 and not _u26[TAG])\n          then\n            do\n              tracker[_u26] = render_path{...}\n              return listed(list2doc(_u26,{},...))\n            end\n          else\n            do\n              tracker[_u26] = render_path{...}\n              return table2doc(_u26,...)\n            end\n          end\n        end\n      else\n        if \'<#null>\' == _u26 then return consnull\n        else\n          if type(_u26) == \'string\' then return str2doc(_u26)\n          else\n            if type(_u26) == \'function\' or type(_u26) == \'thread\' or\n               type(_u26) == \'userdata\'\n            then\n              return angles(text(_u26))\n            else return text(_u26)\n            end\n          end\n        end\n      end\n    end\n    return value(_u27,root_path)\n  else error(errfmt(2,false,_u27,_u28))\n  end\nend\n\n-- pp(any, [root-name]=\"<#>\", [page-width]=160, [line-fill]=0.8) -> string\n-- @root-name -- optional name for the topmost table if you expect it to be recvursive\n-- @page-width -- optional max page width\n-- @line-fill -- max desired (line width)/(page width)\nlocal function pp(obj, root, width, fill)\n  if root == nil or type(root) == \'string\' and width == nil or\n     type(width) == \'number\' and (fill == nil or\n     type(fill) == \'number\')\n  then\n    return layout(lua2doc(obj,root),width,fill)\n  else error(errfmt(4,false,obj,root,width,fill))\n  end\nend\n\nlocal luapp = {}\nluapp.__index = luapp\nluapp.pp = pp\nluapp.zpp = zpp -- submodule, pretty printers construction kit\nluapp.errfmt = function(...)\n  return errfmt(select(\"#\", ...), false, ...)\nend\nreturn luapp"
      }
    }
    Assets {
      Id: 2361961766352951098
      Name: "_Heap"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    Heap (priority queue) with compare function.\n]]\n\nlocal Heap = {type==\"Heap\"}\nHeap.__index = Heap\n\nlocal function _lt(a, b) return a < b end\nlocal function _gt(a, b) return b < a end\n\nfunction Heap.New(comp)\n    assert(comp and type(comp) == \"function\", \"no compare function\")\n    return setmetatable({_n = 0, _pq = {}, _comp = comp}, Heap)\nend\n\nfunction Heap.NewMin() return Heap.New(_lt) end\n\nfunction Heap.NewMax() return Heap.New(_gt) end\n\nfunction Heap:Peek()\n    return self._pq[1]\nend\n\nfunction Heap:Count()\n    return self._n\nend\n\nfunction Heap:IsEmpty()\n    return self._n == 0\nend\n\nfunction Heap:Push(el)\n    local k, pq, comp = self._n + 1, self._pq, self._comp\n    self._n = k\n    -- assert(k == #pq+1)\n    pq[k] = el\n    while true do\n        local parent = k//2\n        if k > 1 and comp(pq[k], pq[parent]) then\n            pq[k], pq[parent] = pq[parent], pq[k]\n            k = parent\n        else\n          break\n        end\n    end\n    return self\nend\n\nfunction Heap:Pop()\n    if self._n == 0 then return nil end\n    local n, pq, comp = self._n, self._pq, self._comp\n    local result = pq[1]\n    pq[1] = pq[n]\n    pq[n] = nil\n    n = n - 1\n    local k = 1\n    while 2*k <= n do\n        local child = 2*k\n        if child < n and comp(pq[child + 1], pq[child]) then\n            child = child + 1\n        end\n        if not comp(pq[child], pq[k]) then\n            break\n        end\n        pq[k], pq[child] = pq[child], pq[k]\n        k = child\n    end\n    self._n = n\n    return result\nend\n\nfunction Heap:Purge()\n    for i = self._n, 1, -1 do\n        self._pq[i] = nil\n    end\n    self._n = 0\nend\n\n-- hacky\nfunction Heap:_for_each(fun)\n    for i=1, self._n do\n        fun(self._pq[i])\n    end\nend\n\n-- test helper\nlocal function _assert_heap_invariant(self, k)\n    local msg =  \"ERROR -- order invariant does not hold.\"\n    k = k or 1\n    local comp = self._comp\n    if k > self._n then\n        return true\n    end\n    local left = 2*k\n    if left <= self._n and comp(self._pq[left], self._pq[k]) then\n        return assert(false, msg)\n    end\n    local right = left + 1\n    if right <= self._n and comp(self._pq[right], self._pq[k]) then\n        return assert(false, msg)\n    end\n    return assert(_assert_heap_invariant(self, left) and _assert_heap_invariant(self, right), msg)\nend\n\n-- --------------------------------------------------------------------------\n\nlocal function _test()\n\n    do\n        local pqmin = Heap.NewMin()\n        pqmin:Push(3):Push(1):Push(2):Push(4):Push(5)\n        _assert_heap_invariant(pqmin)\n        assert(pqmin:Count() == 5 and #pqmin._pq == 5)\n        local out = {}\n        while pqmin:Count() > 0 do\n            out[#out+1] = pqmin:Pop()\n            _assert_heap_invariant(pqmin)\n        end\n        assert(pqmin:IsEmpty() and pqmin:Count() == 0 and pqmin:Peek() == nil and #pqmin._pq == 0)\n        assert(out[1] == 1 and out[2] == 2 and out[3] == 3 and out[4] == 4 and out[5] == 5)\n    end\n\n    do\n        local pqmax = Heap.NewMax()\n        pqmax:Push(3):Push(1):Push(2):Push(4):Push(5):Push(2)\n        _assert_heap_invariant(pqmax)\n        assert(pqmax:Count() == 6 and #pqmax._pq == 6)\n        local sum = 0\n        pqmax:_for_each(function(x) sum = sum + x end)\n        assert(sum == 17)\n        local out = {}\n        while pqmax:Count() > 0 do\n            out[#out+1] = pqmax:Pop()\n            _assert_heap_invariant(pqmax)\n        end\n        assert(pqmax:IsEmpty() and pqmax:Count() == 0 and #pqmax._pq == 0)\n        assert(out[1] == 5 and out[2] == 4 and out[3] == 3 and out[4] == 2 and out[5] == 2 and out[6] == 1)\n    end\n\n    print(\"heap -- ok\")\nend\n_test()\n\nreturn Heap"
      }
    }
    Assets {
      Id: 12769054960477199651
      Name: "_Grid"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    Grid coordinates:\n    0 --> +y, +col\n    |\n    v\n    -x, +row\n]]\n\nlocal CORE_ENV = CoreString and CoreMath\nif not _G.req then _G.req = require end\n\nlocal abs, sqrt = math.abs, math.sqrt\n\nlocal Maid = _G.req(\"_Maid\")\nlocal Deque = _G.req(\"_Deque\")\nlocal Bitarray = _G.req(\"_Bitarray\")\nlocal Base64 = _G.req(\"_Base64\")\n\nlocal Grid = {type = \"Grid\"}\nGrid.__index = Grid\n\nlocal Cell = {type=\"Cell\"}\nCell.__index = Cell\n\nlocal CELL_NIL, _cell_center_global do\n    function Cell.New(row, col, posx, posy, actor)\n        assert(not actor or type(actor) == \"number\")\n        return setmetatable({\n            row=row, col=col, posx=posx, posy=posy, actor = actor\n        }, Cell)\n    end\n\n    CELL_NIL = Cell.New()\n    _cell_center_global = CELL_NIL\nend\n\nfunction Cell.__tostring(c)\n    if c == CELL_NIL then return \"CELL_NIL\" end\n    local actor = c.actor and tostring(c.actor.id) or \"()\"\n    return string.format(\n        \"Cell:{row: %d, col: %d, posx: %0.2f, posy: %0.2f, actor: %s}\",\n        c.row, c.col, c.posx, c.posy, actor)\nend\n\nfunction Cell:IsNil()\n    return not self or self == CELL_NIL\nend\n\nfunction Cell:Unpack()\n    if self ~= CELL_NIL then\n        return self.row, self.col, self.actor and self.actor.id\n    end\nend\n\nfunction Cell:ManhattanDistance(other)\n    if self == CELL_NIL or other == CELL_NIL then return math.huge end\n    return abs(self.row - other.row) + abs(self.col - other.col)\nend\n\nfunction Cell:Distance(other)\n    if self == CELL_NIL or other == CELL_NIL then return math.huge end\n    local dr, dc = self.row - other.row, self.col - other.col\n    return sqrt(dr*dr + dc*dc)\nend\n\nfunction Cell:IsFree()\n    return self ~= CELL_NIL and not self.actor\nend\n\nfunction Cell:Destroy()\n    Maid.safeDestroy(self.tile)\n    Maid.safeDestroy(self.actor)\nend\n\nlocal function idx2rc(idx, width)\n    return (idx - 1)//width, (idx - 1)%width -- 0-idx\nend\n\n-- rc2idx :: r0, c0, w -> idx|-1\nlocal function rc2idx(row0, col0, width)\n    return row0 >= 0 and col0 >= 0 and col0 < width and row0*width + col0 + 1 or -1\nend\n\n-- TODO: factor out geometry: dims, transform etc.\n-- empty :: [(r,c)]\nfunction Grid.New(w, h, dimx, dimy)\n    local _maid = Maid.New()\n    local cells = {}\n    for i = 1, w*h  do\n        local row, col = idx2rc(i, w)\n        local posx, posy = -row*dimx, col*dimy\n        cells[i] = Cell.New(row, col, posx, posy)\n        _maid:GiveTask(cells[i])\n    end\n    local self = setmetatable({_maid=_maid}, Grid)\n    self.w, self.h, self.dimx, self.dimy, self.cells = w, h, dimx, dimy, cells\n    -- add spatial extent\n    -- local dimx, dimy = self.dimx, self.dimy\n    -- local row = (-x + dimx/2)//dimx\n    -- local col = (y + dimy/2)//dimy\n    self.pos_x, self.neg_x = dimx/2, -dimx*h + dimx/2\n    self.pos_y, self.neg_y = dimy*w - dimy/2, -dimy/2\n    if CORE_ENV then\n        self.worldToGrid = Transform.IDENTITY\n    end\n    return self\nend\n\nfunction Grid:Fold(binop, seed)\n    assert(type(binop) == \"function\")\n    local n = self.w*self.h\n    for i=1, n do\n        local cell = self.cells[i]\n        if cell ~= CELL_NIL then\n            seed = binop(seed, cell)\n        end\n    end\n    return seed\nend\n\nfunction Grid:Search(predicate)\n    local n = self.w*self.h\n    for i=1, n do\n        local cell = self.cells[i]\n        if predicate(cell) then return cell end\n    end\nend\n\nlocal FOURCC = \"GRID\"\nfunction Grid:serialize(exploded)\n    local n = self.w*self.h\n    -- first position reserved for protocol op-tag\n    local out = {\"\", FOURCC, utf8.char(self.w, self.h, self.dimx, self.dimy), \'bitmap-placeholder\'}\n    local bitmap = Bitarray.new(n)\n    for i = 1, n do\n        local cell = self.cells[i]\n        local hole = (cell == CELL_NIL)\n        bitmap:set(i, not hole)\n        if not hole and cell.actor and cell.actor.id  then\n            out[#out+1] = utf8.char(cell.row, cell.col, cell.actor.id)\n        end\n    end\n    assert(out[4] == \'bitmap-placeholder\')\n    out[4] = bitmap:serialize()\n    return exploded and out or table.concat(out)\nend\n\nfunction Grid:__tostring()\n    local out = {}\n    out[#out+1] = string.format(\"width=%d height=%d dimx=%d dimy=%d\\n\", self.w, self.h, self.dimx, self.dimy)\n    local rmax, cmax = self.h-1, self.w-1\n    for row = 0, rmax do\n        for col=1, cmax do\n            local cell = self:at(row, col)\n            if cell == CELL_NIL then\n                out[#out+1] = \"| |\"\n            elseif cell.actor then\n                out[#out+1]=string.format(\"%.3d\", cell.actor.id)\n            else\n                out[#out+1] = \"[_]\"\n            end\n            if col == cmax then\n                out[#out+1] = \"\\n\"\n            end\n        end\n    end\n    return table.concat(out)\nend\n\nfunction Grid.deserialize(s, from, to)\n    from, to = from or 1, to or #s\n    assert(string.sub(s, from, from + #FOURCC - 1) == FOURCC)\n    from = from + #FOURCC\n    local whi = utf8.offset(s, 4, from)\n    local w, h, dimx, dimy = utf8.codepoint(s, from, whi)\n    local bi = utf8.offset(s, 5, from)\n    local bitmap\n    bitmap, from = Bitarray.deserialize(s, bi)\n    assert(bitmap:size() == w*h)\n    local actors = {utf8.codepoint(s, from, to)}\n    assert(#actors == 0 or #actors%3 == 0)\n    local grid = Grid.New(w, h, dimx, dimy)\n    for i=1, bitmap:size() do\n        if not bitmap:get(i) then\n            grid:MakeHole(i)\n        end\n    end\n    for i = 1, #actors, 3 do\n        local r, c, actor_id = actors[i], actors[i+1], actors[i+2]\n        local cell = grid:at(r,c)\n        cell.actor = {id=actor_id}\n    end\n    return grid\nend\n\n-- MakeHole :: self, idx | (row, col) ^-> self\nfunction Grid:MakeHole(row, col)\n    local idx = not col and row or rc2idx(row, col, self.w)\n    assert(idx <= self.w*self.h)\n    assert(not self.cells[idx].tile or not self.cells[idx].actor)\n    self.cells[idx]:Destroy()\n    self.cells[idx] = CELL_NIL\n    return self\nend\n\nfunction Grid:Destroy()\n    local n, cells = #self.cells, self.cells\n    for i = n, 1, -1 do\n        cells[i]:Destroy()\n        cells[i] = CELL_NIL\n    end\nend\n\n-- at :: self, idx | (row, col) -> Cell\nfunction Grid:at(row, col)\n    local idx = not col and row or rc2idx(row, col, self.w)\n    return self.cells[idx] or CELL_NIL\nend\n\nfunction Grid:GetExtent()\n    return {pos_x=self.pos_x, neg_x=self.neg_x, pos_y=self.pos_y, neg_y=self.neg_y}\nend\n\nfunction Grid:in_bounds(x, y)\n    return x >= self.neg_x and x <= self.pos_x and y >= self.neg_y and y <= self.pos_y\nend\n\n-- world coordinates\n\n\nif CORE_ENV then\n    function Grid:GetCellAtPoint(vec3)\n        if not vec3 then return CELL_NIL end\n        local p = self.worldToGrid == Transform.IDENTITY\n            and vec3\n            or self.worldToGrid:TransformPosition(vec3)\n        return self:GetCellAt(p.x, p.y)\n    end\nend\n\nfunction Grid:GetCellAt(x, y)\n    if self:in_bounds(x, y) then\n        local dimx, dimy = self.dimx, self.dimy\n        local row = (-x + dimx/2)//dimx\n        local col = (y + dimy/2)//dimy\n        if row < self.h and col < self.w then\n            return self.cells[rc2idx(row, col, self.w)]\n        end\n    end\n    return CELL_NIL\nend\n-- row, col, actor_id -> ok, local_cell, local_actor_id\nfunction Grid:_move_precheck(row, col, actor_id)\n    local loc = self:at(row, col)\n    local loc_actor = loc.actor\n    local loc_actor_id = loc_actor and loc_actor.id\n    return (loc ~= CELL_NIL and loc_actor_id == actor_id), loc, loc_actor\nend\n\nfunction Grid:Move(dest, src, check)\n    local dok, dloc, _ = self:_move_precheck(table.unpack(dest))\n    local sok, sloc, sactor = self:_move_precheck(table.unpack(src))\n    local ok = sok and dok\n    if ok and not check then\n        dloc.actor, sloc.actor = sactor, nil\n    end\n    return ok\nend\n\nfunction Grid:Swap(dest, src, check)\n    local dok, dloc, dactor = self:_move_precheck(table.unpack(dest))\n    local sok, sloc, sactor = self:_move_precheck(table.unpack(src))\n    local ok = dok and sok and dactor and sactor\n    if ok and not check then\n        dloc.actor, sloc.actor = sactor, dactor\n    end\n    return ok\nend\n\nfunction Grid:Push(dest, src, empty, check)\n    local dok, dloc, dactor = self:_move_precheck(table.unpack(dest))\n    local sok, sloc, sactor = self:_move_precheck(table.unpack(src))\n    local eok, eloc, eactor = self:_move_precheck(table.unpack(empty))\n    local ok = dok and sok and eok and dactor and sactor and not eactor\n    if ok and not check then\n        dloc.actor, sloc.actor, eloc.actor = sactor, nil, dactor\n    end\n    return ok\nend\n\nfunction Grid:Merge3(dest, src, other, factory, check)\n    local dok, dloc, dactor = self:_move_precheck(table.unpack(dest))\n    local sok, sloc, sactor = self:_move_precheck(table.unpack(src))\n    local ook, oloc, oactor = self:_move_precheck(table.unpack(other))\n    local ok = dok and sok and ook and dactor and sactor and oactor and (dactor.id == sactor.id) and (dactor.id == oactor.id)\n    if ok and not check then\n        local new_actor = assert(factory())\n        dloc.actor, sloc.actor, oloc.actor = new_actor, nil, nil\n    end\n    return ok\nend\n\nfunction Grid:Delete(src, check)\n    assert(src, CoreDebug.GetStackTrace())\n    local ok, sloc, _sactor = self:_move_precheck(table.unpack(src))\n    if ok and not check then\n        sloc.actor = nil\n    end\n    return ok\nend\n\n-- search_closest :: cell, predicate -> [cell], center excluded\ndo\n    local function comparer(c1, c2)\n        return _cell_center_global:ManhattanDistance(c1) < _cell_center_global:ManhattanDistance(c2)\n    end\n    function Grid:SearchClosest(center, predicate)\n        local out, cells, n = {}, self.cells, self.w * self.h\n        for i = 1, n do\n            local c = cells[i]\n            if c ~= center and predicate(c) then out[#out + 1] = c end\n        end\n        _cell_center_global = center\n        table.sort(out, comparer)\n        _cell_center_global = CELL_NIL\n        return out\n    end\nend\n-- BFS NOTE:\n-- -- SearchClosest is faster for < 50 cells and uses 3x less memory - don\'t use BFS if you can\n-- -- returns array + set of satisfied cells, excludes origin\ndo\n    local SEARCH_PATTERN = {1, 0, -1, 0, 1} -- without diagonals\n    local all = function() return true end\n    function Grid:Bfs(origin, predicate, limit)\n        predicate = predicate or all\n        limit = limit and limit > 0 and limit or math.huge\n        local q, visited = Deque.New(), {}\n        q:Push(origin)\n        while not q:Empty() do\n            if #visited >= limit then break end\n            local cell = q:Pop()\n            local cr, cc = cell.row, cell.col\n            for i = 1, 4 do\n                local row, col = cr + SEARCH_PATTERN[i], cc + SEARCH_PATTERN[i+1]\n                local next = self:at(row, col)\n                if next ~= CELL_NIL and next ~= origin and not visited[next] and predicate(next) then\n                    q:Push(next)\n                    visited[next] = true\n                    visited[#visited+1] = next -- add cell to array part (to return a result)\n                end\n            end\n        end\n        return visited\n    end\n\n    function Grid:Neighbor4(origin, predicate)\n        predicate = predicate or all\n        local r, c = origin.row, origin.col\n        for i = 1, 4 do\n            local row, col = r + SEARCH_PATTERN[i], c + SEARCH_PATTERN[i+1]\n            local cell = self:at(row, col)\n            if cell ~= CELL_NIL and cell ~= origin and predicate(cell) then\n                return cell\n            end\n        end\n    end\n\n    function Grid:Neighbor44(origin, predicate)\n        predicate = predicate or all\n        local r, c = origin.row, origin.col\n        for i = 1, 4 do\n            local row, col = r + SEARCH_PATTERN[i], c + SEARCH_PATTERN[i+1]\n            local cell = self:at(row, col)\n            if cell ~= CELL_NIL and cell ~= origin and predicate(cell) then\n                return cell\n            end\n        end\n        return self:Neighbor8(origin, predicate)\n    end\n\n    function Grid:Neighbor8(origin, predicate)\n        predicate = predicate or all\n        local r, c = origin.row, origin.col\n        for dr = -1, 1 do\n            for dc = -1, 1 do\n                local cell = self:at(r + dr, c + dc)\n                if cell ~= CELL_NIL and cell ~= origin and predicate(cell) then\n                    return cell\n                end\n            end\n        end\n    end\nend\n\nif CORE_ENV then\n    function Grid:SetWorldToGridTransform(tr)\n        self.worldToGrid = tr\n    end\nend\n\nlocal function _test()\n\n    local g0 = Grid.New(7, 5, 100,100)\n    local c30 = g0:GetCellAt(-300, -10)\n    assert(c30.row == 3 and c30.col == 0)\n    assert(rc2idx(2,7,7) == -1)\n\n    -- g1\n    local W, H, DimX, DimY = 5, 4, 50, 100\n    local g1 = Grid.New(W, H, DimX, DimY)\n    assert(#g1.cells == W*H)\n    assert(g1:at(1) == g1:at(0,0))\n    assert(g1:at(W*H) == g1:at(H-1, W-1))\n    local c00 = g1:GetCellAt(0, 0)\n    assert(c00.row == 0 and c00.col == 0)\n    local c34 = g1:GetCellAt(-(H-1)*g1.dimx, (W-1)*g1.dimy)\n    assert(c34.row == 3 and c34.col == 4)\n    local c32 = g1:GetCellAt(-149.999, 199.999)\n    assert(c32.row == 3 and c32.col == 2)\n\n    if CORE_ENV then\n        local tr = Transform.IDENTITY\n        tr:SetPosition(Vector3.New(200, 200, 0))\n        local wtr =tr:GetInverse()\n        g1:SetWorldToGridTransform(wtr)\n        local c31 = g1:GetCellAtPoint(Vector3.New(49.999, 299.999, 0))\n        assert(c31.row == 3 and c31.col == 1)\n    end\n    -- search\n    local center = g1:at(0,0)\n    local ce = g1:SearchClosest(center, function(c) return c.row % 2 == 0 and c.col %2 == 0 end)\n    assert(#ce == 5 and ce[1] == g1:at(0,2))\n    assert(ce[2] == g1:at(2,0))\n    assert(ce[3] == g1:at(2,2))\n    assert(ce[4] == g1:at(0,4))\n    assert(ce[5] == g1:at(2,4))\n\n    -- bfs\n    local g2 = Grid.New(10, 10, 100, 100)\n    center = g2:at(0,0)\n    g2:at(0,1).actor={id=12}\n    g2:at(0,2).actor={id=12}\n    g2:at(1,2).actor={id=730}\n    g2:at(2,2).actor={id=730}\n    g2:at(2,3).actor={id=0}\n    g2:MakeHole(1, 1)\n        :MakeHole(0, 3)\n        :MakeHole(1, 0)\n\n    local cells = g2:Bfs(center, function(c) return c.actor end)\n    assert(#cells == 5)\n    assert(not cells[center])\n    cells = g2:Bfs(center, function(c) return c.actor end, 3)\n    assert(#cells == 3)\n\n    local g2s = g2:serialize()\n    local g2s_64 = Base64.encode(g2s)\n    local g2s_2 = Base64.decode(g2s_64)\n    assert(g2s == g2s_2)\n    local g21 = Grid.deserialize(g2s_2)\n    assert(g21:at(0,1).actor.id==12)\n    assert(g21:at(0,2).actor.id==12)\n    assert(g21:at(1,2).actor.id==730)\n    assert(g21:at(2,2).actor.id==730)\n    assert(g21:at(2,3).actor.id==0)\n\n\n    local g3 = Grid.New(10, 10, 100, 100)\n    local r, c = 2, 3\n    for dr = -1, 1 do\n        for dc = -1, 1 do\n            local d = g3:at(r, c):Distance(g3:at(r+dr, c+dc))\n            assert(d < 2)\n            local md = g3:at(r, c):ManhattanDistance(g3:at(r+dr, c+dc))\n            assert(md <= 2)\n        end\n    end\n\n    print(\"grid -- ok\")\n\nend\n_test()\n\nreturn Grid"
      }
    }
    Assets {
      Id: 410319700329875550
      Name: "_Deque"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    Deque\n    A double ended queue from PIL.\n--]]\n\nlocal Deque = {}\nDeque.__index = Deque\n\nfunction Deque.New()\n    return setmetatable({_front = 0, _back = -1}, Deque)\nend\n\nfunction Deque:Clear()\n    for i = self._front, self._back, 1 do\n        self[i] = nil\n    end\n    self._front = 0\n    self._back = -1\nend\n\nfunction Deque:Empty()\n    return self._front > self._back\nend\n\nfunction Deque:Count()\n    if not self:Empty() then\n        return self._back - self._front + 1\n    else\n        return 0\n    end\nend\n\nfunction Deque:PushBack(value)\n    self._back = self._back + 1\n    self[self._back] = value\nend\n\nfunction Deque:PushFront(value)\n    self._front = self._front - 1\n    self[self._front] = value\nend\n\nfunction Deque:Front()\n    if not self:Empty() then\n        return self[self._front]\n    else\n        return nil\n    end\nend\n\nfunction Deque:Back()\n    if not self:Empty() then\n        return self[self._back]\n    else\n        return nil\n    end\nend\n\nfunction Deque:PopBack()\n    if not self:Empty() then\n        local val = self[self._back]\n        self[self._back] = nil\n        self._back = self._back - 1\n        return val\n    else\n        return nil\n    end\nend\n\nfunction Deque:PopFront()\n    if not self:Empty() then\n        local val = self[self._front]\n        self[self._front] = nil\n        self._front = self._front + 1\n        return val\n    else\n        return nil\n    end\nend\n\n-- aloases\nDeque.PeekFront = Deque.Front\nDeque.PeekBack = Deque.Back\n\nDeque.Push = Deque.PushBack\nDeque.Pop = Deque.PopFront\nDeque.Peek = Deque.PeekFront\nDeque.IsEmpty = Deque.Empty\n\nlocal function _test()\n    local q = Deque.New()\n    assert(q:Count() == 0 and q:IsEmpty())\n    q:Push(1)\n    q:Push(2)\n    q:Push(3)\n    q:Push(4)\n    assert(q:Count() == 4 and not q:IsEmpty())\n    assert(q:Front() == 1 and q:Back() == 4)\n    q:PopFront()\n    q:PopBack()\n    assert(q:Front() == 2 and q:Back() == 3 and q:Count() == 2)\n\n\n   print(\"deque -- ok\")\nend\n_test()\n\nreturn Deque"
      }
    }
    Assets {
      Id: 4327176263148897822
      Name: "_Bitarray"
      PlatformAssetType: 3
      TextAsset {
        Text: "-- fixed size compact, serializable bitarray\nlocal bitarray = {}\nbitarray.__index = bitarray\n\nlocal function nbytes(size)\n    local r, n = size%8, size//8\n    return r == 0 and n or n+1, r\nend\n\nfunction bitarray.new(size, default)\n    size = size or 32\n    local n = nbytes(size)\n    local _size = size\n    -- hide _size in closure\n    local self = {size=function() return _size end}\n\n    local fill = default and 0xFF or 0x00\n    for i=1, n do\n        self[i] = fill\n    end\n    return setmetatable(self, bitarray)\nend\n\n-- bitarray.eq :: self, other -> bool\n-- assume only [1..size] bits must be the same, fill not\nlocal rawequal = rawequal\nfunction bitarray:eq(other)\n    if rawequal(self, other) then return true end\n    if other.type ~= bitarray.type then return false end\n    local size = self.size()\n    if size ~= other.size() then return false end\n    local n, r = nbytes(size)\n     for i=1, n-1 do\n        if self[i] ~= other[i] then return false end\n    end\n    if r == 0 then\n        return self[n] == other[n]\n    else\n        return (self[n] ~ other[n]) & ~(-1 << r) == 0\n    end\nend\n\n-- `==` overload\nbitarray.__eq = bitarray.eq\n\n-- @ bitarray.set :: self, i, bool ^-> self\nfunction bitarray:set(i, val)\n    assert(i >= 1 and i <= self.size())\n    local idx, bit = (i-1)//8 + 1, (i-1)%8\n    local byte = self[idx]\n    byte = val and byte | (1 << bit) or byte & ~(1 << bit)\n    self[idx] = byte\n    return self\nend\n\n-- @ bitarray.get :: self, i -> bool\nfunction bitarray:get(i)\n    assert(i >= 1 and i <= self.size())\n    local idx, bit = (i-1)//8 + 1, (i-1)%8\n    return self[idx] & (1 << bit) ~= 0\nend\n\n-- @ bitarray.find_and_swap :: self[, bool=false] ^-> i | nil\n-- finds first asked boolean value, swap it and return it\'s index\nfunction bitarray:find_and_swap(bool)\n    bool = bool and true or false\n    for i = 1, self.size() do\n        if bool == self:get(i) then\n            self:set(i, not bool)\n            return i\n        end\n    end\nend\n\n-- @ bitarray.swap :: self, i ^-> i\n-- swap boolean at index i\nfunction bitarray:swap(i)\n    assert(i > 0 and i <= self.size())\n    local val = self:get(i)\n    self:set(i, not val)\n    return i\nend\n\n-- @ bitarray.serialize :: self -> string\n-- NOTE: serialize size to variable lenght utf8 codepoint\nfunction bitarray:serialize()\n    local size = utf8.char(self.size())\n    if #size == 1 then\n        return string.char(self.size(), table.unpack(self))\n    end\n    local s = string.char(table.unpack(self))\n    assert(#s == #self, \"limit on the number of return values reached?\")\n    return size..s\nend\n\n-- @ bitarray.deserialize :: string, first_byte_idx -> bitarray, next_byte_idx\nfunction bitarray.deserialize(str, from)\n    from = from or 1\n    local _size = utf8.codepoint(str, from)\n    local offset = utf8.offset(str, 2, from)\n    local n = nbytes(_size)\n    local self = {size=function() return _size end, string.byte(str, offset, offset + n)}\n    return setmetatable(self, bitarray), offset + n\nend\n\n-------------------------------------------------------------------------------\n-- bitvector32\n-------------------------------------------------------------------------------\nlocal bitvector32 = {}\nfunction bitvector32.new(data)\n    return setmetatable({data=data and data or 0}, bitvector32)\nend\n\n-- 1 based indices\nfunction bitvector32:__index(i)\n    assert(i > 0 and i <= 32)\n    local bit = i - 1\n    return self.data & (1 << bit) ~= 0\nend\n\nfunction bitvector32:__newindex(i, v)\n    assert(i > 0 and i <= 32)\n    local bit = i - 1\n    self.data = v and self.data | (1 << bit) or self.data & ~(1 << bit)\nend\n\n-- popcount32\nfunction bitvector32:__len()\n    local x = self.data\n    x = x - ((x >> 1) & 0x55555555)\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0F0F0F0F\n    return ((x * 0x01010101) & 0xFFFFFFFF) >> 24\nend\n\nfunction bitvector32:__eq(other)\n    return self.data == other.data\nend\n\n-- () -> i32\nfunction bitvector32:__call()\n    local n = self.data\n    -- converts to signed\n    return n < 0x7FFFFFFF and n or n - 0x100000000\nend\n\nbitarray.bitvec32 = bitvector32\nbitarray.bitvector32 = bitvector32\n-------------------------------------------------------------------------------\nlocal function _bitarray_test()\n    local ba1 = bitarray.new(9, true)\n    assert(ba1.size() == 9)\n    assert(ba1:eq(ba1))\n    assert(ba1 ==  ba1)\n    ba1:set(1, nil)\n    assert(not ba1:get(1))\n    assert(ba1:get(2) and ba1:get(9))\n\n    local ba2 = bitarray.new(7)\n    assert(ba2.size() == 7)\n    assert(ba2:find_and_swap() == 1 and ba2:get(1))\n    ba2:swap(1)\n    assert(not ba2:get(1))\n    ba2:set(2, true):set(7, true)\n    for i=1, 7 do\n        if i == 2 or i == 7 then\n            assert(ba2:get(i))\n        else\n            assert(not ba2:get(i))\n        end\n    end\n\n    local ba2s = ba2:serialize()\n    assert(#ba2s == 2 and string.byte(ba2s) == 7 and string.byte(ba2s, 2, 2) == 66)\n    local ba21 = bitarray.deserialize(ba2s)\n    assert(ba2:eq(ba21))\n    assert(ba2 == ba21)\n    assert(ba2 ~= ba1)\n\n    -- limits\n    local N = 10000 -- tested up to 1MM\n    local ba10K = bitarray.new(N, true)\n    ba10K:set(N//2, nil)\n    local ba10Ks = ba10K:serialize()\n    local ba10K1 = bitarray.deserialize(ba10Ks)\n    assert(ba10K:eq(ba10K1))\n    assert(ba10K == ba10K1)\n    assert(not ba10K1:get(N//2))\n\n    -- part string\n    local ba4 = bitarray.new(123, true):set(14, nil):set(25, nil)\n    local ba3s = \"GRID\" .. ba2s .. ba4:serialize()\n    local ba3, ba4n = bitarray.deserialize(ba3s, 5)\n    local ba41 = bitarray.deserialize(ba3s, ba4n)\n    assert(ba2:eq(ba3))\n    assert(ba4:eq(ba41))\n    --\n    local ba = bitarray.new(765, true):set(15, nil):set(22, nil)\n    local s = \"GRID\" .. utf8.char(10240, 33000) .. ba:serialize() .. \'tail\'\n\n    local w, h = utf8.codepoint(s, 5, utf8.offset(s, 2, 5))\n    assert(w == 10240 and h == 33000)\n    local ba11, next = bitarray.deserialize(s, utf8.offset(s, 3, 5))\n    assert(ba11:eq(ba))\n    assert(s:sub(next) == \'tail\')\n\n    -- still equal with different fills\n    local ba71 = bitarray.new(7, true)\n    local ba72 = bitarray.new(7, false)\n    for i=1, ba72.size() do ba72:set(i, true) end\n    assert(ba71:eq(ba72))\n    ba71:set(2, nil)\n    ba72:set(2, nil)\n    assert(ba71:eq(ba72))\n    --\n    print(\"bitarray -- ok\")\nend\n_bitarray_test()\n\nlocal function _bitvector32_test()\n    local bv = bitvector32.new()\n    assert(not bv[1])\n    bv[1] = 1\n    assert(bv[1])\n    assert(not bv[32])\n    bv[32] = 1\n    assert(bv[32])\n\n    -- equals\n    local bv2 = bitvector32.new(4294967295)\n    for i = 1,32  do\n        assert(bv2[i])\n    end\n\n    -- to i32\n    do\n        local i32 = -2147483648\n        assert(i32 ==  bitvector32.new(i32)())\n        assert(bitvector32.new(i32) == bitvector32.new(i32))\n    end\n\n    -- popcount\n    -- assert(math.type(x) == \"integer\" and x >= -2147483648 and x <= 2147483647)\n    for i=1, 1000 do\n        local x = math.random(-2147483648, 2147483647)\n        local b = bitvector32.new(x)\n        local c1 = #b\n        local c2 = 0\n        for j=1, 32 do\n            c2 = c2 + (b[j] and 1 or 0)\n        end\n        assert(c1==c2)\n    end\n\n    if CoreDebug and Environment.IsServer() then\n        while #Game.GetPlayers() == 0 do\n            Task.Wait()\n        end\n        local PLAYER = Game.GetPlayers()[1]\n        for i=1, 1000 do\n            -- local x = math.random(-2147483648, 2147483647)\n            local x = -2147483648\n            PLAYER:SetResource(\"@@@\", x)\n            assert(x == PLAYER:GetResource(\"@@@\"))\n            local b = bitvector32.new(x)\n            PLAYER:SetResource(\"@@@\", b())\n            print(PLAYER:GetResource(\"@@@\"), b())\n            local b1 = bitvector32.new(PLAYER:GetResource(\"@@@\"))\n            assert(b == b1)\n            local pdata = Storage.GetPlayerData(PLAYER)\n            pdata[\"@@@\"] = b.data\n            Storage.SetPlayerData(PLAYER, pdata)\n            local b2 =  bitvector32.new(Storage.GetPlayerData(PLAYER)[\"@@@\"])\n            assert(b == b2)\n        end\n    end\n    print(\"bitvector32 -- ok\")\nend\n-- _bitvector32_test()\nreturn bitarray"
      }
    }
    Assets {
      Id: 9544232931398361545
      Name: "_Base64"
      PlatformAssetType: 3
      TextAsset {
        Text: "-- The MIT Licence (MIT)\r\n-- Copyright (c) 2021 Andrew Zhilin (andrew.zhilin@gmail.com)\r\n\r\nlocal base64= {}\r\nlocal char, byte, gsub, find = string.char, string.byte, string.gsub, string.find\r\n-- symbols for ref: \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\'\r\nlocal PAD = string.byte(\'=\')\r\n\r\nlocal enc do\r\n    local ENC = {[0]=\r\n        0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\r\n        0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\r\n        0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\r\n        0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,\r\n        0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,\r\n        0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,\r\n        0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33,\r\n        0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2B, 0x2F,\r\n    }\r\n    -- pass data string to _enc\r\n    local _data = nil\r\n    -- caching lambda, it saves us ~100 bytes\r\n    -- unrolled for 36->48 chars, for big strings (> 1K) it gives 3-4x less garbage\r\n    local function _enc(x, y)\r\n        local data = _data -- pass data string to inner scope\r\n        -- 36 -> 48\r\n        if y - x == 36 then\r\n            local\r\n                a1, b1, c1, a2, b2, c2, a3, b3, c3,\r\n                a4, b4, c4, a5, b5, c5, a6, b6, c6,\r\n                a7, b7, c7, a8, b8, c8, a9, b9, c9,\r\n                aa, ba, ca, ab, bb, cb, ac, bc, cc = byte(data, x, x + 35)\r\n        return char(\r\n            ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], ENC[(b1&15)<<2|c1>>6], ENC[c1&63],\r\n            ENC[a2>>2], ENC[(a2&3)<<4|b2>>4], ENC[(b2&15)<<2|c2>>6], ENC[c2&63],\r\n            ENC[a3>>2], ENC[(a3&3)<<4|b3>>4], ENC[(b3&15)<<2|c3>>6], ENC[c3&63],\r\n            ENC[a4>>2], ENC[(a4&3)<<4|b4>>4], ENC[(b4&15)<<2|c4>>6], ENC[c4&63],\r\n            ENC[a5>>2], ENC[(a5&3)<<4|b5>>4], ENC[(b5&15)<<2|c5>>6], ENC[c5&63],\r\n            ENC[a6>>2], ENC[(a6&3)<<4|b6>>4], ENC[(b6&15)<<2|c6>>6], ENC[c6&63],\r\n            ENC[a7>>2], ENC[(a7&3)<<4|b7>>4], ENC[(b7&15)<<2|c7>>6], ENC[c7&63],\r\n            ENC[a8>>2], ENC[(a8&3)<<4|b8>>4], ENC[(b8&15)<<2|c8>>6], ENC[c8&63],\r\n            ENC[a9>>2], ENC[(a9&3)<<4|b9>>4], ENC[(b9&15)<<2|c9>>6], ENC[c9&63],\r\n            ENC[aa>>2], ENC[(aa&3)<<4|ba>>4], ENC[(ba&15)<<2|ca>>6], ENC[ca&63],\r\n            ENC[ab>>2], ENC[(ab&3)<<4|bb>>4], ENC[(bb&15)<<2|cb>>6], ENC[cb&63],\r\n            ENC[ac>>2], ENC[(ac&3)<<4|bc>>4], ENC[(bc&15)<<2|cc>>6], ENC[cc&63]\r\n        )\r\n        end\r\n\r\n        local out = {}\r\n        local a1, b1, c1, a2, b2, c2, a3, b3, c3\r\n        -- 9 -> 12\r\n        while x + 8 < y do\r\n            a1, b1, c1, a2, b2, c2, a3, b3, c3 = byte(data, x, x + 8)\r\n            out[#out+1] = char(\r\n                ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], ENC[(b1&15)<<2|c1>>6], ENC[c1&63],\r\n                ENC[a2>>2], ENC[(a2&3)<<4|b2>>4], ENC[(b2&15)<<2|c2>>6], ENC[c2&63],\r\n                ENC[a3>>2], ENC[(a3&3)<<4|b3>>4], ENC[(b3&15)<<2|c3>>6], ENC[c3&63]\r\n            )\r\n            x = x + 9\r\n        end\r\n        -- 3 -> 4\r\n        while x + 2 < y do\r\n            a1, b1, c1 = byte(data, x, x + 2)\r\n            out[#out+1] = char(ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], ENC[(b1&15)<<2|c1>>6], ENC[c1&63])\r\n            x = x + 3\r\n        end\r\n        -- tail: 1..2 -> 3..2 + padding\r\n        local n = y - x\r\n        if n == 2 then\r\n            a1, b1 = byte(data, x, x + 1)\r\n            c1 = 0\r\n            out[#out+1] = char(ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], ENC[(b1&15)<<2|c1>>6], PAD)\r\n        elseif n == 1 then\r\n            a1 = byte(data, x)\r\n            b1 = 0\r\n            out[#out+1] = char(ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], PAD, PAD)\r\n        end\r\n        return table.concat(out)\r\n    end\r\n\r\n    -- there is no limiting quantifier support in lua pattens ...\r\n    local OPT36 = \"()\" .. string.rep(\'.?\', 36) .. \"()\"\r\n    enc = function(data)\r\n        _data = data -- pass data to outer scope\r\n        return (gsub(_data, OPT36, _enc))\r\n    end\r\nend\r\n\r\nlocal dec do\r\n    local DEC = {\r\n        [0x41]=0x00, [0x42]=0x01, [0x43]=0x02, [0x44]=0x03, [0x45]=0x04, [0x46]=0x05, [0x47]=0x06, [0x48]=0x07,\r\n        [0x49]=0x08, [0x4A]=0x09, [0x4B]=0x0A, [0x4C]=0x0B, [0x4D]=0x0C, [0x4E]=0x0D, [0x4F]=0x0E, [0x50]=0x0F,\r\n        [0x51]=0x10, [0x52]=0x11, [0x53]=0x12, [0x54]=0x13, [0x55]=0x14, [0x56]=0x15, [0x57]=0x16, [0x58]=0x17,\r\n        [0x59]=0x18, [0x5A]=0x19, [0x61]=0x1A, [0x62]=0x1B, [0x63]=0x1C, [0x64]=0x1D, [0x65]=0x1E, [0x66]=0x1F,\r\n        [0x67]=0x20, [0x68]=0x21, [0x69]=0x22, [0x6A]=0x23, [0x6B]=0x24, [0x6C]=0x25, [0x6D]=0x26, [0x6E]=0x27,\r\n        [0x6F]=0x28, [0x70]=0x29, [0x71]=0x2A, [0x72]=0x2B, [0x73]=0x2C, [0x74]=0x2D, [0x75]=0x2E, [0x76]=0x2F,\r\n        [0x77]=0x30, [0x78]=0x31, [0x79]=0x32, [0x7A]=0x33, [0x30]=0x34, [0x31]=0x35, [0x32]=0x36, [0x33]=0x37,\r\n        [0x34]=0x38, [0x35]=0x39, [0x36]=0x3A, [0x37]=0x3B, [0x38]=0x3C, [0x39]=0x3D, [0x2B]=0x3E, [0x2F]=0x3F,\r\n    }\r\n\r\n    local _b64str = nil\r\n    -- caching lambda, it saves us ~100 bytes\r\n    -- unrolled for 48->36 chars, for big strings (> 1K) it gives 3-4x less garbage\r\n    local function _dec(x, y)\r\n        local b64str = _b64str\r\n        -- 48 -> 36\r\n        if y - x == 48 and byte(b64str, x + 47) ~= PAD then\r\n            local\r\n                a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3,\r\n                a4, b4, c4, d4, a5, b5, c5, d5, a6, b6, c6, d6,\r\n                a7, b7, c7, d7, a8, b8, c8, d8, a9, b9, c9, d9,\r\n                aa, ba, ca, da, ab, bb, cb, db, ac, bc, cc, dc =\r\n                    byte(b64str, x, x + 47)\r\n                -- decode all\r\n                a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3,\r\n                a4, b4, c4, d4, a5, b5, c5, d5, a6, b6, c6, d6,\r\n                a7, b7, c7, d7, a8, b8, c8, d8, a9, b9, c9, d9,\r\n                aa, ba, ca, da, ab, bb, cb, db, ac, bc, cc, dc =\r\n                    DEC[a1], DEC[b1], DEC[c1], DEC[d1], DEC[a2], DEC[b2], DEC[c2], DEC[d2],\r\n                    DEC[a3], DEC[b3], DEC[c3], DEC[d3], DEC[a4], DEC[b4], DEC[c4], DEC[d4],\r\n                    DEC[a5], DEC[b5], DEC[c5], DEC[d5], DEC[a6], DEC[b6], DEC[c6], DEC[d6],\r\n                    DEC[a7], DEC[b7], DEC[c7], DEC[d7], DEC[a8], DEC[b8], DEC[c8], DEC[d8],\r\n                    DEC[a9], DEC[b9], DEC[c9], DEC[d9], DEC[aa], DEC[ba], DEC[ca], DEC[da],\r\n                    DEC[ab], DEC[bb], DEC[cb], DEC[db], DEC[ac], DEC[bc], DEC[cc], DEC[dc]\r\n            return char(\r\n                a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F,\r\n                a2<<2&0xFC|b2>>4&0x03, b2<<4&0xF0|c2>>2&0x0F, c2<<6&0xC0|d2>>0&0x3F,\r\n                a3<<2&0xFC|b3>>4&0x03, b3<<4&0xF0|c3>>2&0x0F, c3<<6&0xC0|d3>>0&0x3F,\r\n                a4<<2&0xFC|b4>>4&0x03, b4<<4&0xF0|c4>>2&0x0F, c4<<6&0xC0|d4>>0&0x3F,\r\n                a5<<2&0xFC|b5>>4&0x03, b5<<4&0xF0|c5>>2&0x0F, c5<<6&0xC0|d5>>0&0x3F,\r\n                a6<<2&0xFC|b6>>4&0x03, b6<<4&0xF0|c6>>2&0x0F, c6<<6&0xC0|d6>>0&0x3F,\r\n                a7<<2&0xFC|b7>>4&0x03, b7<<4&0xF0|c7>>2&0x0F, c7<<6&0xC0|d7>>0&0x3F,\r\n                a8<<2&0xFC|b8>>4&0x03, b8<<4&0xF0|c8>>2&0x0F, c8<<6&0xC0|d8>>0&0x3F,\r\n                a9<<2&0xFC|b9>>4&0x03, b9<<4&0xF0|c9>>2&0x0F, c9<<6&0xC0|d9>>0&0x3F,\r\n                aa<<2&0xFC|ba>>4&0x03, ba<<4&0xF0|ca>>2&0x0F, ca<<6&0xC0|da>>0&0x3F,\r\n                ab<<2&0xFC|bb>>4&0x03, bb<<4&0xF0|cb>>2&0x0F, cb<<6&0xC0|db>>0&0x3F,\r\n                ac<<2&0xFC|bc>>4&0x03, bc<<4&0xF0|cc>>2&0x0F, cc<<6&0xC0|dc>>0&0x3F\r\n            )\r\n        end\r\n\r\n        local out = {}\r\n        local a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3\r\n        -- 12 -> 9\r\n        while x + 11 < y - 4 do -- all but last 4\r\n            a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3 = byte(b64str, x, x + 11)\r\n            a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3 =\r\n                DEC[a1], DEC[b1], DEC[c1], DEC[d1], DEC[a2], DEC[b2],\r\n                DEC[c2], DEC[d2], DEC[a3], DEC[b3], DEC[c3], DEC[d3]\r\n            out[#out+1] = char(\r\n                a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F,\r\n                a2<<2&0xFC|b2>>4&0x03, b2<<4&0xF0|c2>>2&0x0F, c2<<6&0xC0|d2>>0&0x3F,\r\n                a3<<2&0xFC|b3>>4&0x03, b3<<4&0xF0|c3>>2&0x0F, c3<<6&0xC0|d3>>0&0x3F\r\n            )\r\n            x = x + 12\r\n        end\r\n        -- 4 -> 3\r\n        while x + 3 < y - 4 do -- all but last 4\r\n            a1, b1, c1, d1 = byte(b64str, x, x + 3)\r\n            a1, b1, c1, d1 = DEC[a1], DEC[b1], DEC[c1], DEC[d1]\r\n            out[#out+1] = char(a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F)\r\n            x = x + 4\r\n        end\r\n        -- last 4 -> 1..3\r\n        a1, b1, c1, d1 = byte(b64str, x, x + 3)\r\n        a1, b1, c1, d1 = DEC[a1], DEC[b1], DEC[c1], DEC[d1]\r\n        local n = c1 and d1 and 3 or c1 and 2 or 1\r\n        if n == 3 then\r\n            out[#out+1] = char(a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F)\r\n        elseif n == 2 then\r\n            out[#out+1] = char(a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F)\r\n        elseif n == 1 then\r\n            out[#out+1] = char(a1<<2&0xFC|b1>>4&0x03)\r\n        end\r\n        return table.concat(out)\r\n    end\r\n\r\n    local OPT48 = \"()\" .. string.rep(\'.?\', 48) .. \"()\"\r\n    dec = function (b64str)\r\n        if #b64str == 0 then return \"\" end\r\n        -- remove whitespace if any\r\n        if find(b64str, \"%s+\") then b64str = gsub(b64str, \"%s+\", \"\") end\r\n        assert(#b64str%4 == 0, \"invalid encoding: input length is not divisible by 4\")\r\n        _b64str = b64str -- pass to outer scope\r\n        return (gsub(b64str, OPT48, _dec)) -- coerce to 1 result\r\n    end\r\n\r\n    ----------------------------------\r\n    -- partial decode utils:\r\n    ----------------------------------\r\n\r\n    local function _test(prefix, ...)\r\n        assert(prefix and #prefix <= 3, \"max length of prefix should be 3\")\r\n        assert(select(\"#\", ...) == 3)\r\n        for i = 1, #prefix do\r\n            if byte(prefix, i) ~= select(i, ...) then return false end\r\n        end\r\n        return true\r\n    end\r\n\r\n    -- dec3 :: base64 -> byte1, byte2, byte3\r\n    local function dec3(s64)\r\n        assert(s64 and #s64 >= 4, \"length of encoded string should be >= 4\")\r\n        local a1, b1, c1, d1 = byte(s64, 1, 4)\r\n        a1, b1, c1, d1 = DEC[a1], DEC[b1], DEC[c1], DEC[d1]\r\n        return a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F\r\n    end\r\n\r\n    local function test_prefix(s64, prefix)\r\n        return _test(prefix, dec3(s64))\r\n    end\r\n\r\n    -- select_prefix :: base64, prefix1, prefix2, ...  -> index\r\n    local function select_prefix(s64, ...)\r\n        local n = select(\"#\", ...)\r\n        local b1, b2, b3 = dec3(s64)\r\n        for i = 1, n do\r\n            if _test(select(i, ...), b1, b2, b3) then return i end\r\n        end\r\n    end\r\n\r\n    -- exports\r\n    base64.dec3 = dec3\r\n    base64.test_prefix = test_prefix\r\n    base64.select_prefix = select_prefix\r\nend\r\n\r\nlocal function _self_test()\r\n    local data = {\r\n        [\"\"] = \"\",\r\n        [\"A\"]=\"QQ==\",\r\n        [\"BC\"]=\"QkM=\",\r\n        [\"DEF\"]=\"REVG\",\r\n        [\"*?!@\"]=\"Kj8hQA==\",\r\n        [\"Man \"]=\"TWFuIA==\",\r\n        [\"7904 (base10)\"]=\"NzkwNCAoYmFzZTEwKQ==\",\r\n        [\"1337lEEt\\0\\0\\0\\0\"]=\"MTMzN2xFRXQAAAAA\",\r\n        [\"Use our super handy online tool to decode or encode your data.\"] =\r\n            \"VXNlIG91ciBzdXBlciBoYW5keSBvbmxpbmUgdG9vbCB0byBkZWNvZGUgb3IgZW5jb2RlIHlvdXIgZGF0YS4=\",\r\n        [\"<D\\254\"] = \"PET+\"\r\n    }\r\n    for r, e in pairs(data) do\r\n        assert(enc(r) == e, string.format(\"err encode: %q -> %q\", r, enc(r)))\r\n        assert(dec(e) == r, string.format(\"err decode: %q -> %q\", r, dec(e)))\r\n    end\r\n\r\n    local s64 = enc(\"7904 (base10)\")\r\n    assert(base64.test_prefix(s64, \"7\"))\r\n    assert(base64.test_prefix(s64, \"79\"))\r\n    assert(base64.test_prefix(s64, \"790\"))\r\n    assert(base64.select_prefix(s64, \"A\", \"BB\", \"790\", \"CCC\") == 3)\r\n\r\n    assert(base64.test_prefix(\"REVG\", \"DEF\"))\r\n\r\n    -- test bugfix (dec returns 2 values)\r\n    local id = \"eec0239c0d644f5bb9f59779307edb17\"\r\n    local fmt = \"c1 z c3\"\r\n    local x = string.pack(fmt, \"$\", id, \"C09\")\r\n    assert(select(2, string.unpack(fmt, x)) == id)\r\n    assert(select(2, string.unpack(fmt, dec(enc(x)))) == id)\r\n\r\n    --\r\n    print(\'base64 -- ok\')\r\nend\r\n\r\n_self_test()\r\n\r\n-- exports\r\nbase64.encode = enc\r\nbase64.decode = dec\r\n\r\nreturn base64"
      }
    }
    PrimaryAssetId {
      AssetType: "None"
      AssetId: "None"
    }
  }
  SerializationVersion: 81
}
IncludesAllDependencies: true
