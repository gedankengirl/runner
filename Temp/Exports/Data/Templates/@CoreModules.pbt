Assets {
  Id: 17771149258410848072
  Name: "@CoreModules"
  PlatformAssetType: 5
  TemplateAsset {
    ObjectBlock {
      RootId: 16291094792229598910
      Objects {
        Id: 16291094792229598910
        Name: "@CoreModules"
        Transform {
          Scale {
            X: 1
            Y: 1
            Z: 1
          }
        }
        ParentId: 4781671109827199097
        ChildIds: 3989999382868994304
        ChildIds: 2709063500133343796
        UnregisteredParameters {
          Overrides {
            Name: "cs:_Deque"
            AssetReference {
              Id: 410319700329875550
            }
          }
          Overrides {
            Name: "cs:_Heap"
            AssetReference {
              Id: 2361961766352951098
            }
          }
          Overrides {
            Name: "cs:_Maid"
            AssetReference {
              Id: 10304107291754736192
            }
          }
          Overrides {
            Name: "cs:_PQmax"
            AssetReference {
              Id: 16283193609845389182
            }
          }
          Overrides {
            Name: "cs:_PQmin"
            AssetReference {
              Id: 9342788341295903362
            }
          }
          Overrides {
            Name: "cs:_ReliableEvents"
            AssetReference {
              Id: 14454691258374778668
            }
          }
          Overrides {
            Name: "cs:_Spring"
            AssetReference {
              Id: 17918387935289379105
            }
          }
          Overrides {
            Name: "cs:_Base64"
            AssetReference {
              Id: 9544232931398361545
            }
          }
          Overrides {
            Name: "cs:_Ascii85"
            AssetReference {
              Id: 5070080147057503107
            }
          }
          Overrides {
            Name: "cs:_Snippets"
            AssetReference {
              Id: 4739659780833170311
            }
          }
          Overrides {
            Name: "cs:_Spr"
            AssetReference {
              Id: 7602836839952416252
            }
          }
          Overrides {
            Name: "cs:_StateMachine"
            AssetReference {
              Id: 15572707156245510975
            }
          }
          Overrides {
            Name: "cs:_Grid"
            AssetReference {
              Id: 12769054960477199651
            }
          }
          Overrides {
            Name: "cs:_Bitarray"
            AssetReference {
              Id: 4327176263148897822
            }
          }
          Overrides {
            Name: "cs:_Luapp"
            AssetReference {
              Id: 7243897883920053925
            }
          }
          Overrides {
            Name: "cs:_Trampoline"
            AssetReference {
              Id: 3973205370573435669
            }
          }
          Overrides {
            Name: "cs:_Xoshiro256"
            AssetReference {
              Id: 9765507830262698727
            }
          }
          Overrides {
            Name: "cs:BusinessLogic"
            AssetReference {
              Id: 18342435553950571227
            }
          }
          Overrides {
            Name: "cs:Protocols"
            AssetReference {
              Id: 5305102967692430199
            }
          }
          Overrides {
            Name: "cs:StaticData"
            AssetReference {
              Id: 14856984160948620178
            }
          }
        }
        Collidable_v2 {
          Value: "mc:ecollisionsetting:forceoff"
        }
        Visible_v2 {
          Value: "mc:evisibilitysetting:forceoff"
        }
        Folder {
          IsFilePartition: true
          FilePartitionName: "_CoreModules"
        }
      }
      Objects {
        Id: 3989999382868994304
        Name: "ClientContext"
        Transform {
          Location {
          }
          Rotation {
          }
          Scale {
            X: 1
            Y: 1
            Z: 1
          }
        }
        ParentId: 16291094792229598910
        ChildIds: 10159195518397696328
        Collidable_v2 {
          Value: "mc:ecollisionsetting:forceoff"
        }
        Visible_v2 {
          Value: "mc:evisibilitysetting:inheritfromparent"
        }
        NetworkContext {
        }
      }
      Objects {
        Id: 10159195518397696328
        Name: "InitModules"
        Transform {
          Location {
          }
          Rotation {
          }
          Scale {
            X: 1
            Y: 1
            Z: 1
          }
        }
        ParentId: 3989999382868994304
        Collidable_v2 {
          Value: "mc:ecollisionsetting:inheritfromparent"
        }
        Visible_v2 {
          Value: "mc:evisibilitysetting:inheritfromparent"
        }
        Script {
          ScriptAsset {
            Id: 6625644237715666445
          }
        }
      }
      Objects {
        Id: 2709063500133343796
        Name: "InitModules"
        Transform {
          Location {
          }
          Rotation {
          }
          Scale {
            X: 1
            Y: 1
            Z: 1
          }
        }
        ParentId: 16291094792229598910
        Collidable_v2 {
          Value: "mc:ecollisionsetting:inheritfromparent"
        }
        Visible_v2 {
          Value: "mc:evisibilitysetting:inheritfromparent"
        }
        Script {
          ScriptAsset {
            Id: 6625644237715666445
          }
        }
      }
    }
    Assets {
      Id: 6625644237715666445
      Name: "InitModules"
      PlatformAssetType: 3
      TextAsset {
        Text: "local container = Environment.IsClient() and script.parent.parent or script.parent\r\nlocal modules = container:GetCustomProperties()\r\nlocal shorts = {}\r\n\r\nlocal UNDERSCORE = string.byte(\'_\')\r\nfor name, muid in pairs(modules) do\r\n    if #name > 1 and name:byte(1) == UNDERSCORE then\r\n        local short = name:sub(2)\r\n        shorts[short] = muid\r\n    end\r\nend\r\n\r\n_G.req = function(moduleName)\r\n    local muid = modules[moduleName] or shorts[moduleName]\r\n    if not muid then\r\n        error(\"unknown module: \'\" .. moduleName .. \"\'\", 2)\r\n    end\r\n    return require(muid)\r\nend\r\n\r\n"
      }
    }
    Assets {
      Id: 14856984160948620178
      Name: "StaticData"
      PlatformAssetType: 3
      TextAsset {
        Text: "local StaticData = {}\r\nStaticData.__index = StaticData\r\n\r\nlocal UPGRADE = {\r\n    NO_UPGRADE = 1,\r\n    GOLDEN = 2,\r\n    DIAMOND = 3,\r\n    EMERALD = 4,\r\n    RUBY = 5,\r\n    DARK = 6,\r\n    PERLECENT = 7\r\n}\r\n\r\n-- limit max upgrade\r\nUPGRADE.MAX = UPGRADE.DIAMOND\r\n\r\nlocal UPGRADE_NAMES = {\r\n \"\", \"Golden\", \"Diamond\", \"Emerald\", \"Ruby\", \"Dark\", \"Perlecent\"\r\n}\r\n\r\nlocal RARITY = {\r\n    COMMON = 1,\r\n    UNIQUE = 2,\r\n    RARE = 3,\r\n    EPIC = 4,\r\n    LEGENDARY = 5,\r\n    MYTHIC = 6,\r\n    GODLY = 7\r\n}\r\n\r\nlocal RARITY_NAMES = {\r\n    \"Common\", \"Unique\", \"Rare\", \"Epic\", \"Legendary\", \"Mythic\", \"Godly\"\r\n}\r\n\r\n-- name, rarity, upgrade, bonus, muid, [next upgrade id]\r\nlocal PetDb, EggDb do\r\n    local kName, kRarity, kUpgrade, kBonus, kMuid, kNextUpgradeId = 1, 2, 3, 4, 5\r\n    PetDb = {\r\n        -- 1\r\n        {\"Bee\",      RARITY.COMMON, UPGRADE.NO_UPGRADE,   2,  \"657199ADF67F7CF8:$Bee_1_ClientContext\"},\r\n        {\"Bee\",      RARITY.COMMON, UPGRADE.GOLDEN,       4,  \"F13AA8B68801D8BD:$Bee_2_ClientContext\"},\r\n        {\"Bee\",      RARITY.COMMON, UPGRADE.DIAMOND,      8, \"FF21F3E0457977D1:$Bee_3_ClientContext\"},\r\n\r\n        {\"Gnome\",    RARITY.COMMON, UPGRADE.NO_UPGRADE,   3,  \"F5302EE25E9F9D4F:$Gnome_1_ClientContext\"},\r\n        {\"Gnome\",    RARITY.COMMON, UPGRADE.GOLDEN,       6,  \"D24270AC73BE7243:$Gnome_2_ClientContext\"},\r\n        {\"Gnome\",    RARITY.COMMON, UPGRADE.DIAMOND,      10, \"630295E0FE016E5B:$Gnome_3_ClientContext\"},\r\n\r\n        {\"Birdie\",   RARITY.RARE, UPGRADE.NO_UPGRADE,     6,  \"58C1BC6D4E3E52EF:$Birdie_1_ClientContext\"},\r\n        {\"Birdie\",   RARITY.RARE, UPGRADE.GOLDEN,         10,  \"F1DE16434F864AD5:$Birdie_2_ClientContext\"},\r\n        {\"Birdie\",   RARITY.RARE, UPGRADE.DIAMOND,        14, \"B3958F910891BB16:$Birdie_3_ClientContext\"},\r\n        -- 2 -- TODO: bonuses for later arenas\r\n        {\"Monkey\",   RARITY.COMMON, UPGRADE.NO_UPGRADE,   4,  \"DA2AF5973CC4AAC7:$Monkey_1_ClientContext\"},\r\n        {\"Monkey\",   RARITY.COMMON, UPGRADE.GOLDEN,       8,  \"4921CFB551E57DF0:$Monkey_2_ClientContext\"},\r\n        {\"Monkey\",   RARITY.COMMON, UPGRADE.DIAMOND,      12, \"EA4B79D1C34D0C57:$Monkey_3_ClientContext\"},\r\n\r\n        {\"Bull\",     RARITY.RARE, UPGRADE.NO_UPGRADE,     4,  \"8B6E8CCC1AD210FF:$Bull_1_ClientContext\"},\r\n        {\"Bull\",     RARITY.RARE, UPGRADE.GOLDEN,         8,  \"44C36F7D9935979F:$Bull_2_ClientContext\"},\r\n        {\"Bull\",     RARITY.RARE, UPGRADE.DIAMOND,        12, \"4B40EAF86CA2C086:$Bull_3_ClientContext\"},\r\n\r\n        {\"Cat\",      RARITY.EPIC, UPGRADE.NO_UPGRADE,     4,  \"0C4EB2DA3414B14F:$Cat_1_ClientContext\"},\r\n        {\"Cat\",      RARITY.EPIC, UPGRADE.GOLDEN,         8,  \"DFE30E8B8B8E3A13:$Cat_2_ClientContext\"},\r\n        {\"Cat\",      RARITY.EPIC, UPGRADE.DIAMOND,        12, \"CB0B715CE9DAAB6B:$Cat_3_ClientContext\"},\r\n        -- 3\r\n        {\"Bat\",      RARITY.RARE, UPGRADE.NO_UPGRADE,      4,  \"0CFD2C321CA36B14:$Bat_1_ClientContext\"},\r\n        {\"Bat\",      RARITY.RARE, UPGRADE.GOLDEN,          8,  \"9456CF56DF2AAE9F:$Bat_2_ClientContext\"},\r\n        {\"Bat\",      RARITY.RARE, UPGRADE.DIAMOND,         12, \"C21E3BB91DE75225:$Bat_3_ClientContext\"},\r\n\r\n        {\"Ghost\",    RARITY.EPIC, UPGRADE.NO_UPGRADE,     4,  \"CF55C15AEFAE9044:$Ghost_1_ClientContext\"},\r\n        {\"Ghost\",    RARITY.EPIC, UPGRADE.GOLDEN,         8,  \"BA0A766F76B7E34A:$Ghost_2_ClientContext\"},\r\n        {\"Ghost\",    RARITY.EPIC, UPGRADE.DIAMOND,        12, \"0C0160C5404C95B7:$Ghost_3_ClientContext\"},\r\n\r\n        {\"Witch\",    RARITY.LEGENDARY, UPGRADE.NO_UPGRADE, 4,  \"A1B2E8E17077708A:$Witch_1_ClientContext\"},\r\n        {\"Witch\",    RARITY.LEGENDARY, UPGRADE.GOLDEN,     8,  \"2F2C5E5DC7F6C4B8:$Witch_2_ClientContext\"},\r\n        {\"Witch\",    RARITY.LEGENDARY, UPGRADE.DIAMOND,    12, \"3E796B0666945BE2:$Witch_3_ClientContext\"},\r\n        -- 4\r\n        {\"Flamingo\", RARITY.COMMON, UPGRADE.NO_UPGRADE,    4,  \"C144AB8425326692:$Flamingo_1_ClientContext\"},\r\n        {\"Flamingo\", RARITY.COMMON, UPGRADE.GOLDEN,        8,  \"DFC51798AA8AF2B9:$Flamingo_2_ClientContext\"},\r\n        {\"Flamingo\", RARITY.COMMON, UPGRADE.DIAMOND,       12, \"368285AECAD6C069:$Flamingo_3_ClientContext\"},\r\n\r\n        {\"Crab\",     RARITY.COMMON, UPGRADE.NO_UPGRADE,    4,  \"4371AE07A16CB143:$Crab_1_ClientContext\"},\r\n        {\"Crab\",     RARITY.COMMON, UPGRADE.GOLDEN,        8,  \"2D37568E6E6804CC:$Crab_2_ClientContext\"},\r\n        {\"Crab\",     RARITY.COMMON, UPGRADE.DIAMOND,       12, \"B040C298A49D9FE7:$Crab_3_ClientContext\"},\r\n\r\n        {\"Mermaid\",  RARITY.LEGENDARY, UPGRADE.NO_UPGRADE, 4,  \"2DBDC09751CE4485:$Mermaid_1_ClientContext\"},\r\n        {\"Mermaid\",  RARITY.LEGENDARY, UPGRADE.GOLDEN,     8,  \"1796205E3ECA0CA6:$Mermaid_2_ClientContext\"},\r\n        {\"Mermaid\",  RARITY.LEGENDARY, UPGRADE.DIAMOND,    12, \"6C8621CFD91213A9:$Mermaid_3_ClientContext\"},\r\n        -- 5\r\n        {\"Mushroom\", RARITY.RARE, UPGRADE.NO_UPGRADE,      4,  \"2E8C4BA2B95B6991:$MushroomClientContext_1\"},\r\n        {\"Mushroom\", RARITY.RARE, UPGRADE.GOLDEN,          8,  \"6E09632F0C956DC8:$MushroomClientContext_2\"},\r\n        {\"Mushroom\", RARITY.RARE, UPGRADE.DIAMOND,         12, \"CB4E4FEC8EF5E4B6:$MushroomClientContext_3\"},\r\n\r\n        {\"Bunny\",    RARITY.EPIC, UPGRADE.NO_UPGRADE,      4,  \"5898683E0D7F13F3:$BunnyClientContext_1\"},\r\n        {\"Bunny\",    RARITY.EPIC, UPGRADE.GOLDEN,          8,  \"7FB6E2346C48F56F:$BunnyClientContext_2\"},\r\n        {\"Bunny\",    RARITY.EPIC, UPGRADE.DIAMOND,         12, \"3BAE097EAFBDE1C1:$BunnyClientContext_3\"},\r\n\r\n        {\"Fairy\",    RARITY.EPIC, UPGRADE.NO_UPGRADE,      4,  \"F2CEAFC73E2982DB:$FairyClientContext_1\"},\r\n        {\"Fairy\",    RARITY.EPIC, UPGRADE.GOLDEN,          8,  \"DC4C8B19BDB624F2:$FairyClientContext_2\"},\r\n        {\"Fairy\",    RARITY.EPIC, UPGRADE.DIAMOND,         12, \"B6EC162A0D0221EA:$FairyClientContext_3\"},\r\n    }\r\n\r\n    EggDb = {\r\n        First =  {gacha = {Bee=50, Gnome=30, Birdie=20},      price = 500},\r\n        Second = {gacha = {Monkey=50, Bull=35, Cat=15},       price = 5000},\r\n        Third =  {gacha = {Bat=60, Ghost=35, Witch=5},        price = 30000},\r\n        Fourth = {gacha = {Flamingo=50, Crab=40, Mermaid=10}, price = 100000},\r\n        Fifth =  {gacha = {Mushroom=60, Bunny=30, Fairy=10},  price = 175000},\r\n    }\r\n    ---------------------------\r\n    -- Pets\r\n    ---------------------------\r\n     function PetDb:GetName(id)\r\n        return self[id][kName]\r\n    end\r\n\r\n    function PetDb:GetMuid(id)\r\n        local rec = self[id]\r\n        return  rec[kMuid]\r\n    end\r\n\r\n    function PetDb:GetBonus(id)\r\n        return self[id][kBonus]\r\n    end\r\n\r\n    function PetDb:GetUpgradeStatus(id)\r\n        local n = self[id][kUpgrade]\r\n        return n, UPGRADE_NAMES[n]\r\n    end\r\n\r\n    function PetDb:GetRarity(id)\r\n        local n = self[id][kRarity]\r\n        return n, RARITY_NAMES[n]\r\n    end\r\n\r\n    function PetDb:CanUpgrade(id1, id2)\r\n        local u1 = self:GetUpgradeStatus(id1)\r\n        local rec = self[id1]\r\n        return u1 ~= UPGRADE.MAX and (not id2 or id1 == id2), rec[kNextUpgradeId] or id1+1\r\n    end\r\n       -- add id by name\r\n       for id=1, #PetDb do\r\n        local pet = PetDb[id]\r\n        if PetDb:GetUpgradeStatus(id) == UPGRADE.NO_UPGRADE then\r\n            PetDb[PetDb:GetName(id)] = id\r\n        end\r\n    end\r\nend\r\n\r\nStaticData.PetDb = PetDb\r\nStaticData.EggDb = EggDb\r\n\r\nreturn StaticData"
      }
    }
    Assets {
      Id: 5305102967692430199
      Name: "Protocols"
      PlatformAssetType: 3
      TextAsset {
        Text: "local Base64 = _G.req(\"_Base64\")\nlocal _pp = _G.req(\"_Luapp\").pp\npp = function(...) warn(\"\\n\".._pp{...}) end\nlocal Protocols = {}\nProtocols.__index = Protocols\n\nlocal spack, sunpack = string.pack, string.unpack\nlocal enc, dec, testOp = Base64.encode, Base64.decode, Base64.test_prefix\n\n\nlocal PROTOCOL_OWNER do\n    local op, fmt = \"$\", \"c1 z c3 c3 c1\"\n    local function pack(player_id, channel, social, nonce)\n        assert(nonce)\n        return enc(spack(fmt, op, player_id, channel, social, nonce))\n    end\n    local function unpack(msg)\n        if msg and type(msg) == \"string\" and #msg > 0 and testOp(msg, op) then\n            local _op, player_id, channel, social, _nonce = sunpack(fmt, dec(msg))\n            return player_id, channel, social\n        end\n    end\n    PROTOCOL_OWNER = {op=op, pack=pack, unpack=unpack}\nend\n\nlocal PROTOCOL_EGG do\n    local op, fmt = \"#\", \"c1 B z B B\"\n    local function pack(pet_id, egg_id, row, col, nonce)\n        assert(nonce, CoreDebug.GetStackTrace())\n        return enc(spack(fmt, op, pet_id, egg_id, row, col, nonce))\n    end\n    local function unpack(msg)\n        if msg and type(msg) == \"string\" and #msg > 0 and testOp(msg, op) then\n            local _op, pet_id, egg_id, row, col, _nonce = sunpack(fmt, dec(msg))\n            return pet_id, egg_id, row, col\n        end\n    end\n    PROTOCOL_EGG = {op=op, pack=pack, unpack=unpack}\nend\n\n-- TODO: rename record to grid or inventory\nlocal PROTOCOL_RECORD do\n    local op = \"@\"\n    local function pack(frags, nonce)\n        assert(nonce)\n        assert(frags[1] == \"\", \"there is no `op` placeholder at [1]\")\n        frags[1] = op\n        frags[#frags + 1] = nonce\n        return enc(table.concat(frags))\n    end\n    local function unpack(msg, deserialize)\n        assert(deserialize and type(deserialize) == \"function\")\n        if msg and #msg > 0 and testOp(msg, op) then\n            local decoded  = dec(msg)\n            -- ajust indices to remove op and nonce\n            local from, to = #op + 1, #decoded - 1\n            local record = deserialize(decoded, from, to)\n            return record\n        end\n    end\n    PROTOCOL_RECORD = {op=op, pack=pack, unpack=unpack}\nend\n\nProtocols.PROTOCOL_RECORD = PROTOCOL_RECORD\nProtocols.PROTOCOL_OWNER = PROTOCOL_OWNER\nProtocols.PROTOCOL_EGG = PROTOCOL_EGG\n\nlocal SOCIAL do\n    local HATCH do\n        local op, event, fmt = \"SH\", \"Social_Hatch\", \"c2 z B c1\"\n        local function pack(player_id, pet_id, nonce)\n            assert(nonce)\n            return enc(spack(fmt, op, player_id, pet_id, nonce))\n        end\n        local function unpack(msg)\n            if msg and type(msg) == \"string\" and #msg > 0 and testOp(msg, op) then\n                local _op, player_id, pet_id, _nonce = sunpack(fmt, dec(msg))\n                return player_id, pet_id\n            end\n        end\n        HATCH = {op=op, event=event, pack=pack, unpack=unpack}\n    end\n\n    local MERGE do\n        local op, event, fmt = \"SM\", \"Social_Merge\", \"c2 z B c1\"\n        local function pack(player_id, pet_id, nonce)\n            assert(nonce)\n            return enc(spack(fmt, op, player_id, pet_id, nonce))\n        end\n        local function unpack(msg)\n            if msg and type(msg) == \"string\" and #msg > 0 and testOp(msg, op) then\n                local _op, player_id, pet_id, _nonce = sunpack(fmt, dec(msg))\n                return player_id, pet_id\n            end\n        end\n        MERGE = {op=op, event=event, pack=pack, unpack=unpack}\n    end\n\n    local REBIRTH do\n        local op, event, fmt = \"SR\", \"Social_Rebirth\", \"c2 z B c1\"\n        local function pack(player_id, nrebirth, nonce)\n            assert(nonce)\n            assert(math.type(nrebirth) == \"integer\")\n            return enc(spack(fmt, op, player_id, nrebirth, nonce))\n        end\n        local function unpack(msg)\n            if msg and type(msg) == \"string\" and #msg > 0 and testOp(msg, op) then\n                local _op, player_id, nrebirth, _nonce = sunpack(fmt, dec(msg))\n                return player_id, nrebirth\n            end\n        end\n        REBIRTH = {op=op, event=event, pack=pack, unpack=unpack}\n    end\n    -- handle protocol\n    local social_protocols = {\n        [HATCH.op] = HATCH,\n        [MERGE.op] = MERGE,\n        [REBIRTH.op] = REBIRTH,\n    }\n    local function handle_data(data)\n        assert(Environment.IsClient())\n        for op, protocol in pairs(social_protocols) do\n            if testOp(data, op) then\n                Events.Broadcast(protocol.event, protocol.unpack(data))\n            end\n        end\n    end\n    SOCIAL = {handle=handle_data, protocols=social_protocols}\n    SOCIAL.HATCH = HATCH\n    SOCIAL.MERGE = MERGE\n    SOCIAL.REBIRTH = REBIRTH\nend\n\nProtocols.SOCIAL = SOCIAL\n\n-- server to client\nProtocols.CLIENT = {\n    GameInventoryRrequest = \"GIR\",\n    GameResetRequest = \"GRR\",\n    TransmitInventoryModifications = \"TIM\",\n    TransmitPetDeletion = \"TPD\", -- TODO: send and handle\n    TransmitHatchingEgg = \"THE\"\n}\n\n-- client only inventory events\nProtocols.INTERACTION = {\n    AttemptDelete = \"Interaction_AttemptDelete\",\n    CameraScrollingBegin=\"Interaction_CameraScrollingBegin\",\n    CameraScrollingEnd = \"Interaction_CameraScrollingEnd\",\n    TileUnderCursorChanged = \"Interaction_TileUnderCursorChanged\",\n    ActorPickUp = \"Interaction_ActorPickUp\"\n}\n\n-- enum\nProtocols.MOVE_OUTCOME = {\n    BASIC = \"Basic\",\n    PUSHOUT = \"Pushout\",\n    SWAP = \"Swap\",\n    MERGE = \"Merge\"\n}\n\n-- internal client events\nProtocols.CLIENT_LOCAL = {\n    EGG_HATCHED = \"Egg_Hatched\",\n    MODAL = \"Interactions_Modal\"\n}\n\nProtocols.C2S = {\n    EQUIPMENT_ON = \"TurnOnEquipment\",\n    EQUIPMENT_OFF = \"TurnOffEquipment\",\n}\n\n\nProtocols.MODAL_ARG = {\n    NO_ARG = 0,\n    YES_ARG = 1,\n    OPEN_ARG = 2,\n}\n\n-- Environment\n-- Time of the day Noon, Dusk, Midnight, Dawn (look DayNightControllerClient)\n\n-- Social\n-- + PetHatch player_id, pet_id\n-- + Rebirth player_id, rebirth\n-- + PetMerge player_id, pet_id\n-- + Connect/Disconnect player_id\n\n-- Client Inventory Presentation\n--  -- \"Game_TileActorModified\"\n--  -- \"Game_MouseHoverTile\"\n--  -- \"Game_MousePickUpActor\"\n--  -- \"Game_MouseClickedActor\"\n--  -- \"Game_MouseDragActorBegin\"\n--  -- \"Game_MouseDragActorHoverTile\"\n--  -- \"Game_MouseDragActorDropOnTile\"\n\n-- Client Presentation\n\n-- Client Requests\n-- GIR Game_InventoryRequest inventory_id\n-- GFR Game_FullResetRequest ()\n-- TIM TransmitInventoryModification\n-- THE TransmitHatchingEgg\n\nreturn Protocols"
      }
    }
    Assets {
      Id: 18342435553950571227
      Name: "BusinessLogic"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[ Game Rules\r\n* Speed Coin (SC) is the currency of the game.\r\n* You can buy eggs for SC. You hatching pets from eggs.\r\n* The more SC you have then faster you are.\r\n* You can rebirth by spending all your SC (but no less then each rebirth price).\r\n* SC is earning by clicking or grabbing bonuses. Earned amount affected by your Speed Coin Per Click (SCPC).\r\n* One click gives you 1 SCPC, bonuses gives you one time X*SCPC (where X is a bonus multiplier).\r\n* Each rebirth gives you + 1 SCPC. Rebirths is a prerequest for new areas and new eggs.\r\n* SCPC = 3(base) + N-rebirth + Sum(equipped pet\'s bonus).\r\n* You can merge 3 equivalent pets to one `upgraded` pet. Now max upgrade is limited to 3-rd.\r\n* You can equip the limited number of pets: 3. You can upgrade this limit to 5.\r\n]]\r\n-- constants\r\nlocal S -- uninitialized static data\r\nlocal BASE_SPEED = 100\r\nlocal MAX_MULTIPLIER = 25\r\nlocal BASE_CPS = 3\r\nlocal FIRST_REBIRTH = 1000\r\nlocal REBIRTH_EXP_RATE = 1.618\r\nlocal COIN_TO_SPEED_RATE = 1.001\r\nlocal COIN_KEY = \"SpeedCoin\"\r\nlocal REBIRTH_KEY = \"Rebirth\"\r\nlocal INVENTORY_KEY = \"Inventory\"\r\nlocal PET_BONUS_KEY = \"PetBonus\" -- not persist\r\n\r\nlocal EQUIPPED_ROW = 0\r\n\r\n_G.req = CoreMath and _G.req or require\r\n\r\nlocal xoshiro256 = _G.req(\"_Xoshiro256\")\r\nlocal Trampoline = _G.req(\"_Trampoline\")\r\nlocal random = xoshiro256.random\r\nlocal randomseed = xoshiro256.randomseed\r\n\r\n--------------------\r\n-- math utils\r\n--------------------\r\n\r\nlocal _tiers = {\"K\", \"M\", \"B\", \"T\", \"Q\"}\r\nlocal function formatNumber(n)\r\n    n = math.tointeger(n) or n//1\r\n    if n < 100000 then return tostring(n) end\r\n    local tier = math.log(n, 10)//3\r\n    n = n / 10^(3*tier)\r\n    return string.format(\"%.4g%s\", n, _tiers[tier])\r\nend\r\n\r\n\r\n-- pythonic uniform\r\nlocal function uniform(a, b)\r\n    assert(a < b, \"empty interval\")\r\n    return a + (b-a)*random()\r\nend\r\n\r\n-- weightedchoice :: {[key, weight]} -> key\r\nlocal function weightedchoice(t)\r\n    local sum = 0\r\n    for _, w in pairs(t) do sum = sum + w end\r\n    local rnd = uniform(0, sum)\r\n    for k, w in pairs(t) do\r\n        rnd = rnd - w\r\n        if rnd < 0 then return k end\r\n    end\r\nend\r\n\r\nlocal function roundToSignificantDigits(d, digits, trancate)\r\n    assert(d >= 0)\r\n    digits = digits or 3\r\n    if d == 0 then return 0 end\r\n    local k = math.floor(math.log(d, 10))\r\n    local scale = 10^(k - digits + 1)\r\n    return scale * math.floor(d/scale + (trancate and 0 or 0.5))\r\nend\r\n\r\nlocal function geomNth(a, f, n, digits)\r\n    return roundToSignificantDigits(a*f^n, digits)\r\nend\r\n\r\nlocal function calculateAfforadableAmount(initial, exp, owned, cash)\r\n    return math.log(1 - cash * (1 - exp) / (initial * exp^owned)) / math.log(exp)\r\nend\r\n\r\n--------------------\r\n-- module\r\n--------------------\r\n\r\nlocal BusinessLogic = {type = \'BusinessLogic\'}\r\nBusinessLogic.__index = BusinessLogic\r\n\r\nfunction BusinessLogic.SetStaticData(data)\r\n    assert(data.EggDb and data.PetDb)\r\n    S = data\r\nend\r\n\r\n--- Returns a new BusinessLogic object\r\n-- @return BusinessLogic\r\nfunction BusinessLogic.New()\r\n    return setmetatable({}, BusinessLogic)\r\nend\r\n\r\nfunction BusinessLogic:IsA(typename)\r\n    return typename == BusinessLogic.type and getmetatable(self) == BusinessLogic\r\nend\r\n\r\nlocal function setSpeed(player, speedcoins)\r\n    speedcoins = speedcoins <= 0 and 1 or speedcoins\r\n    player:SetResource(COIN_KEY, speedcoins)\r\n    player.maxWalkSpeed = BASE_SPEED + calculateAfforadableAmount(1, COIN_TO_SPEED_RATE, 0, speedcoins)//1\r\nend\r\n\r\nlocal function neededForRebirth(rebirth)\r\n    return geomNth(FIRST_REBIRTH, REBIRTH_EXP_RATE, rebirth)\r\nend\r\n\r\n--------------------\r\n-- Rebirth\r\n--------------------\r\n--[[ DEBUG: prints rebirth table to events log\r\nprint(\"INFO: rebirth table:\")\r\nfor i=0, 35 do\r\n    print(\"  rebirth\", i + 1, \"needs:\", formatNumber(neededForRebirth(i)))\r\nend\r\n--]]\r\n\r\nlocal function isRebirthPossible(player)\r\n    local rebirth = player:GetResource(REBIRTH_KEY) or 0\r\n    local coins = player:GetResource(COIN_KEY) or 1\r\n    local needed = neededForRebirth(rebirth)\r\n    return  coins >= needed, needed, coins, rebirth\r\nend\r\n\r\nlocal function doRebirth(player)\r\n    assert(Environment.IsServer())\r\n    local ok, needed, has, rebirth = isRebirthPossible(player)\r\n    if ok then\r\n        player:SetResource(REBIRTH_KEY, rebirth + 1)\r\n        setSpeed(player, 0)\r\n        return true, rebirth + 1\r\n    end\r\n    return false, needed, has, rebirth\r\nend\r\n\r\nlocal function addCoins(player, multiplier)\r\n    assert(Environment.IsServer())\r\n    assert(player and player:IsA(\'Player\'))\r\n    assert(type(multiplier) == \'number\' and multiplier >= 1 and multiplier <= MAX_MULTIPLIER)\r\n    local petsBonus = player:GetResource(PET_BONUS_KEY) or 0\r\n    local rebirth = player:GetResource(REBIRTH_KEY) or 0\r\n    local n =  (BASE_CPS + rebirth + petsBonus) * multiplier\r\n    local coins = n + (player:GetResource(COIN_KEY) or 1)\r\n    setSpeed(player, coins)\r\n    -- DEBUG:\r\n    print(string.format(\"%s %d %d %d\", player.name, n//1, coins//1, player.maxWalkSpeed//1))\r\nend\r\n\r\nlocal function subtractCoins(player, price)\r\n    assert(price >= 0)\r\n    assert(Environment.IsServer())\r\n    assert(player and player:IsA(\'Player\'))\r\n    local coins = player:GetResource(COIN_KEY) or 1\r\n    if price <= coins then\r\n       coins = coins - price\r\n       setSpeed(player, coins)\r\n       return true\r\n    else\r\n        return false, \"Insufficient Speed\"\r\n    end\r\n    -- DEBUG:\r\n    print(string.format(\"%s %d %d\", player.name, coins//1, player.maxWalkSpeed//1))\r\nend\r\n\r\nlocal function onClick(ability)\r\n    if ability and ability.owner then\r\n        addCoins(ability.owner, 1)\r\n    end\r\nend\r\n\r\nfunction BusinessLogic.LoadSave(player)\r\n    assert(Environment.IsServer())\r\n    local data = Storage.GetPlayerData(player)\r\n    -- rebirth\r\n    data[REBIRTH_KEY] = data[REBIRTH_KEY] or 0\r\n    player:SetResource(REBIRTH_KEY, data[REBIRTH_KEY])\r\n    -- speedcoins\r\n    data[COIN_KEY] = data[COIN_KEY] or 1\r\n    player:SetResource(COIN_KEY, data[COIN_KEY])\r\n    setSpeed(player, data[COIN_KEY])\r\n    return data\r\nend\r\n\r\nfunction BusinessLogic.LoadKey(player, key)\r\n    assert(key == COIN_KEY or key == REBIRTH_KEY or key == INVENTORY_KEY or key == PET_BONUS_KEY)\r\n    local data = Storage.GetPlayerData(player)\r\n    return data[key]\r\nend\r\n\r\nlocal _retry_save = Trampoline.New(function(args)\r\n    return Storage.SetPlayerData(table.unpack(args))\r\n end)\r\n\r\nfunction BusinessLogic.SaveKey(player, key, datum)\r\n    assert(key == COIN_KEY or key == REBIRTH_KEY or key == INVENTORY_KEY or key == PET_BONUS_KEY, CoreDebug.GetStackTrace())\r\n    -- PET_BONUS_KEY is trancient, don\'t save it\r\n    if key == PET_BONUS_KEY then return end\r\n    local data = Storage.GetPlayerData(player)\r\n    data[key] = datum\r\n    local ok, message = Storage.SetPlayerData(player, data)\r\n    if not ok then\r\n       warn(message)\r\n       -- TODO: test retry save\r\n       _retry_save({player, data})\r\n    end\r\nend\r\n\r\nfunction BusinessLogic.PurchaseEgg(player, egg_name, grid)\r\n    assert(Environment.IsServer())\r\n    assert(grid and grid.type == \"Grid\")\r\n    local egg = S.EggDb[egg_name]\r\n    local price = egg.price\r\n    local free_cell = grid:Search(function(cell)\r\n        return cell:IsFree() and cell.row ~ EQUIPPED_ROW\r\n    end)\r\n    if not free_cell then\r\n        return false, \"No free inventory space\"\r\n    end\r\n    local ok, msg = subtractCoins(player, price)\r\n    if ok then\r\n        local gacha = egg.gacha\r\n        local pet_name = weightedchoice(gacha)\r\n        local pet_id = S.PetDb[pet_name]\r\n        return true, pet_id, free_cell\r\n    else\r\n        return false, msg\r\n    end\r\nend\r\n\r\nfunction BusinessLogic.RecalculatePetBonus(player, grid)\r\n    assert(Environment.IsServer())\r\n    assert(grid and grid.type == \"Grid\")\r\n    local function sum_bonuses(seed, cell)\r\n        local row, _, id = cell:Unpack()\r\n        return seed + (id and row == EQUIPPED_ROW and S.PetDb:GetBonus(id) or 0)\r\n    end\r\n    local bonus = grid:Fold(sum_bonuses, 0)\r\n    player:SetResource(PET_BONUS_KEY, bonus)\r\n    return bonus\r\nend\r\n\r\nfunction BusinessLogic.ResetGame(player)\r\n    assert(Environment.IsServer())\r\n    local data = {}\r\n    data[REBIRTH_KEY] = 0\r\n    player:SetResource(REBIRTH_KEY, data[REBIRTH_KEY])\r\n    data[COIN_KEY] = 1\r\n    player:SetResource(COIN_KEY, data[COIN_KEY])\r\n    setSpeed(player, data[COIN_KEY])\r\n    local ok, message = Storage.SetPlayerData(player, data)\r\n    if not ok then\r\n       warn(message)\r\n       _retry_save({player, data})\r\n    end\r\nend\r\n\r\n-- exports\r\nBusinessLogic.formatNumber = formatNumber\r\nBusinessLogic.onClick = onClick\r\nBusinessLogic.addCoins = addCoins\r\nBusinessLogic.isRebirthPossible = isRebirthPossible\r\nBusinessLogic.doRebirth = doRebirth\r\nBusinessLogic.COIN_KEY = COIN_KEY\r\nBusinessLogic.REBIRTH_KEY = REBIRTH_KEY\r\nBusinessLogic.INVENTORY_KEY = INVENTORY_KEY\r\nBusinessLogic.PET_BONUS_KEY = PET_BONUS_KEY\r\n-- for resource display\r\nBusinessLogic.max = neededForRebirth\r\nBusinessLogic.MAX_KEY = REBIRTH_KEY\r\n\r\nlocal function _test()\r\n    local t = {A=1, B=2, C=3}\r\n    local out = {A=0, B=0, C=0}\r\n    local N = 1000\r\n    for _ = 1, N do\r\n        local k = weightedchoice(t)\r\n        out[k] = out[k] + 1\r\n    end\r\n    for k, v in pairs(out) do\r\n        out[k] = v/N\r\n        print(k, out[k])\r\n    end\r\nend\r\n-- _test()\r\n\r\nreturn BusinessLogic\r\n\r\n\r\n"
      }
    }
    Assets {
      Id: 9765507830262698727
      Name: "_Xoshiro256"
      PlatformAssetType: 3
      TextAsset {
        Text: "-- Copyright (C) 1994-2020 Lua.org, PUC-Rio.\n-- Copyright (C) 2021 by Andrew Zhilin <andrew.zhilin@gmail.com>\n-- Distributed under MIT license.\n--[===========================================================================[\n    `Xoshiro256` is a pure lua 5.3 implementation of xoshiro256**\n    algorithm, that is fully compatible with lua 5.4 API and implementation of\n    `math.random` and `math.randomseed`. It has a reasonable performance and\n    passes all random related tests from lua 5.4 test suite.\n\n    * xoshiro256.random([m[, n]]\n    When called without arguments, returns a pseudo-random float with uniform\n    distribution in the range [0,1). When called with two integers m and n,\n    xoshiro256.random returns a pseudo-random integer with uniform\n    distribution in the range [m, n]. The call xoshiro256.random(n),\n    for a positive n, is equivalent to xoshiro256.random(1,n). The call\n    math.random(0) produces an integer with all bits (pseudo)random.\n    This function uses the xoshiro256** algorithm to produce pseudo-random\n    64-bit integers, which are the results of calls with argument 0. Other\n    results (ranges and floats) are unbiased extracted from these integers.\n\n    * xoshiro256.randomseed([x[, y]])\n    When called with at least one argument, the integer parameters x and y\n    are joined into a 128-bit seed that is used to reinitialize the\n    pseudo-random generator; equal seeds produce equal sequences of numbers.\n    The default for y is zero.\n    When called with no arguments, generates a seed with a weak attempt for\n    randomness.\n    This function returns the two seed components that were effectively used,\n    so that setting them again repeats the sequence.\n    To ensure a required level of randomness to the initial state (or\n    contrarily, to have a deterministic sequence, for instance when debugging\n    a program), you should call xoshiro256.randomseed with explicit\n    arguments.\n--]===========================================================================]\nassert(_VERSION:find(\"Lua 5.3\"))\nlocal xoshiro256 = {}\ndo\n    local select, ult = select, math.ult\n    local DBL_CONV_MULT = 1/2^53 -- http://prng.di.unimi.it/\n    local s0, s1, s2, s3 = 0x00, 0x00, 0x00, 0x00\n    local function next_rand()\n        local x, k = s1*5, 7\n        local result = (x << k | x >> (64 - k))*9\n        local t = s1 << 17\n        s2 = s2 ~ s0\n        s3 = s3 ~ s1\n        s1 = s1 ~ s2\n        s0 = s0 ~ s3\n        s2 = s2 ~ t\n        x, k = s3, 45\n        s3 = x << k | x >> (64 - k)\n        return result\n    end\n\n    local function randomseed(n1, n2)\n        n1 = n1 or os.time()\n        n2 = n2 or 0\n        s0, s1, s2, s3 = n1, 0xFF --[[to avoid a zero state]], n2, 0x00\n        for _=1, 16 do\n            next_rand() -- discard initial values to \"spread\" seed\n        end\n        return n1, n2\n    end\n\n    randomseed() -- initial seeding\n\n    -- Project the random integer \'ran\' into the interval [0, n].\n    -- Because \'ran\' has 2^B possible values, the projection can only be\n    -- uniform when the size of the interval is a power of 2 (exact\n    -- division). Otherwise, to get a uniform projection into [0, n], we\n    -- first compute \'lim\', the smallest Mersenne number not smaller than\n    -- \'n\'. We then project \'ran\' into the interval [0, lim].  If the result\n    -- is inside [0, n], we are done. Otherwise, we try with another \'ran\',\n    -- until we have a result inside the interval.\n    local function project(ran, n)\n        if n & (n + 1) == 0 then -- is \'n + 1\' a power of 2?\n            return ran & n -- no bias\n        else\n            -- compute the smallest (2^b - 1) not smaller than \'n\'\n            local lim = n\n            lim = lim | lim >> 1\n            lim = lim | lim >> 2\n            lim = lim | lim >> 4\n            lim = lim | lim >> 8\n            lim = lim | lim >> 16\n            lim = lim | lim >> 32\n            -- commented out for performance:\n            -- assert(lim & (lim + 1) == 0)\n            -- assert(lim >= n)\n            -- assert(ult(lim >> 1, n))\n            while true do\n                ran = ran & lim -- project \'ran\' into [0..lim]\n                if ult(n, ran) then -- not inside [0..n]? try again\n                    ran = next_rand()\n                else\n                    break\n                end\n            end\n            return ran\n        end\n    end\n\n    local function random(low, up, ...)\n        assert(select(\"#\", ...) == 0, \"too many arguments\")\n        local rv = next_rand()\n        local nargs = (low and up and 2) or (low and not up and 1) or 0\n        if nargs == 0 then\n            return (rv >> 11) * DBL_CONV_MULT -- converts uint64 to double at [0, 1)\n        elseif nargs == 1 then\n            up, low = low, 1 -- only upper limit\n            if up == 0 then return rv end\n        end\n        -- project rv into the interval [low, up]\n        assert(low <= up, \"interval is empty\")\n        local p = project(rv, up - low)\n        return p + low\n     end\n    -- exports\n    xoshiro256.random = random\n    xoshiro256.randomseed = randomseed\nend\n\nlocal function _test()\n    local random, max, min = xoshiro256.random, math.max, math.min\n    -- all `random` tests from lua-5.4.2-tests/math.lua\n    local minint = math.mininteger\n    local maxint = math.maxinteger\n    local intbits = math.floor(math.log(maxint, 2) + 0.5) + 1\n    assert((1 << intbits) == 0)\n\n    assert(minint == 1 << (intbits - 1))\n    assert(maxint == minint - 1)\n\n    -- number of bits in the mantissa of a floating-point number\n    local floatbits = 24\n    do\n        local p = 2.0^floatbits\n        while p < p + 1.0 do\n            p = p * 2.0\n            floatbits = floatbits + 1\n        end\n    end\n\n    -- NOTE: we cut some corners assuming standard lua 5.3 64-bit runtime and IEEE 754 64-bit doubles\n    assert(floatbits == 53)\n    assert(intbits == 64)\n\n    local function isNaN (x)\n        return (x ~= x)\n    end\n\n    assert(isNaN(0/0))\n    assert(not isNaN(1/0))\n\n    do\n        local x = 2.0^floatbits\n        assert(x > x - 1.0 and x == x + 1.0)\n        print(string.format(\"* %d-bit integers, %d-bit (mantissa) floats\",\n                             intbits, floatbits))\n    end\n    assert(math.type(0) == \"integer\" and math.type(0.0) == \"float\"\n        and not math.type(\"10\"))\n\n\n    -- float equality\n    local function eq(a,b,limit)\n        if not limit then\n            if floatbits >= 50 then limit = 1E-11\n            else limit = 1E-5\n            end\n        end\n        -- a == b needed for +inf/-inf\n        return a == b or math.abs(a-b) <= limit\n    end\n\n    local function testnear (val, ref, tol)\n        return (math.abs(val - ref) < ref * tol)\n    end\n\n    -- low-level!! For the current implementation of random in Lua,\n    -- the first call after seed 1007 should return 0x7a7040a5a323c9d6\n\n    -- all computations should work with 32-bit integers\n    do\n        local h = 0x7a7040a5   -- higher half\n        local l = 0xa323c9d6   -- lower half\n        xoshiro256.randomseed(1007)\n        -- get the low \'intbits\' of the 64-bit expected result\n        local res = (h << 32 | l) & ~(~0 << intbits)\n        assert(random(0) == res)\n        xoshiro256.randomseed(1007, 0)\n        -- using higher bits to generate random floats; (the \'% 2^32\' converts\n        -- 32-bit integers to floats as unsigned)\n        local res\n        if floatbits <= 32 then\n            -- get all bits from the higher half\n            res = (h >> (32 - floatbits)) % 2^32\n        else\n            -- get 32 bits from the higher half and the rest from the lower half\n            res = (h % 2^32) * 2^(floatbits - 32) + ((l >> (64 - floatbits)) % 2^32)\n        end\n        local rand = random()\n        -- NOTE: there is no hexadecimal floating-point literals until lua 5.4, but tonumber works!\n        assert(eq(rand, tonumber[[0x0.7a7040a5a323c9d6]], 2^-floatbits))\n        assert(rand * 2^floatbits == res)\n    end\n\n    do\n        -- testing return of \'randomseed\'\n        local x, y = xoshiro256.randomseed()\n        local res = xoshiro256.random(0)\n        x, y = xoshiro256.randomseed(x, y)    -- should repeat the state\n        assert(xoshiro256.random(0) == res)\n        xoshiro256.randomseed(x, y)    -- again should repeat the state\n        assert(xoshiro256.random(0) == res)\n        -- keep the random seed for following tests\n    end\n\n    do   -- test random for floats\n        local randbits = math.min(floatbits, 64)   -- at most 64 random bits\n        local mult = 2^randbits      -- to make random float into an integral\n        local counts = {}    -- counts for bits\n        for i = 1, randbits do counts[i] = 0 end\n        local up = -math.huge\n        local low = math.huge\n        local rounds = 100 * randbits   -- 100 times for each bit\n        local totalrounds = 0\n        ::doagain::   -- will repeat test until we get good statistics\n        for i = 0, rounds do\n            local t = random()\n            assert(0 <= t and t < 1)\n            up = max(up, t)\n            low = min(low, t)\n            assert(t * mult % 1 == 0)    -- no extra bits\n            local bit = i % randbits     -- bit to be tested\n            if (t * 2^bit) % 1 >= 0.5 then    -- is bit set?\n                counts[bit + 1] = counts[bit + 1] + 1   -- increment its count\n            end\n        end\n        totalrounds = totalrounds + rounds\n        if not (eq(up, 1, 0.001) and eq(low, 0, 0.001)) then\n            goto doagain\n        end\n        -- all bit counts should be near 50%\n        local expected = (totalrounds / randbits / 2)\n        for i = 1, randbits do\n            if not testnear(counts[i], expected, 0.10) then\n                goto doagain\n            end\n        end\n        print(string.format(\"float random range in %d calls: [%f, %f]\",\n                            totalrounds, low, up))\n    end\n\n    do   -- test random for full integers\n        local up = 0\n        local low = 0\n        local counts = {}    -- counts for bits\n        for i = 1, intbits do counts[i] = 0 end\n        local rounds = 100 * intbits   -- 100 times for each bit\n        local totalrounds = 0\n        ::doagain::   -- will repeat test until we get good statistics\n        for i = 0, rounds do\n            local t = random(0)\n            up = max(up, t)\n            low = min(low, t)\n            local bit = i % intbits     -- bit to be tested\n            -- increment its count if it is set\n            counts[bit + 1] = counts[bit + 1] + ((t >> bit) & 1)\n        end\n        totalrounds = totalrounds + rounds\n        local lim = maxint >> 10\n        if not (maxint - up < lim and low - minint < lim) then\n            goto doagain\n        end\n        -- all bit counts should be near 50%\n        local expected = (totalrounds / intbits / 2)\n        for i = 1, intbits do\n            if not testnear(counts[i], expected, 0.10) then\n                goto doagain\n            end\n        end\n        print(string.format(\n           \"integer random range in %d calls: [minint + %.0fppm, maxint - %.0fppm]\",\n            totalrounds, (minint - low) / minint * 1e6,\n                         (maxint - up) / maxint * 1e6))\n    end\n\n    do\n        -- test distribution for a dice\n        local count = {0, 0, 0, 0, 0, 0}\n        local rep = 200\n        local totalrep = 0\n        ::doagain::\n        for i = 1, rep * 6 do\n            local r = random(6)\n            count[r] = count[r] + 1\n        end\n        totalrep = totalrep + rep\n        for i = 1, 6 do\n            if not testnear(count[i], totalrep, 0.05) then\n                goto doagain\n            end\n        end\n    end\n\n    do\n        local function aux (x1, x2)     -- test random for small intervals\n        local mark = {}; local count = 0   -- to check that all values appeared\n        while true do\n            local t = random(x1, x2)\n            assert(x1 <= t and t <= x2)\n            if not mark[t] then  -- new value\n                mark[t] = true\n                count = count + 1\n                if count == x2 - x1 + 1 then   -- all values appeared; OK\n                    goto ok\n                end\n            end\n        end\n        ::ok::\n        end\n\n        aux(-10,0)\n        aux(1, 6)\n        aux(1, 2)\n        aux(1, 13)\n        aux(1, 31)\n        aux(1, 32)\n        aux(1, 33)\n        aux(-10, 10)\n        aux(-10,-10)   -- unit set\n        aux(minint, minint)   -- unit set\n        aux(maxint, maxint)   -- unit set\n        aux(minint, minint + 9)\n        aux(maxint - 3, maxint)\n    end\n\n    do\n        local function aux(p1, p2)       -- test random for large intervals\n            local max = minint\n            local min = maxint\n            local n = 100\n            local mark = {}; local count = 0   -- to count how many different values\n            ::doagain::\n        for _ = 1, n do\n            local t = random(p1, p2)\n            if not mark[t] then  -- new value\n                assert(p1 <= t and t <= p2)\n                max = math.max(max, t)\n                min = math.min(min, t)\n                mark[t] = true\n                count = count + 1\n            end\n        end\n            -- at least 80% of values are different\n            if not (count >= n * 0.8) then\n            goto doagain\n            end\n            -- min and max not too far from formal min and max\n            local diff = (p2 - p1) >> 4\n            if not (min < p1 + diff and max > p2 - diff) then\n            goto doagain\n            end\n        end\n        aux(0, maxint)\n        aux(1, maxint)\n        aux(3, maxint // 3)\n        aux(minint, -1)\n        aux(minint // 2, maxint // 2)\n        aux(minint, maxint)\n        aux(minint + 1, maxint)\n        -- aux(minint, maxint - 1)\n        aux(0, 1 << (intbits - 5))\n    end\n\n    assert(not pcall(random, 1, 2, 3))    -- too many arguments\n    -- empty interval\n    assert(not pcall(random, minint + 1, minint))\n    assert(not pcall(random, maxint, maxint - 1))\n    assert(not pcall(random, maxint, minint))\n\n    print(\"xoshiro256 -- ok\")\nend\n\n\nlocal CORE_ENV = CoreString and CoreMath\n\nlocal function _test_perf()\n    ---[[\n        _G.req = _G.req or require\n        local perfn = _G.req(\"_Snippets\").perfn\n        local N = CORE_ENV and 1000 or 1000000\n        perfn(\"math ints\", N, function()\n            math.random(12345, 1234567890)\n        end)\n        perfn(\"xoroshiro ints\", N, function()\n            xoshiro256.random(123451, 1234567890)\n        end)\n        perfn(\"math double\", N, function()\n            math.random()\n        end)\n        perfn(\"xoroshiro double\", N, function()\n            xoshiro256.random()\n        end)\n    --]]\nend\n\nif not CORE_ENV then -- Core has too low instruction limit\n    _test()\nend\n\n-- _test_perf()\n\nreturn xoshiro256\n"
      }
    }
    Assets {
      Id: 3973205370573435669
      Name: "_Trampoline"
      PlatformAssetType: 3
      TextAsset {
        Text: "local Trampoline = {}\nTrampoline.__index = Trampoline\n\nfunction Trampoline.New(func, interval)\n    interval = interval or 0\n    return setmetatable({\n        _first=0,\n        _last=-1,\n        _func = func,\n        _task = nil,\n        _last_tx = 0,\n        _interval=interval}, Trampoline)\nend\n\nfunction Trampoline:_empty()\n    return self._first > self._last\nend\n\nfunction Trampoline:_push(arg)\n    self._last = self._last + 1\n    self[self._last] = arg\nend\n\nfunction Trampoline:_pop()\n    local first = self._first\n    local arg = self[first]\n    self[first] = nil\n    self._first = first + 1\n    return arg\nend\n\nfunction Trampoline:__call(arg)\n    local tx_allowed = time() - self._last_tx > self._interval\n    local in_trampoline = not self:_empty()\n    if tx_allowed then\n        self._last_tx = time()\n        local ok = self._func(arg)\n        if not ok then\n            self:_push(arg)\n        end\n    else\n        self:_push(arg)\n    end\n    if not self:_empty() and not in_trampoline then\n        self.task = Task.Spawn(function()\n            -- warn(\"trampoline START\")\n            while not self:_empty() do\n                local parg = self:_pop()\n                local ok, msg = self._func(parg)\n                if ok then\n                    self._last_tx = time()\n                    Task.Wait(self._interval)\n                else\n                    if msg then warn(\"[Trampoline] \" .. msg) end\n                    self:_push(parg)\n                    Task.Wait()\n                end\n            end\n            --warn(\"trampoline END\")\n            self._task = nil\n        end, self._interval - (time() - self._last_tx))\n    end\nend\n\nfunction Trampoline:Destroy()\n    if self.task then self.task:Cancel() end\n    for i = self.first, self.last do self[i] = nil end\nend\n\nreturn Trampoline"
      }
    }
    Assets {
      Id: 7243897883920053925
      Name: "_Luapp"
      PlatformAssetType: 3
      TextAsset {
        Text: "--------------------------------------------------------------------------\n--  An attempt to write robust pretty-printer for lua structures.\n--\n--  @author: andrew_zhilin@yahoo.com\n--  @Copyright (C) 2008-2021 by zOOn\n--  https://github.com/zoon/luapp\n--------------------------------------------------------------------------\n-- compiled from hlua, unreadable ^_^\nlocal RESPECT_TOSTRING_MT = true -- hacky for lua 5.2+\nlocal format, gsub = string.format, string.gsub\nlocal function errfmt(argn,varargs,...)\n  local MAX_TAB = 5\n  local args = {...}\n  local argslen = select(\"#\", ...)\n  argslen = (argn and argn>argslen) and argn or argslen\n  local function get_type(_u0)\n    if type(_u0) == \'table\' or type(_u0) == \'userdata\' then\n      local mt = getmetatable(_u0)\n      if mt and mt.type and type(mt.type) == \'function\' then\n        return _u0:type()\n      else return type(_u0)\n      end\n    else return type(_u0)\n    end\n  end\n  local function atom(x)\n    if type(x) == \'string\' then return format(\'%q:%s\',x,\'string\')\n    else return format(\'%s:%s\',tostring(x),get_type(x))\n    end\n  end\n  local function key(x)\n    if type(x) == \'number\' then return \"\"\n    else return \'[\'..atom(x) ..\']=\'\n    end\n  end\n  local function one_arg(i,x)\n    local what = \'arg#\'..i ..\":\\t\"\n    if type(x) == \'table\' then\n      local n = 0\n      what = what ..\'{\'\n      for k,v in pairs(x) do\n        what = what ..(key(k) ..atom(v) ..\',\')\n        n = n+1\n        if n == MAX_TAB then what = what ..\" ...\" break end\n      end\n      what = what ..\'}:\'..get_type(x)\n    else what = what ..atom(x)\n    end\n    what = what ..\'\\n\'\n    return what\n  end\n  local res = \'pattern-match error:\\n\'\n  if varargs ~= false then\n    res = res ..\'varargs possible after arg#\'..argn ..\'.\\n\'\n  end\n  if argn ~= 0 then\n    res = res ..argn ..\' args were expected, in fact we got:\\n\'\n  end\n  for i=1,argslen do res = res ..one_arg(i,args[i]) end\n  if debug and type(debug) == \'table\' then\n    return res ..(gsub(debug.traceback\"\",\'\\t\',\'\')) ..\'\\n\'\n  else return res\n  end\nend\n\n-- zpp\nlocal error = error\nlocal tostring = tostring\nlocal rep = string.rep\nlocal min,max = math.min,math.max\nlocal type = type\nlocal spaces = function(_u53) return rep(\" \",_u53) end\nlocal compose = function(f,g)\n  return function(x) return f(g(x)) end\nend\nlocal identity = function(...) return ... end\nlocal function i2list(_u54)\n  local res = \'<#null>\'\n  for i=#_u54,1,-1 do res = {_u54[i];res}; end\n  return res\nend\nlocal function foldl(_u55,_u56,_u57)\n  if \'<#null>\' == _u57 then return _u56\n  else\n    if type(_u57) == \'table\' and #_u57 == 2 then\n      return foldl(_u55,_u55(_u56,_u57[1]),_u57[2])\n    else error(errfmt(3,false,_u55,_u56,_u57))\n    end\n  end\nend\nlocal Doc_mt = {}\nDoc_mt.__index = Doc_mt\nlocal function Doc(_u58)\n  if type(_u58) == \'table\' and (#_u58 == 2 and\n     _u58.tag ~= nil and (_u58.tag == \'Cat\' or\n     _u58.tag == \'Nest\') or #_u58 == 1 and _u58.tag ~= nil and\n     (_u58.tag == \'Text\' or _u58.tag == \'Break\' or\n     _u58.tag == \'Group\' or _u58.tag == \'Column\' or\n     _u58.tag == \'Nesting\') or #_u58 == 0 and _u58.tag ~= nil and\n     _u58.tag == \'Empty\')\n  then\n    return setmetatable(_u58,Doc_mt)\n  else error(errfmt(1,false,_u58))\n  end\nend\nlocal Empty = Doc{tag=\'Empty\'}\nlocal isDoc = function(_u59)\n  if type(_u59) == \'table\' then\n    return getmetatable(_u59) == Doc_mt\n  else return false\n  end\nend\nlocal empty = Empty\nlocal text = function(_u60)\n  return Doc{tag=\'Text\';tostring(_u60)}\nend\nlocal nest = function(_u61,_u62)\n  if type(_u61) == \'number\' and isDoc(_u62) then\n    return Doc{tag=\'Nest\';_u61;_u62}\n  else error(errfmt(2,false,_u61,_u62))\n  end\nend\nlocal group = function(_u63)\n  if isDoc(_u63) then return Doc{tag=\'Group\';_u63}\n  else error(errfmt(1,false,_u63))\n  end\nend\nlocal column = function(_u64)\n  if type(_u64) == \'function\' then return Doc{tag=\'Column\';_u64}\n  else error(errfmt(1,false,_u64))\n  end\nend\nlocal nesting = function(_u65)\n  if type(_u65) == \'function\' then\n    return Doc{tag=\'Nesting\';_u65}\n  else error(errfmt(1,false,_u65))\n  end\nend\nlocal line = Doc{tag=\'Break\';\" \"}\nlocal linebreak = Doc{tag=\'Break\';\"\"}\nlocal space = text\" \"\nlocal softline = group(line)\nlocal softbreak = group(linebreak)\nlocal function cat(_u66,_u67)\n  if _u66 == Empty then\n    if isDoc(_u67) then return _u67\n    else\n      if isDoc(_u66) and _u67 == Empty then return _u66\n      else error(errfmt(2,false,_u66,_u67))\n      end\n    end\n  else\n    if isDoc(_u66) then\n      if _u67 == Empty then return _u66\n      else\n        if isDoc(_u67) then return Doc{tag=\'Cat\';_u66;_u67}\n        else error(errfmt(2,false,_u66,_u67))\n        end\n      end\n    else error(errfmt(2,false,_u66,_u67))\n    end\n  end\nend\nlocal function catspace(_u68,_u69)\n  return cat(_u68,(cat(space,_u69)))\nend\nlocal function above(_u70,_u71)\n  return cat(_u70,(cat(linebreak,_u71)))\nend\nlocal function abovespace(_u72,_u73)\n  return cat(_u72,(cat(line,_u73)))\nend\nlocal function abovesoft(_u74,_u75)\n  return cat(_u74,(cat(softbreak,_u75)))\nend\nlocal function abovesoftspace(_u76,_u77)\n  return cat(_u76,(cat(softline,_u77)))\nend\nlocal function foldDoc(_u79,_u80)\n  if type(_u79) == \'function\' and isDoc(_u80) then\n    return function(_u78)\n      if type(_u78) == \'table\' and #_u78 == 2 or \'<#null>\' == _u78\n      then\n        return foldl(_u79,_u80,_u78)\n      else error(errfmt(1,false,_u78))\n      end\n    end\n  else error(errfmt(2,false,_u79,_u80))\n  end\nend\nlocal function separateWith(_u84,_u85)\n  if isDoc(_u84) and type(_u85) == \'function\' then\n    return function(_u83)\n      if \'<#null>\' == _u83 then return empty\n      else\n        if type(_u83) == \'table\' and #_u83 == 2 then\n          if \'<#null>\' == _u83[2] then return _u85(_u83[1])\n          else\n            return foldDoc(function(_u81,_u82)\n                            return cat(_u81,(cat(_u85(_u82),_u84)))\n                          end\n                          ,_u85(_u83[1]))(_u83[2])\n          end\n        else error(errfmt(1,false,_u83))\n        end\n      end\n    end\n  else error(errfmt(2,false,_u84,_u85))\n  end\nend\nlocal function ifoldDoc(_u87)\n  if type(_u87) == \'function\' then\n    return function(_u86)\n      if type(_u86) == \'table\' then\n        if #_u86 == 0 then return empty\n        else\n          if #_u86 == 1 then return _u86[1]\n          else\n            if #_u86 >= 1 then\n              local seed = _u86[1]\n              for i=2,#_u86 do seed = _u87(seed,_u86[i]); end\n              return seed\n            else error(errfmt(1,false,_u86))\n            end\n          end\n        end\n      else error(errfmt(1,false,_u86))\n      end\n    end\n  else error(errfmt(1,false,_u87))\n  end\nend\nlocal function iseparateWith(_u89,_u90)\n  if isDoc(_u89) and type(_u90) == \'function\' then\n    return function(_u88)\n      if type(_u88) == \'table\' then\n        if #_u88 == 0 then return empty\n        else\n          if #_u88 == 1 then return _u90(_u88[1])\n          else\n            local seed = empty\n            for i=1,(#_u88-1) do\n              seed = cat(seed,(cat(_u90(_u88[i]),_u89)))\n            end\n            return cat(seed,_u90(_u88[#_u88]))\n          end\n        end\n      else error(errfmt(1,false,_u88))\n      end\n    end\n  else error(errfmt(2,false,_u89,_u90))\n  end\nend\nlocal align = function(doc)\n  return column(function(k)\n    return nesting(function(i) return nest(k-i,doc) end)\n  end)\nend\nlocal hang = function(i,doc) return align(nest(i,doc)) end\nlocal indent = function(i,doc)\n  return hang(i,cat(text(spaces(i)),doc))\nend\nlocal width = function(_u91,_u92)\n  if isDoc(_u91) and type(_u92) == \'function\' then\n    return column(function(k1)\n      return cat(_u91,column(function(k2) return _u92(k2-k1) end))\n    end)\n  else error(errfmt(2,false,_u91,_u92))\n  end\nend\nlocal fillBreak = function(_u94,_u95)\n  if type(_u94) == \'number\' and isDoc(_u95) then\n    return width(_u95\n                ,function(_u93)\n                  if _u93>_u94 then return nest(_u94,linebreak)\n                  else return text(spaces(_u94-_u93))\n                  end\n                end)\n  else error(errfmt(2,false,_u94,_u95))\n  end\nend\nlocal fill = function(_u97,_u98)\n  if type(_u97) == \'number\' and isDoc(_u98) then\n    return width(_u98\n                ,function(_u96)\n                  if _u96 >= _u97 then return empty\n                  else return text(spaces(_u97-_u96))\n                  end\n                end)\n  else error(errfmt(2,false,_u97,_u98))\n  end\nend\nlocal FL,BR = {\'Flat\'},{\'Break\'}\nlocal function layout(_u110,_u111,_u112)\n  if isDoc(_u110) then\n    _u111 = _u111 or 160\n    _u112 = _u112 or 0.8\n    local ribbon = max(min((_u111*_u112),_u111),0)\n    local function fits(_u99,_u100,_u101)\n      if _u99<0 then return false\n      else\n        if \'<#null>\' == _u101 then return true\n        else\n          if type(_u101) == \'table\' and #_u101 == 2 and\n             type(_u101[1]) == \'table\' and #_u101[1] == 3\n          then\n            if _u101[1][3] == Empty then return fits(_u99,_u100,_u101[2])\n            else\n              if type(_u101[1][3]) == \'table\' then\n                if #_u101[1][3] == 2 then\n                  if _u101[1][3].tag ~= nil then\n                    if _u101[1][3].tag == \'Cat\' then\n                      return fits(_u99\n                                 ,_u100\n                                 ,{{_u101[1][1];_u101[1][2];_u101[1][3][1]}\n                                  ;{{_u101[1][1];_u101[1][2];_u101[1][3][2]}\n                                   ;_u101[2]}})\n                    else\n                      if _u101[1][3].tag == \'Nest\' then\n                        return fits(_u99\n                                   ,_u100\n                                   ,{{_u101[1][1]+_u101[1][3][1]\n                                     ;_u101[1][2]\n                                     ;_u101[1][3][2]}\n                                    ;_u101[2]})\n                      else return error(tostring(_u101))\n                      end\n                    end\n                  else return error(tostring(_u101))\n                  end\n                else\n                  if #_u101[1][3] == 1 and _u101[1][3].tag ~= nil then\n                    if _u101[1][3].tag == \'Text\' then\n                      return fits(_u99-#_u101[1][3][1]\n                                 ,_u100+#_u101[1][3][1]\n                                 ,_u101[2])\n                    else\n                      if _u101[1][2] == FL then\n                        if _u101[1][3].tag == \'Break\' then\n                          return fits(_u99-#_u101[1][3][1]\n                                     ,_u100+#_u101[1][3][1]\n                                     ,_u101[2])\n                        else\n                          if _u101[1][3].tag == \'Group\' then\n                            return fits(_u99\n                                       ,_u100\n                                       ,{{_u101[1][1]\n                                         ;_u101[1][2]\n                                         ;_u101[1][3][1]}\n                                        ;_u101[2]})\n                          else\n                            if _u101[1][3].tag == \'Column\' then\n                              return fits(_u99\n                                         ,_u100\n                                         ,{{_u101[1][1]\n                                           ;_u101[1][2]\n                                           ;_u101[1][3][1](_u100)}\n                                          ;_u101[2]})\n                            else\n                              if _u101[1][3].tag == \'Nesting\' then\n                                return fits(_u99\n                                           ,_u100\n                                           ,{{_u101[1][1]\n                                             ;_u101[1][2]\n                                             ;_u101[1][3][1](_u101[1][1])}\n                                            ;_u101[2]})\n                              else return error(tostring(_u101))\n                              end\n                            end\n                          end\n                        end\n                      else\n                        if _u101[1][2] == BR and _u101[1][3].tag == \'Break\'\n                        then\n                          return true\n                        else\n                          if _u101[1][3].tag == \'Group\' then\n                            return fits(_u99\n                                       ,_u100\n                                       ,{{_u101[1][1]\n                                         ;_u101[1][2]\n                                         ;_u101[1][3][1]}\n                                        ;_u101[2]})\n                          else\n                            if _u101[1][3].tag == \'Column\' then\n                              return fits(_u99\n                                         ,_u100\n                                         ,{{_u101[1][1]\n                                           ;_u101[1][2]\n                                           ;_u101[1][3][1](_u100)}\n                                          ;_u101[2]})\n                            else\n                              if _u101[1][3].tag == \'Nesting\' then\n                                return fits(_u99\n                                           ,_u100\n                                           ,{{_u101[1][1]\n                                             ;_u101[1][2]\n                                             ;_u101[1][3][1](_u101[1][1])}\n                                            ;_u101[2]})\n                              else return error(tostring(_u101))\n                              end\n                            end\n                          end\n                        end\n                      end\n                    end\n                  else return error(tostring(_u101))\n                  end\n                end\n              else return error(tostring(_u101))\n              end\n            end\n          else return error(tostring(_u101))\n          end\n        end\n      end\n    end\n    local function push(_u102,_u103)\n      _u102[#_u102+1] = _u103\n      return _u102\n    end\n    local function nl(_u104,_u105)\n      return push(_u104,(\'\\n\'..spaces(_u105)))\n    end\n    local function best(_u106,_u107,_u108,_u109)\n      if \'<#null>\' == _u109 then return _u106\n      else\n        if type(_u109) == \'table\' and #_u109 == 2 and\n           type(_u109[1]) == \'table\' and #_u109[1] == 3\n        then\n          if _u109[1][3] == Empty then\n            return best(_u106,_u107,_u108,_u109[2])\n          else\n            if type(_u109[1][3]) == \'table\' then\n              if #_u109[1][3] == 2 then\n                if _u109[1][3].tag ~= nil then\n                  if _u109[1][3].tag == \'Cat\' then\n                    return best(_u106\n                               ,_u107\n                               ,_u108\n                               ,{{_u109[1][1];_u109[1][2];_u109[1][3][1]}\n                                ;{{_u109[1][1];_u109[1][2];_u109[1][3][2]}\n                                 ;_u109[2]}})\n                  else\n                    if _u109[1][3].tag == \'Nest\' then\n                      return best(_u106\n                                 ,_u107\n                                 ,_u108\n                                 ,{{_u109[1][1]+_u109[1][3][1]\n                                   ;_u109[1][2]\n                                   ;_u109[1][3][2]}\n                                  ;_u109[2]})\n                    else error(errfmt(4,false,_u106,_u107,_u108,_u109))\n                    end\n                  end\n                else error(errfmt(4,false,_u106,_u107,_u108,_u109))\n                end\n              else\n                if #_u109[1][3] == 1 and _u109[1][3].tag ~= nil then\n                  if _u109[1][3].tag == \'Text\' then\n                    return best(push(_u106,_u109[1][3][1])\n                               ,_u107\n                               ,_u108+#_u109[1][3][1]\n                               ,_u109[2])\n                  else\n                    if _u109[1][2] == FL then\n                      if _u109[1][3].tag == \'Break\' then\n                        return best(push(_u106,_u109[1][3][1])\n                                   ,_u107\n                                   ,_u108+#_u109[1][3][1]\n                                   ,_u109[2])\n                      else\n                        if _u109[1][3].tag == \'Group\' then\n                          return best(_u106\n                                     ,_u111\n                                     ,_u108\n                                     ,{{_u109[1][1];FL;_u109[1][3][1]}\n                                      ;_u109[2]})\n                        else\n                          if _u109[1][3].tag == \'Column\' then\n                            return best(_u106\n                                       ,_u107\n                                       ,_u108\n                                       ,{{_u109[1][1]\n                                         ;_u109[1][2]\n                                         ;_u109[1][3][1](_u108)}\n                                        ;_u109[2]})\n                          else\n                            if _u109[1][3].tag == \'Nesting\' then\n                              return best(_u106\n                                         ,_u107\n                                         ,_u108\n                                         ,{{_u109[1][1]\n                                           ;_u109[1][2]\n                                           ;_u109[1][3][1](_u109[1][1])}\n                                          ;_u109[2]})\n                            else\n                              error(errfmt(4,false,_u106,_u107,_u108,_u109))\n                            end\n                          end\n                        end\n                      end\n                    else\n                      if _u109[1][2] == BR then\n                        if _u109[1][3].tag == \'Break\' then\n                          return best(nl(_u106,_u109[1][1])\n                                     ,_u109[1][1]\n                                     ,_u109[1][1]\n                                     ,_u109[2])\n                        else\n                          if _u109[1][3].tag == \'Group\' then\n                            do\n                              local ribbonleft = min((_u111-_u108)\n                                                    ,(ribbon-_u108+_u107))\n                              if fits(ribbonleft\n                                     ,_u108\n                                     ,{{_u109[1][1];FL;_u109[1][3][1]}\n                                      ;_u109[2]})\n                              then\n                                return best(_u106\n                                           ,_u107\n                                           ,_u108\n                                           ,{{_u109[1][1];FL;_u109[1][3][1]}\n                                            ;_u109[2]})\n                              else\n                                return best(_u106\n                                           ,_u107\n                                           ,_u108\n                                           ,{{_u109[1][1];BR;_u109[1][3][1]}\n                                            ;_u109[2]})\n                              end\n                            end\n                          else\n                            if _u109[1][3].tag == \'Column\' then\n                              return best(_u106\n                                         ,_u107\n                                         ,_u108\n                                         ,{{_u109[1][1]\n                                           ;_u109[1][2]\n                                           ;_u109[1][3][1](_u108)}\n                                          ;_u109[2]})\n                            else\n                              if _u109[1][3].tag == \'Nesting\' then\n                                return best(_u106\n                                           ,_u107\n                                           ,_u108\n                                           ,{{_u109[1][1]\n                                             ;_u109[1][2]\n                                             ;_u109[1][3][1](_u109[1][1])}\n                                            ;_u109[2]})\n                              else\n                                error(errfmt(4\n                                            ,false\n                                            ,_u106\n                                            ,_u107\n                                            ,_u108\n                                            ,_u109))\n                              end\n                            end\n                          end\n                        end\n                      else\n                        if _u109[1][3].tag == \'Column\' then\n                          return best(_u106\n                                     ,_u107\n                                     ,_u108\n                                     ,{{_u109[1][1]\n                                       ;_u109[1][2]\n                                       ;_u109[1][3][1](_u108)}\n                                      ;_u109[2]})\n                        else\n                          if _u109[1][3].tag == \'Nesting\' then\n                            return best(_u106\n                                       ,_u107\n                                       ,_u108\n                                       ,{{_u109[1][1]\n                                         ;_u109[1][2]\n                                         ;_u109[1][3][1](_u109[1][1])}\n                                        ;_u109[2]})\n                          else error(errfmt(4,false,_u106,_u107,_u108,_u109))\n                          end\n                        end\n                      end\n                    end\n                  end\n                else error(errfmt(4,false,_u106,_u107,_u108,_u109))\n                end\n              end\n            else error(errfmt(4,false,_u106,_u107,_u108,_u109))\n            end\n          end\n        else error(errfmt(4,false,_u106,_u107,_u108,_u109))\n        end\n      end\n    end\n    return table.concat(best({},0,0,{{0;BR;_u110};\'<#null>\'}))\n  else error(errfmt(3,false,_u110,_u111,_u112))\n  end\nend\nlocal zpp = {}\nzpp.__index = zpp\nzpp.layout = layout\nzpp.isDoc = isDoc\nzpp.empty = empty\nzpp.text = text\nzpp.nest = nest\nzpp.group = group\nzpp.column = column\nzpp.nesting = nesting\nzpp.line = line\nzpp.linebreak = linebreak\nzpp.softline = group(line)\nzpp.softbreak = group(linebreak)\nzpp.space = space\nzpp.cat = cat\nzpp.catspace = catspace\nzpp.abovespace = abovespace\nzpp.above = above\nzpp.abovesoftspace = abovesoftspace\nzpp.abovesoft = abovesoft\nzpp.lparen = text\'(\'\nzpp.rparen = text\')\'\nzpp.langle = text\'<\'\nzpp.rangle = text\'>\'\nzpp.lbrace = text\'{\'\nzpp.rbrace = text\'}\'\nzpp.lbracket = text\'[\'\nzpp.rbracket = text\']\'\nzpp.backtick = text\'`\'\nzpp.squote = text\"\'\"\nzpp.dquote = text\'\"\'\nzpp.semi = text\';\'\nzpp.colon = text\':\'\nzpp.comma = text\',\'\nzpp.dot = text\'.\'\nzpp.slash = text\'/\'\nzpp.backslash = text\'\\\\\'\nzpp.assign = text\'=\'\nzpp.foldDoc = foldDoc\nzpp.separateWith = separateWith\nzpp.ifoldDoc = ifoldDoc\nzpp.iseparateWith = iseparateWith\nzpp.indent = indent\nzpp.align = align\nzpp.hang = hang\nzpp.fill = fill\nzpp.fillBreak = fillBreak\nDoc_mt.type = (function() return \"Doc\" end)\nDoc_mt.__tostring = layout\nDoc_mt.__add = cat\nDoc_mt.__sub = catspace\nDoc_mt.__div = abovespace\nDoc_mt.__mul = above\nzpp.compose = compose\nzpp.identity = identity\nzpp.i2list = i2list\n\n-- luapp\nlocal pairs = pairs\nlocal ipairs = ipairs\nlocal find = string.find\nlocal sort = table.sort\nlocal insert = table.insert\nlocal lbracket = zpp.lbracket\nlocal rbracket = zpp.rbracket\nlocal langle = zpp.langle\nlocal rangle = zpp.rangle\nlocal dot = zpp.dot\nlocal assign = zpp.assign\nlocal backtick = zpp.backtick\nlocal dcolon = text\" ::\"\nlocal consnull = text\"[]\"\nlocal consnullsp = text\" [] \"\nlocal TAG = \'tag\'\nlocal function encloseSep(_u2,_u3,_u4)\n  if isDoc(_u2) and isDoc(_u3) and isDoc(_u4) then\n    return function(_u1)\n      if type(_u1) == \'table\' then\n        return _u2+align(group(iseparateWith(_u4+line\n                                            ,identity)(_u1)))+_u3\n      else error(errfmt(1,false,_u1))\n      end\n    end\n  else error(errfmt(3,false,_u2,_u3,_u4))\n  end\nend\nlocal tabled = encloseSep(zpp.lbrace,zpp.rbrace,zpp.comma)\nlocal listed_proper = encloseSep(zpp.lbracket\n                                ,zpp.rbracket\n                                ,zpp.comma)\nlocal function listed(_u5,_u6)\n  if _u6 == nil then return listed_proper(_u5)\n  else\n    return encloseSep(empty,empty,dcolon){listed_proper(_u5);_u6}\n  end\nend\nlocal angles = function(x) return langle+x+rangle end\nlocal brackets = function(x) return lbracket+x+rbracket end\nlocal brkangles = function(x)\n  return lbracket+langle+x+rangle+rbracket\nend\nlocal function lua2doc(_u27,_u28)\n  if _u28 == nil or type(_u28) == \'string\' then\n    local root_path = text(_u28 or \'<#>\')\n    local key,value\n    local tracker = {}\n    local function isLikeId(_u7)\n      return type(_u7) == \'string\' and find(_u7,\"^[%a_][%a%d_]*$\")\n    end\n    local function sort_pairs_by_key(_u10,_u11)\n      if type(_u10) == \'table\' and #_u10 == 2 and\n         type(_u11) == \'table\' and #_u11 == 2\n      then\n        do\n          local _u8,_u9 = _u10[1],_u11[1]\n          if type(_u8) == \'number\' then\n            if type(_u9) == \'number\' then return _u8<_u9\n            else return true\n            end\n          else\n            if type(_u8) == \'string\' then\n              if type(_u9) == \'string\' then return _u8<_u9\n              else return not (type(_u9) == \'number\')\n              end\n            else\n              if type(_u9) == \'string\' or type(_u9) == \'number\' then\n                return false\n              else return type(_u8)<type(_u9)\n              end\n            end\n          end\n        end\n      else error(errfmt(2,false,_u10,_u11))\n      end\n    end\n    local function str2doc(_u12)\n      return text(format(\"%q\",_u12))\n    end\n    local function render_path(_u13)\n      if _u13 == nil then return empty\n      else\n        local res = empty; for i=#_u13,1,-1 do res = res+_u13[i]; end\n        return res\n      end\n    end\n    local function get_addr(_u14)\n      local obj = tostring(_u14)\n      local _,_,addr = find(obj,\': (.+)$\')\n      return addr or obj\n    end\n    local function prepare_table(_u17)\n      if type(_u17) == \'table\' then\n        local res,tag,len = {},nil,0\n        for i,_ in ipairs(_u17) do len = i; end\n        for k,v in pairs(_u17) do\n          do\n            local _u15,_u16 = k,v\n            if _u15 == TAG and type(_u16) == \'string\' then tag = _u16\n            else insert(res,{k;v})\n            end\n          end\n        end\n        sort(res,sort_pairs_by_key)\n        tag = tag and backtick+text(tag) or empty\n        return len,res,tag\n      else error(errfmt(1,false,_u17))\n      end\n    end\n    local function render_nonarray_part(_u18,_u19,_u20,...)\n      local last_i = _u18\n      for i=_u18,#_u19 do\n        last_i = i\n        local sorted_k,sorted_v = _u19[i][1],_u19[i][2]\n        if sorted_k == 1 then break end\n        local new_key,is_id = key(sorted_k)\n        local new_path_el = is_id and dot+new_key or new_key\n        _u20[i] = (new_key+assign+value(sorted_v,new_path_el,...))\n      end\n      return last_i\n    end\n    local function table2doc(_u22,...)\n      if type(_u22) == \'table\' then\n        local length,sorted,tag = prepare_table(_u22)\n        local res = {}\n        local ii = 1\n        do\n          local _u21 = sorted\n          if type(_u21) == \'table\' and #_u21 >= 1 and\n             type(_u21[1]) == \'table\' and #_u21[1] == 2 and\n             type(_u21[1][1]) == \'number\' and _u21[1][1] ~= 1\n          then\n            ii = render_nonarray_part(ii,sorted,res,...)\n          else\n          end\n        end\n        for i=ii,ii+length-1 do\n          res[i] = value(sorted[i][2],key(i),...)\n        end\n        render_nonarray_part(ii+length,sorted,res,...)\n        return tag+tabled(res)\n      else error(errfmt(1,true,_u22,...))\n      end\n    end\n    local function list2doc(_u23,_u24,...)\n      if \'<#null>\' == _u23 then return _u24\n      else\n        if type(_u23) == \'table\' and #_u23 == 2 then\n          do\n            _u24[#_u24+1] = value(_u23[1],key(1),...)\n            return list2doc(_u23[2],_u24,key(2),...)\n          end\n        else return _u24,value(_u23,...)\n        end\n      end\n    end\n    function key(_u25)\n      if type(_u25) == \'table\' then\n        if #_u25 == 2 and (\'<#null>\' == _u25[2] or\n           type(_u25[2]) == \'table\' and #_u25[2] == 2)\n        then\n          return brkangles(text(\'pair: \'..get_addr(_u25)))\n        else return brkangles(text(_u25))\n        end\n      else\n        if type(_u25) == \'number\' then return brackets(text(_u25))\n        else\n          if \'<#null>\' == _u25 then return brackets(consnullsp)\n          else\n            if isLikeId(_u25) then return text(_u25),\"ID\"\n            else\n              if type(_u25) == \'string\' then return brackets(str2doc(_u25))\n              else\n                if _u25 == nil then return error\'nil key?\'\n                else return brkangles(text(_u25))\n                end\n              end\n            end\n          end\n        end\n      end\n    end\n    function value(_u26,...)\n      if type(_u26) == \'table\' then\n        if RESPECT_TOSTRING_MT and _u26.__tostring then return text(tostring(_u26)) end\n        if tracker[_u26] then return tracker[_u26]\n        else\n          if #_u26 == 2 and (\'<#null>\' == _u26[2] and not _u26[TAG] or\n             type(_u26[2]) == \'table\' and #_u26[2] == 2 and not _u26[TAG])\n          then\n            do\n              tracker[_u26] = render_path{...}\n              return listed(list2doc(_u26,{},...))\n            end\n          else\n            do\n              tracker[_u26] = render_path{...}\n              return table2doc(_u26,...)\n            end\n          end\n        end\n      else\n        if \'<#null>\' == _u26 then return consnull\n        else\n          if type(_u26) == \'string\' then return str2doc(_u26)\n          else\n            if type(_u26) == \'function\' or type(_u26) == \'thread\' or\n               type(_u26) == \'userdata\'\n            then\n              return angles(text(_u26))\n            else return text(_u26)\n            end\n          end\n        end\n      end\n    end\n    return value(_u27,root_path)\n  else error(errfmt(2,false,_u27,_u28))\n  end\nend\n\n-- pp(any, [root-name]=\"<#>\", [page-width]=160, [line-fill]=0.8) -> string\n-- @root-name -- optional name for the topmost table if you expect it to be recvursive\n-- @page-width -- optional max page width\n-- @line-fill -- max desired (line width)/(page width)\nlocal function pp(obj, root, width, fill)\n  if root == nil or type(root) == \'string\' and width == nil or\n     type(width) == \'number\' and (fill == nil or\n     type(fill) == \'number\')\n  then\n    return layout(lua2doc(obj,root),width,fill)\n  else error(errfmt(4,false,obj,root,width,fill))\n  end\nend\n\nlocal luapp = {}\nluapp.__index = luapp\nluapp.pp = pp\nluapp.zpp = zpp -- submodule, pretty printers construction kit\nluapp.errfmt = function(...)\n  return errfmt(select(\"#\", ...), false, ...)\nend\nreturn luapp"
      }
    }
    Assets {
      Id: 4327176263148897822
      Name: "_Bitarray"
      PlatformAssetType: 3
      TextAsset {
        Text: "-- fixed size bitarray\nlocal bitarray = {}\nbitarray.__index = bitarray\n\nlocal function nbytes(size)\n    return size%8 == 0 and size//8 or size//8 + 1\nend\n\nfunction bitarray.new(size, default)\n    size = size or 32\n    local n = nbytes(size)\n    local _size = size\n    local self = {size=function() return _size end}\n\n    local fill = default and 0xFF or 0x00\n    for i=1, n do\n        self[i] = fill\n    end\n    return setmetatable(self, bitarray)\nend\n\n-- eq :: self, other -> bool\nfunction bitarray:eq(other)\n    if self == other then return true end\n    if self.size() ~= other.size() then return false end\n    local n = nbytes(self.size())\n    for i=1, n do\n        if self[i] ~= other[i] then return false end\n    end\n    return true\nend\n\n-- sel :: self, i, bool ^-> self\nfunction bitarray:set(i, val)\n    assert(i >= 1 and i <= self.size())\n    local idx, bit = (i-1)//8 + 1, (i-1)%8\n    local byte = self[idx]\n    byte = val and byte | (1 << bit) or byte & ~(1 << bit)\n    self[idx] = byte\n    return self\nend\n\n-- get :: self, i -> bool\nfunction bitarray:get(i)\n    assert(i >= 1 and i <= self.size())\n    local idx, bit = (i-1)//8 + 1, (i-1)%8\n    return self[idx] & (1 << bit) ~= 0\nend\n\n-- find_and_swap :: self, i ^-> i | nil\nfunction bitarray:find_and_swap(bool)\n    bool = bool and true or false\n    for i = 1, self.size() do\n        if bool == self:get(i) then\n            self:set(i, not bool)\n            return i\n        end\n    end\nend\n\n-- swap :: self, i ^-> i\nfunction bitarray:swap(i)\n    assert(i > 0 and i <= self.size())\n    local val = self:get(i)\n    self:set(i, not val)\n    return i\nend\n\n-- serialize :: self -> string\nfunction bitarray:serialize()\n    local size = utf8.char(self.size())\n    if #size == 1 then\n        return string.char(self.size(), table.unpack(self))\n    end\n    local s = string.char(table.unpack(self))\n    assert(#s == #self, \"limit on the number of return values reached?\")\n    return size..s\nend\n\n-- deserialize :: string, first_byte -> bitarray, next_byte\nfunction bitarray.deserialize(str, from)\n    from = from or 1\n    local _size = utf8.codepoint(str, from)\n    local offset = utf8.offset(str, 2, from)\n    local n = nbytes(_size)\n    local self = {size=function() return _size end, string.byte(str, offset, offset + n)}\n    return setmetatable(self, bitarray), offset + n\nend\n\nlocal function _bitarray_test()\n    local ba1 = bitarray.new(9, true)\n    assert(ba1.size() == 9)\n    assert(ba1:eq(ba1))\n    ba1:set(1, nil)\n    assert(not ba1:get(1))\n    assert(ba1:get(2) and ba1:get(9))\n\n    local ba2 = bitarray.new(7)\n    assert(ba2.size() == 7)\n    assert(ba2:find_and_swap() == 1 and ba2:get(1))\n    ba2:swap(1)\n    assert(not ba2:get(1))\n    ba2:set(2, true):set(7, true)\n    for i=1, 7 do\n        if i == 2 or i == 7 then\n            assert(ba2:get(i))\n        else\n            assert(not ba2:get(i))\n        end\n    end\n\n    local ba2s = ba2:serialize()\n    assert(#ba2s == 2 and string.byte(ba2s) == 7 and string.byte(ba2s, 2, 2) == 66)\n    local ba21 = bitarray.deserialize(ba2s)\n    assert(ba2:eq(ba21))\n\n    -- limits\n    local N = 10000 -- tested up to 1MM\n    local ba10K = bitarray.new(N, true)\n    ba10K:set(N//2, nil)\n    local ba10Ks = ba10K:serialize()\n    local ba10K1 = bitarray.deserialize(ba10Ks)\n    assert(ba10K:eq(ba10K1))\n    assert(not ba10K1:get(N//2))\n\n    -- part string\n    local ba4 = bitarray.new(123, true):set(14, nil):set(25, nil)\n    local ba3s = \"GRID\" .. ba2s .. ba4:serialize()\n    local ba3, ba4n = bitarray.deserialize(ba3s, 5)\n    local ba41 = bitarray.deserialize(ba3s, ba4n)\n    assert(ba2:eq(ba3))\n    assert(ba4:eq(ba41))\n    --\n    local ba = bitarray.new(765, true):set(15, nil):set(22, nil)\n    local s = \"GRID\" .. utf8.char(10240, 33000) .. ba:serialize() .. \'tail\'\n\n    local w, h = utf8.codepoint(s, 5, utf8.offset(s, 2, 5))\n    assert(w == 10240 and h == 33000)\n    local ba11, next = bitarray.deserialize(s, utf8.offset(s, 3, 5))\n    assert(ba11:eq(ba))\n    assert(s:sub(next) == \'tail\')\n    --\n    print(\"bitarray -- ok\")\n end\n\n_bitarray_test()\n\nreturn bitarray"
      }
    }
    Assets {
      Id: 12769054960477199651
      Name: "_Grid"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    Grid coordinates:\n    0 --> +y, +col\n    |\n    v\n    -x, +row\n]]\n\nif not _G.req then _G.req = require end\nlocal Maid = _G.req(\"_Maid\")\nlocal Deque = _G.req(\"_Deque\")\nlocal Bitarray = _G.req(\"_Bitarray\")\nlocal Base64 = _G.req(\"_Base64\")\nlocal pp = _G.req(\"_Luapp\").pp\nlocal Grid = {type = \"Grid\"}\nGrid.__index = Grid\nlocal abs, sqrt = math.abs, math.sqrt\n\nlocal CORE_ENV = CoreString and CoreMath\n\nlocal Cell = {type=\"Cell\"}\nCell.__index = Cell\n\nlocal CELL_NIL, CELL_CENTER do\n    function Cell.New(row, col, posx, posy, actor)\n        assert(not actor or type(actor) == \"number\")\n        return setmetatable({\n            row=row, col=col, posx=posx, posy=posy, actor = actor\n        }, Cell)\n    end\n\n    CELL_NIL = Cell.New()\n    CELL_CENTER = CELL_NIL\nend\n\nfunction Cell.__tostring(c)\n    if c == CELL_NIL then return \"CELL_NIL\" end\n    local actor = c.actor and tostring(c.actor.id) or \"()\"\n    return string.format(\n        \"Cell:{row: %d, col: %d, posx: %0.2f, posy: %0.2f, actor: %s}\",\n        c.row, c.col, c.posx, c.posy, actor)\nend\n\nfunction Cell:IsNil()\n    return not self or self == CELL_NIL\nend\n\nfunction Cell:Unpack()\n    if self ~= CELL_NIL then\n        return self.row, self.col, self.actor and self.actor.id\n    end\nend\n\nfunction Cell:ManhattanDistance(other)\n    if self == CELL_NIL or other == CELL_NIL then return math.huge end\n    return abs(self.row - other.row) + abs(self.col - other.col)\nend\n\nfunction Cell:Distance(other)\n    if self == CELL_NIL or other == CELL_NIL then return math.huge end\n    local dr, dc = self.row - other.row, self.col - other.col\n    return sqrt(dr*dr + dc*dc)\nend\n\nfunction Cell:IsFree()\n    return self ~= CELL_NIL and not self.actor\nend\n\nfunction Cell:Destroy()\n    if self.tile then\n        Maid.safeDestroy(self.tile)\n    end\n    if self.actor then\n        Maid.safeDestroy(self.actor)\n    end\nend\n\nlocal function idx2rc(idx, width)\n    return (idx - 1)//width, (idx - 1)%width -- 0-idx\nend\n\nlocal function rc2idx(row0, col0, width)\n    return row0 >= 0 and col0 >= 0 and row0*width + col0 + 1 or -1\nend\n\n-- TODO: factor out geometry: dims, transform etc.\n-- empty :: [(r,c)]\nfunction Grid.New(w, h, dimx, dimy)\n    local _maid = Maid.New()\n    local cells = {}\n    for i = 1, w*h  do\n        local row, col = idx2rc(i, w)\n        local posx, posy = -row*dimx, col*dimy\n        cells[i] = Cell.New(row, col, posx, posy)\n        _maid:GiveTask(cells[i])\n    end\n    local self = setmetatable({_maid=_maid}, Grid)\n    self.w, self.h, self.dimx, self.dimy, self.cells = w, h, dimx, dimy, cells\n    -- add spatial extent\n    self.pos_x, self.neg_x = 0, -dimx*h\n    self.pos_y, self.neg_y = dimy*w, 0\n    if CORE_ENV then\n        self.worldToGrid = Transform.IDENTITY\n    end\n    return self\nend\n\nfunction Grid:Fold(binop, seed)\n    assert(type(binop) == \"function\")\n    local n = self.w*self.h\n    for i=1, n do\n        local cell = self.cells[i]\n        if cell ~= CELL_NIL then\n            seed = binop(seed, cell)\n        end\n    end\n    return seed\nend\n\nfunction Grid:Search(predicate)\n    local n = self.w*self.h\n    for i=1, n do\n        local cell = self.cells[i]\n        if predicate(cell) then return cell end\n    end\nend\n\nlocal FOURCC = \"GRID\"\nfunction Grid:serialize(exploded)\n    local n = self.w*self.h\n    -- first position reserved for protocol op-tag\n    local out = {\"\", FOURCC, utf8.char(self.w, self.h, self.dimx, self.dimy), \'bitmap-placeholder\'}\n    local bitmap = Bitarray.new(n)\n    for i = 1, n do\n        local cell = self.cells[i]\n        local hole = (cell == CELL_NIL)\n        bitmap:set(i, not hole)\n        if not hole and cell.actor and cell.actor.id  then\n            out[#out+1] = utf8.char(cell.row, cell.col, cell.actor.id)\n        end\n    end\n    assert(out[4] == \'bitmap-placeholder\')\n    out[4] = bitmap:serialize()\n    return exploded and out or table.concat(out)\nend\n\nfunction Grid.deserialize(s, from, to)\n    from, to = from or 1, to or #s\n    assert(string.sub(s, from, from + #FOURCC - 1) == FOURCC)\n    from = from + #FOURCC\n    local whi = utf8.offset(s, 4, from)\n    local w, h, dimx, dimy = utf8.codepoint(s, from, whi)\n    local bi = utf8.offset(s, 5, from)\n    local bitmap\n    bitmap, from = Bitarray.deserialize(s, bi)\n    assert(bitmap:size() == w*h)\n    local actors = {utf8.codepoint(s, from, to)}\n    assert(#actors == 0 or #actors%3 == 0)\n    local grid = Grid.New(w, h, dimx, dimy)\n    for i=1, bitmap:size() do\n        if not bitmap:get(i) then\n            grid:MakeHole(i)\n        end\n    end\n    for i = 1, #actors, 3 do\n        local r, c, actor_id = actors[i], actors[i+1], actors[i+2]\n        local cell = grid:at(r,c)\n        cell.actor = {id=actor_id}\n    end\n    return grid\nend\n\n-- MakeHole :: self, idx | (row, col) ^-> self\nfunction Grid:MakeHole(row, col)\n    local idx = not col and row or rc2idx(row, col, self.w)\n    assert(idx <= self.w*self.h)\n    assert(not self.cells[idx].tile or not self.cells[idx].actor)\n    self.cells[idx]:Destroy()\n    self.cells[idx] = CELL_NIL\n    return self\nend\n\nfunction Grid:Destroy()\n    local n, cells = #self.cells, self.cells\n    for i = n, 1, -1 do\n        cells[i]:Destroy()\n        cells[i] = CELL_NIL\n    end\nend\n\n-- at :: self, idx | (row, col) -> Cell\nfunction Grid:at(row, col)\n    local idx = not col and row or rc2idx(row, col, self.w)\n    return self.cells[idx] or CELL_NIL\nend\n\nfunction Grid:GetExtent()\n    return {pos_x=self.pos_x, neg_x=self.neg_x, pos_y=self.pos_y, neg_y=self.neg_y}\nend\n\nfunction Grid:in_bounds(x, y)\n    return x >= self.neg_x and x <= self.pos_x and y >= self.neg_y and y <= self.pos_y\nend\n\n-- world coordinates\n\n\nif CORE_ENV then\n    function Grid:GetCellAtPoint(vec3)\n        if not vec3 then return CELL_NIL end\n        local p = self.worldToGrid == Transform.IDENTITY\n            and vec3\n            or self.worldToGrid:TransformPosition(vec3)\n        return self:GetCellAt(p.x, p.y)\n    end\nend\n\nfunction Grid:GetCellAt(x, y)\n    if self:in_bounds(x, y) then\n        local dimx, dimy = self.dimx, self.dimy\n        local row = (-x + dimx/2)//dimx\n        local col = (y + dimy/2)//dimy\n        if row < self.h and col < self.w then\n            return self.cells[rc2idx(row, col, self.w)]\n        end\n    end\n    return CELL_NIL\nend\n-- roe, col, actor_id -> ok, local_cell, local_actor_id\nfunction Grid:_move_precheck(row, col, actor_id)\n    local loc = self:at(row, col)\n    local loc_actor = loc.actor\n    local loc_actor_id = loc_actor and loc_actor.id\n    return (loc ~= CELL_NIL and loc_actor_id == actor_id), loc, loc_actor\nend\n\nfunction Grid:Move(dest, src, check)\n    local dok, dloc, _ = self:_move_precheck(table.unpack(dest))\n    local sok, sloc, sactor = self:_move_precheck(table.unpack(src))\n    local ok = sok and dok\n    if ok and not check then\n        dloc.actor, sloc.actor = sactor, nil\n    end\n    return ok\nend\n\nfunction Grid:Swap(dest, src, check)\n    local dok, dloc, dactor = self:_move_precheck(table.unpack(dest))\n    local sok, sloc, sactor = self:_move_precheck(table.unpack(src))\n    local ok = dok and sok and dactor and sactor\n    if ok and not check then\n        dloc.actor, sloc.actor = sactor, dactor\n    end\n    return ok\nend\n\nfunction Grid:Push(dest, src, empty, check)\n    local dok, dloc, dactor = self:_move_precheck(table.unpack(dest))\n    local sok, sloc, sactor = self:_move_precheck(table.unpack(src))\n    local eok, eloc, eactor = self:_move_precheck(table.unpack(empty))\n    local ok = dok and sok and eok and dactor and sactor and not eactor\n    if ok and not check then\n        dloc.actor, sloc.actor, eloc.actor = sactor, nil, dactor\n    end\n    return ok\nend\n\nfunction Grid:Merge3(dest, src, other, factory, check)\n    local dok, dloc, dactor = self:_move_precheck(table.unpack(dest))\n    local sok, sloc, sactor = self:_move_precheck(table.unpack(src))\n    local ook, oloc, oactor = self:_move_precheck(table.unpack(other))\n    local ok = dok and sok and ook and dactor and sactor and oactor and (dactor.id == sactor.id) and (dactor.id == oactor.id)\n    if ok and not check then\n        local new_actor = assert(factory())\n        dloc.actor, sloc.actor, oloc.actor = new_actor, nil, nil\n    end\n    return ok\nend\n\n-- search_closest :: cell, predicate -> [cell], center excluded\ndo\n    local function comparer(c1, c2)\n        return CELL_CENTER:ManhattanDistance(c1) < CELL_CENTER:ManhattanDistance(c2)\n    end\n    function Grid:SearchClosest(center, predicate)\n        local out, cells, n = {}, self.cells, self.w * self.h\n        for i = 1, n do\n            local c = cells[i]\n            if c ~= center and predicate(c) then out[#out + 1] = c end\n        end\n        CELL_CENTER = center\n        table.sort(out, comparer)\n        CELL_CENTER = CELL_NIL\n        return out\n    end\nend\n-- BFS NOTE:\n-- -- SearchClosest is faster for < 50 cells and uses 3x less memory - don\'t use BFS if you can\n-- -- returns array + set of satisfied cells, excludes origin\ndo\n    local SEARCH_PATTERN = {1, 0, -1, 0, 1}\n    local all = function() return true end\n    function Grid:Bfs(origin, predicate, limit)\n        predicate = predicate or all\n        limit = limit and limit > 0 and limit or math.huge\n        local q, visited = Deque.New(), {}\n        q:Push(origin)\n        while not q:Empty() do\n            if #visited >= limit then break end\n            local cell = q:Pop()\n            local cr, cc = cell.row, cell.col\n            for i = 1, 4 do\n                local row, col = cr + SEARCH_PATTERN[i], cc + SEARCH_PATTERN[i+1]\n                local next = self:at(row, col)\n                if next ~= CELL_NIL and next ~= origin and not visited[next] and predicate(next) then\n                    q:Push(next)\n                    visited[next] = true\n                    visited[#visited+1] = next -- add cell to array part (to return a result)\n                end\n            end\n        end\n        return visited\n    end\n\n    function Grid:Neighbor4(origin, predicate)\n        predicate = predicate or all\n        local r, c = origin.row, origin.col\n        for i = 1, 4 do\n            local row, col = r + SEARCH_PATTERN[i], c + SEARCH_PATTERN[i+1]\n            local cell = self:at(row, col)\n            if cell ~= CELL_NIL and cell ~= origin and predicate(cell) then\n                return cell\n            end\n        end\n    end\n\n    function Grid:Neighbor8(origin, predicate)\n        predicate = predicate or all\n        local r, c = origin.row, origin.col\n        for dr = -1, 1 do\n            for dc = -1, 1 do\n                local cell = self:at(r + dr, c + dc)\n                if cell ~= CELL_NIL and cell ~= origin and predicate(cell) then \n                    return cell\n                end\n            end\n        end\n    end\nend\n\nif CORE_ENV then\n    function Grid:SetWorldToGridTransform(tr)\n        self.worldToGrid = tr\n    end\nend\n\nlocal function _test()\n    -- g1\n    local W, H, DimX, DimY = 5, 4, 50, 100\n    local g1 = Grid.New(W, H, DimX, DimY)\n    assert(#g1.cells == W*H)\n    assert(g1:at(1) == g1:at(0,0))\n    assert(g1:at(W*H) == g1:at(H-1, W-1))\n    local c00 = g1:GetCellAt(0, 0)\n    assert(c00.row == 0 and c00.col == 0)\n    local c34 = g1:GetCellAt(-(H-1)*g1.dimx, (W-1)*g1.dimy)\n    assert(c34.row == 3 and c34.col == 4)\n    local c32 = g1:GetCellAt(-149.999, 199.999)\n    assert(c32.row == 3 and c32.col == 2)\n    assert(g1:GetCellAt(-1,-10) == CELL_NIL)\n\n    if CORE_ENV then\n        local tr = Transform.IDENTITY\n        tr:SetPosition(Vector3.New(200, 200, 0))\n        local wtr =tr:GetInverse()\n        g1:SetWorldToGridTransform(wtr)\n        local c31 = g1:GetCellAtPoint(Vector3.New(49.999, 299.999, 0))\n        assert(c31.row == 3 and c31.col == 1)\n    end\n    -- search\n    local center = g1:at(0,0)\n    local ce = g1:SearchClosest(center, function(c) return c.row % 2 == 0 and c.col %2 == 0 end)\n    assert(#ce == 5 and ce[1] == g1:at(0,2))\n    assert(ce[2] == g1:at(2,0))\n    assert(ce[3] == g1:at(2,2))\n    assert(ce[4] == g1:at(0,4))\n    assert(ce[5] == g1:at(2,4))\n\n    -- bfs\n    local g2 = Grid.New(10, 10, 100, 100)\n    center = g2:at(0,0)\n    g2:at(0,1).actor={id=12}\n    g2:at(0,2).actor={id=12}\n    g2:at(1,2).actor={id=730}\n    g2:at(2,2).actor={id=730}\n    g2:at(2,3).actor={id=0}\n    g2:MakeHole(1, 1)\n        :MakeHole(0, 3)\n        :MakeHole(1, 0)\n\n    local cells = g2:Bfs(center, function(c) return c.actor end)\n    assert(#cells == 5)\n    assert(not cells[center])\n    cells = g2:Bfs(center, function(c) return c.actor end, 3)\n    assert(#cells == 3)\n\n    local g2s = g2:serialize()\n    local g2s_64 = Base64.encode(g2s)\n    local g2s_2 = Base64.decode(g2s_64)\n    assert(g2s == g2s_2)\n    local g21 = Grid.deserialize(g2s_2)\n    assert(g21:at(0,1).actor.id==12)\n    assert(g21:at(0,2).actor.id==12)\n    assert(g21:at(1,2).actor.id==730)\n    assert(g21:at(2,2).actor.id==730)\n    assert(g21:at(2,3).actor.id==0)\n\n\n    local g3 = Grid.New(10, 10, 100, 100)\n    local r, c = 2, 3\n    for dr = -1, 1 do\n        for dc = -1, 1 do\n            local d = g3:at(r, c):Distance(g3:at(r+dr, c+dc))\n            assert(d < 2)\n            local md = g3:at(r, c):ManhattanDistance(g3:at(r+dr, c+dc))\n            assert(md <= 2)\n        end\n    end\n\n    print(\"grid -- ok\")\n\nend\n_test()\n\nreturn Grid"
      }
    }
    Assets {
      Id: 15572707156245510975
      Name: "_StateMachine"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\r\n    Slightly abstracted state-machine from Mergelandia\r\n    Predefined state callbacks (all optional):\r\n        Check :: state -> bool\r\n        Enter :: state, ... -> nil\r\n        Exit  :: state -> nil\r\n        Update :: state, dt -> nil\r\n]]\r\n\r\nlocal Maid = _G.req(\"Maid\")\r\nlocal StateMachine = {}\r\nStateMachine.__index = StateMachine\r\n\r\nlocal State = {}\r\nState.__index = State\r\nlocal START = setmetatable({name=\"$START\"}, State)\r\n\r\nfunction StateMachine.New()\r\n    return setmetatable({\r\n        states = {},\r\n        _maid = Maid.New(),\r\n        currentState = START,\r\n    }, StateMachine)\r\nend\r\n\r\n-- handlers :: {key = [handle1, handle2, ...]\r\n-- example: {[\"ability_primary\"] = {\"HandleLeftMouseDown\", \"HandleLeftMouseUp\"}, ...}\r\n-- usage: PLAYER.bindingPressedEvent:Connect(function(_,binding) MapToStateHandler(binding, 1) end)\r\nfunction StateMachine:SetBindingHandlers(handlers)\r\n    self.handlers = handlers\r\nend\r\n\r\nfunction StateMachine:MapToStateHandler(binding, handlerIndex, ...)\r\n    assert(handlerIndex and type(handlerIndex) == \"number\")\r\n    if not self.handlers[binding] then return end\r\n    local handler = self.handlers[binding][handlerIndex]\r\n    if self.currentState and self.currentState[handler] then\r\n        self.currentState[handler](self.currentState, ...)\r\n    end\r\nend\r\n\r\nfunction StateMachine:Connect(connectable, callback, event)\r\n    if connectable == Events then\r\n        self._maid:GiveTask(connectable.Connect(event, callback))\r\n    else\r\n        self._maid:GiveTask(connectable:Connect(callback))\r\n    end\r\nend\r\n\r\nlocal function _spawnUpdate(self, update)\r\n    return Task.Spawn(function()\r\n        while true do\r\n            local dt = Task.Wait()\r\n            update(self, dt)\r\n        end\r\n    end)\r\nend\r\n\r\nfunction StateMachine:GoToState(state, ...)\r\n    assert(state)\r\n    state = getmetatable(state) == State and state or self.states[state]\r\n    if state.Check and not state:Check() then return end\r\n    if self.currentState and self.currentState.name == state then return end\r\n    if self.currentState and self.currentState.Exit then self.currentState:Exit() end\r\n    local from = self.currentState\r\n    self.currentState = state\r\n    if state.Enter then state:Enter(from, ...) end\r\n    self._maid.update = state.Update and _spawnUpdate(state, state.Update) or nil\r\nend\r\n\r\nfunction StateMachine:AddState(name)\r\n    local state = setmetatable({name=name, _sm = self}, State)\r\n    self.states[name] = state\r\n    return state\r\nend\r\n\r\nfunction StateMachine:Destroy()\r\n    self._maid:Destroy()\r\nend\r\n\r\nreturn StateMachine"
      }
    }
    Assets {
      Id: 7602836839952416252
      Name: "_Spr"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n   Copyright (c) 2020 Parker Stebbins. All rights reserved.\n   License & docs can be found at https://github.com/Fraktality/spr\n   Core version by https://github.com/zoon\n]]\n\n-- TODO:\n-- * proxy object for props without lerp: create :: obj, lerp, get, set, target -> proxy\n\nlocal Spr = {}\nSpr.__index = Spr\n\nlocal pi = math.pi\nlocal exp = math.exp\nlocal sin = math.sin\nlocal cos = math.cos\nlocal sqrt = math.sqrt\nlocal EPS = 1e-5\nlocal SLEEP_OFFSET_SQ_LIMIT = 1e-4^2 -- (1/3840)^2\nlocal SLEEP_VELOCITY_SQ_LIMIT = 1e-2^2\n\n--[[\n    step: (dt, d, f, p, v) -> (p, v, sleep)\n    dt: simulation time step\n     `d`: damping ratio\n       * d < 1 Underdamping: overshoots and converges on the target.\n       * d = 1 Critical damping: converges on the target without overshooting.\n       * d > 1 Overdamping: converges on the target without overshooting, but slower.\n     `f`: undumped frequency in Hz\n     `p` and `v`: state veriables (position and velocity)\n    Note: goal is always equal to 1\n]]\nlocal function step(dt, d, f, p, v)\n    f = f*2*pi -- Hz -> Rad/s\n    local g = 1\n    local o = p - g\n\n    if d == 1 then -- critically damped\n        local q = exp(-f*dt)\n        local w = dt*q\n\n        local c0 = q + w*f\n        local c2 = q - w*f\n        local c3 = w*f*f\n\n        p = o*c0 + v*w + g\n        v = v*c2 - o*c3\n    elseif d < 1 then -- underdamped\n        local q = exp(-d*f*dt)\n        local c = sqrt(1 - d*d)\n\n        local i = cos(dt*f*c)\n        local j = sin(dt*f*c)\n\n        -- Damping ratios approaching 1 can cause division by very small numbers.\n        -- To mitigate that, group terms around z=j/c and find an approximation for z.\n        -- Start with the definition of z:\n        --    z = sin(dt*f*c)/c\n        -- Substitute a=dt*f:\n        --    z = sin(a*c)/c\n        -- Take the Maclaurin expansion of z with respect to c:\n        --    z = a - (a^3*c^2)/6 + (a^5*c^4)/120 + O(c^6)\n        --    z \342\211\210 a - (a^3*c^2)/6 + (a^5*c^4)/120\n        -- Rewrite in Horner form:\n        --    z \342\211\210 a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6\n\n        local z\n        if c > EPS then\n            z = j/c\n        else\n            local a = dt*f\n            z = a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6\n        end\n\n        -- Frequencies approaching 0 present a similar problem.\n        -- We want an approximation for y as f approaches 0, where:\n        --    y = sin(dt*f*c)/(f*c)\n        -- Substitute b=dt*c:\n        --    y = sin(b*c)/b\n        -- Now reapply the process from z.\n\n        local y\n        if f*c > EPS then\n            y = j/(f*c)\n        else\n            local b = f*c\n            y = dt + ((dt*dt)*(b*b)*(b*b)/20 - b*b)*(dt*dt*dt)/6\n        end\n        p = (o*(i + z*d) + v*y)*q + g\n        v = (v*(i - z*d) - o*(z*f))*q\n    else -- overdamped\n        local c = sqrt(d*d - 1)\n\n        local r1 = -f*(d - c)\n        local r2 = -f*(d + c)\n\n        local ec1 = exp(r1*dt)\n        local ec2 = exp(r2*dt)\n\n        local co2 = (v - o*r1)/(2*f*c)\n        local co1 = ec1*(o - co2)\n\n        p = co1 + co2*ec2 + g\n        v = co1*r1 + co2*ec2*r2\n    end\n    o = p - g\n    return p, v, o*o < SLEEP_OFFSET_SQ_LIMIT and v*v < SLEEP_VELOCITY_SQ_LIMIT\nend\n\nfunction Spr.New(dumping, frequency)\n    dumping, frequency = dumping or 1, frequency or 1\n    assert(dumping >= 0 and frequency >= 0)\n    return setmetatable({dumping=dumping, frequency=frequency}, Spr)\nend\n\nlocal _springStates = setmetatable({}, {__mode=\"k\"})\n\nlocal function _getPropValue(obj, propkey)\n    local m = \'Get\' .. propkey\n    assert(propkey and obj[m])\n    return obj[m](obj)\nend\n\nlocal function _setPropValue(obj, propkey, value)\n    if propkey:find(\"Rotation\") then value = Rotation.New(value) end\n    local m = \'Set\' .. propkey\n    assert(propkey and obj[m])\n    obj[m](obj, value)\nend\n\nlocal function _getLerp(prop)\n    local type = type(prop)\n    if type == \'userdata\' then return prop.Lerp or prop.Slerp end\n    if type == \'number\' then return CoreMath.Lerp end\nend\n\nlocal _ACTIVE = false\nlocal function _trampoline()\n    print(\"!~~~> Spr trampoline STARTED\", Task.GetCurrent(), time())\n    while _ACTIVE do\n        local dt = Task.Wait()\n        -- pre clean-up unvalid objects\n        for obj, _ in pairs(_springStates) do\n            if not obj:IsValid() then _springStates[obj] = nil end\n        end\n        -- run step\n        for obj, states in pairs(_springStates) do\n            for propkey, pstate in pairs(states) do\n                -- step: (dt, d, f, p, v) -> (p, v, sleep)\n                local p, v, sleep = step(dt, pstate.d, pstate.f, pstate.p, pstate.v)\n                _setPropValue(obj, propkey, pstate.lerp(pstate.origin, pstate.goal, not sleep and p or 1))\n                if sleep then\n                    states[propkey] = nil\n                    if pstate.onsleep then\n                        local onsleep = pstate.onsleep\n                        pstate.onsleep = nil\n                        assert(type(onsleep) == \'function\', \"onsleep should be a function\")\n                        onsleep()\n                    end\n                else\n                    pstate.p = p\n                    pstate.v = v\n                end\n            end\n        end\n        -- post clean-up finished objects\n        for obj, states in pairs(_springStates) do\n            if not next(states) then\n                _springStates[obj] = nil\n            end\n        end\n        if not next(_springStates) then\n            _ACTIVE = false\n        end\n    end\n    print(\"!~~~> Spr trampoline STOPPED\", Task.GetCurrent(), time())\nend\n\nlocal function activate()\n    if _ACTIVE then return end\n    _ACTIVE = true\n    Task.Spawn(_trampoline)\nend\n\n--[[\nTODO: some schema for extending + random stream (?)\nlocal params = {\n    StartDelay = {},  -- delay or range [from, to]\n    IterationDelay = {}, -- delay of range [from, to]\n    RandomizeDumping = {}, -- factor of [from,to] range\n    RandomizeFrequency = {}, -- factor of [from,to] range\n    Iterations = -1, -- count or -1 for infinite\n    PingPong = true, -- bool\n    OnSleap = function() end\n}\n--]]\n\n\n-- TODO: smarts\nfunction Spr:Target(obj, propkey, goal, onsleep)\n    assert(propkey and type(propkey) == \'string\', \"no propkey\")\n    if not _springStates[obj] then\n        _springStates[obj] = {}\n    end\n    local states = _springStates[obj]\n    if not states[propkey] then\n        states[propkey] = {}\n        activate()\n    end\n    local rot = propkey:find(\"Rotation\")\n    local pstate = states[propkey]\n    local value = _getPropValue(obj, propkey)\n    pstate.d = self.dumping\n    pstate.f = self.frequency\n    pstate.origin = not rot and value or Quaternion.New(value)\n    pstate.goal = not rot and goal or Quaternion.New(goal)\n    pstate.lerp = assert(_getLerp(pstate.origin), \"no Lerp\")\n    pstate.p = 0\n    pstate.v = 0\n    pstate.onsleep = onsleep\nend\n\nfunction Spr:Randomize(factor)\n    factor = factor or 0.05\n    factor = factor*(2*math.random() - 1)\n    local d, f = self.dumping, self.frequency\n    self.dumping = d == 1 and 1 or d + d*factor\n    self.frequency = f + f*factor\n    return self\nend\n\n\n-- stops animating of prop or all props\nfunction Spr.Stop(obj, propkey)\n    if not propkey then _springStates[obj] = nil end\n    local states = _springStates[obj]\n    if states then states[propkey] = nil end\nend\n\n-- sets animation to reach the goal in 1 frame\nfunction Spr.Finalize(obj, propkey)\n    local states = _springStates[obj]\n    if not states then return end\n    for pk, ps in pairs(states) do\n        if not propkey or propkey == pk then\n            ps.p = 1\n            ps.v = 0\n        end\n    end\nend\n\n-- self test\nlocal function _self_test()\n    local d, f = 1, 1\n    local p1, v1, s1 = step(0.5, d, f, 0, 0)\n    assert(not s1 and math.abs(p1 - 0.82102555358593) < EPS)\n    assert(math.abs(v1 - 0.85300855576888) < EPS)\n    local p2, v2, s2 = step(0.5, d, f, p1, v1)\n    assert(not s2 and math.abs(p2 - 0.98639906853443) < EPS)\n    assert(math.abs(v2 - 0.07372368401459) < EPS)\n    d = 0.5\n    p1, v1, s1 = step(0.5, d, f, 0, 0)\n    assert(not s1 and math.abs(p1 - 1.1406996741435) < EPS)\n    assert(math.abs(v1 - 0.61621768737322) < EPS)\n    p2, v2, s2 = step(0.5, d, f, p1, v1)\n    assert(not s2 and math.abs(p2 - 0.98982212901474) < EPS)\n    assert(math.abs(v2 - -0.23383824515613) < EPS)\n    d = 1.5\n    p1, v1, s1 = step(0.5, d, f, 0, 0)\n    assert(not s1 and math.abs(p1 - 0.75020554281012) < EPS)\n    assert(math.abs(v1 - 0.60014052697326) < EPS)\n    p2, v2, s2 = step(0.5, d, f, p1, v1)\n    assert(not s2 and math.abs(p2 - 0.92474819921701) < EPS)\n    assert(math.abs(v2 - 0.1806013825691) < EPS)\n    d, f = 1, 2\n    p1, v1, s1 = step(0.5, d, f, 0, 0)\n    assert(not s1 and math.abs(p1 - 0.98639906853443) < EPS)\n    assert(math.abs(v1 - 0.14744736802918) < EPS)\n    p2, v2, s2 = step(0.5, d, f, p1, v1)\n    assert(s2 and math.abs(p2 - 0.99995268942114) < EPS) -- sleeps\n    assert(math.abs(v2 - 0.00055069903147113) < EPS)\n\nend\n_self_test()\n\n-- exports\nSpr.step = step\nif Environment and Environment.IsServer() then\n    Spr = {step = step}\nend\nreturn Spr"
      }
    }
    Assets {
      Id: 4739659780833170311
      Name: "_Snippets"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    Lua 5.3 bits, little snippets and notes\n    * https://www.ilikebigbits.com/2015_03_04_plane_from_points.html\n    * What in C is (i % N) in Lua must become ((i-1)%N + 1).\n    * [de]serialize set of ints: utf8.char <-> utf8.codepoint. Max int = 2^21 (~2E+6).\n    * TODO: For inspiration: https://github.com/rxi/lume/blob/master/lume.lua\n    * math.random :: (nil) -> [0,1) | (a:int, b:int) -> [a,b] | (n:int) -> [1, n]\n    * TODO: pure lua xoshiro256\n--]]\n\nlocal abs = math.abs\n\nlocal CORE_ENV = CoreString and CoreMath\n\nlocal snippets = {}\n\nlocal clock do\n    if not CORE_ENV then\n        local ok, socket = pcall(require, \"socket\")\n        clock = ok and socket.gettime or os.clock\n    else\n        clock = os.clock\n    end\nend\nsnippets.clock = clock\n\n-- timestamps\nlocal os_time, os_date = os.time, os.date\nlocal function utc_timestamp()\n    return os_time(os_date\"!*t\")\nend\n\nlocal function format_timestamp(timestamp)\n    local d = os_date(\"!*t\", timestamp)\n    return string.format(\"%04d-%02d-%02d %02d:%02d:%02d\", d.year, d.month, d.day, d.hour, d.min, d.sec)\nend\nsnippets.utc_timestamp = utc_timestamp\nsnippets.format_timestamp = format_timestamp\n\n\n-- ZigZag encoding for negative integers\n-- https://en.wikipedia.org/wiki/Variable-length_quantity#Zigzag_encoding\nlocal function zigzag_encode(i)\n    assert(abs(i) < 0x80000000, \"abs(i) >= 2^31\") -- 2^31\n    return (i << 1 & 0xFFFFFFFF) ~ (i >> 31 & 0xFFFFFFFF)\nend\n\nlocal function zigzag_decode(i)\n    return (i >> 1) ~ -(i & 1)\nend\n\nsnippets.zigzag_encode = zigzag_encode\nsnippets.zigzag_decode = zigzag_decode\n\n\n-- Table optimizations\n-- ar_swap_remove: remove and swap with last element of array, O(1) and 10x faster then table.remove\nfunction snippets.ar_swap_remove(ar, idx)\n    local n = #ar\n    local res = ar[idx]\n    ar[idx] = ar[n]\n    ar[n] = nil\n    return res\nend\n\nfunction snippets.table_clear(t)\n    -- NOTE: idiomatic way to `traverse & modify` table (`pairs` can cause errors)\n    local k, v = next(t)\n    while v ~= nil do\n        t[k] = nil\n        -- use k, v and modify table here ...\n        k, v = next(t)\n    end\nend\n\nfunction snippets.ar_clear(ar)\n    local n = #ar\n    for i=n, 1, -1 do ar[i] = nil end\nend\n\n-- pythonic uniform\nlocal function uniform(a, b)\n    assert(a < b, \"empty interval\")\n    return a + (b-a)*math.random()\nend\n\n-- https://eli.thegreenplace.net/2010/01/22/weighted-random-generation-in-python\n-- NOTE: sum * math.random() is biased, in practice use xoshiro256 with unbiased projection\nfunction snippets.weightedchoice(t)\n    local sum = 0\n    for _, w in pairs(t) do sum = sum + w end\n    local rnd = uniform(0, sum)\n    for k, w in pairs(t) do\n        rnd = rnd - w\n        if rnd < 0 then return k end\n    end\nend\n\n\ndo\n    local NIBBLES = {[0]=\n        \"0000\", \"0001\", \"0010\", \"0011\",\n        \"0100\", \"0101\", \"0110\", \"0111\",\n        \"1000\", \"1001\", \"1010\", \"1011\",\n        \"1100\", \"1101\", \"1110\", \"1111\",\n    }\n\n    -- converts integer to binary string\n    function snippets.bitstr(v, sep, width, out)\n        assert(math.type(v) == \"integer\")\n        width = width or 32\n        assert(math.type(width) == \"integer\" and width%8 == 0, \"`width` should be 8, 16, 24, 32 or 64\")\n        sep, out = sep or \' \', out or {}\n        for b=(width//8 - 1), 0, -1 do\n            local byte = v >> 8*b & 0xFF\n            out[#out+1] = NIBBLES[byte >> 4 & 0xF]\n            out[#out+1] = NIBBLES[byte & 0xF]\n        end\n        return table.concat(out, sep)\n    end\nend\n\n-- measure the time and memory consumption of the thunk execution\nlocal function perfn(tag, times, thunk)\n    if not CORE_ENV then\n        collectgarbage(\"collect\")\n        collectgarbage(\"stop\")\n    end\n    local m1 = collectgarbage(\"count\")\n    local t1 = clock()\n    local result = nil\n    for i = 1, times do\n        result = thunk()\n    end\n    local t2 = clock()\n    local m2 = collectgarbage(\"count\")\n    if not CORE_ENV then\n        collectgarbage(\"restart\")\n    end\n    local tmstr = string.format(\"time: %0.4fs mem: %0.2fK\", t2 - t1, m2-m1)\n    if times <= 1 then\n        print(\"REPF:\", tag, tmstr)\n    else\n        print(string.format(\"PERF: %d\", times), tag, tmstr)\n    end\n    return result\nend\n\n-- exports\nfunction snippets.perf(tag, thunk)\n    return perfn(tag, 1, thunk)\nend\nsnippets.perfn = perfn\n\n-- https://community.khronos.org/t/zoom-to-fit-screen/59857/12\nfunction snippets.fitSphereToCamera(r, fov)\n    local scr = UI.GetScreenSize()\n    local halfMinFov = 0.5 * math.rad(fov)\n    local aspect = scr.x/scr.y\n    if aspect < 1 then\n        halfMinFov = math.atan(aspect * math.tan(halfMinFov))\n    end\n    return r / math.sin(halfMinFov)\nend\n\n-- assumes obj attached to local view (in Core sence)\nfunction snippets.ScreenPosition(obj, w3d, w2d, fov, x, y, tocam)\n    local res = UI.GetScreenSize()\n    local wx, wy = res.x, res.y\n    fov, x, y = fov or 90, x or wx//2, y or wy//2\n    local xf = math.tan(fov*math.pi/360)\n    local yf = xf * wy / wx\n    local depth = 0.5*w3d/w2d*wx/xf\n    local xo = xf*depth*(x/wx*2 - 1)\n    local yo = -yf*depth*(y/wy*2 - 1)\n    local offset = Vector3.New(depth, xo, yo)\n    obj:SetPosition(offset)\n    if tocam then\n        obj:SetRotation(Rotation.New(-offset, Vector3.UP))\n    end\nend\n\n-- table deepcopy from lua wiki\nlocal function deepcopy(orig)\n    local orig_type = type(orig)\n    local copy\n    if orig_type == \'table\' then\n        copy = {}\n        for orig_key, orig_value in next, orig, nil do\n            copy[deepcopy(orig_key)] = deepcopy(orig_value)\n        end\n        setmetatable(copy, deepcopy(getmetatable(orig)))\n    elseif orig_type == \'userdata\' then\n        local new = orig.New or orig.new -- TODO: should we allow shared references to CoreObjects?\n        assert(new, \"there is no copy constructor for `userdata`\")\n        copy = new(orig)\n    else -- number, string, boolean, etc\n        copy = orig\n    end\n    return copy\nend\nsnippets.deepcopy = deepcopy\n\n\n-- pass value to observer before subscribe, like Rx\'s subject\nfunction snippets.Subject(obj, networkedProperty, callback)\n    assert(CORE_ENV)\n    local wrapped = function(coreObject, propertyName)\n        if networkedProperty == propertyName then\n             callback(coreObject:GetCustomProperty(networkedProperty))\n        end\n    end\n    wrapped(obj, networkedProperty)\n    return obj.networkedPropertyChangedEvent:Connect(wrapped)\nend\n\nreturn snippets"
      }
    }
    Assets {
      Id: 5070080147057503107
      Name: "_Ascii85"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    Ported to Lua 5.3 by https://github.com/zoon\n    --\n    lascii85.c\n    ascii85 encoding and decoding for Lua 5.2\n    Luiz Henrique de Figueiredo <lhf@tecgraf.puc-rio.br>\n    27 Sep 2012 19:36:45\n    This code is hereby placed in the public domain.\n\n    NOTES:\n    https://en.wikipedia.org/wiki/Ascii85\n    When encoding, each group of 4 bytes is taken as a 32-bit binary number, most significant byte first.\n    This is converted, by repeatedly dividing by 85 and taking the remainder, into 5 radix-85 digits.\n    Then each digit (most significant first) is encoded as an ASCII printable character by adding 33 to it,\n    giving the ASCII characters 33 (\"!\") through 117 (\"u\").\n    Because all-zero data is quite common, an exception is made for the sake of data compression,\n    and an all-zero group is encoded as a single character \"z\" instead of \"!!!!!\".\n]]\n\nlocal ascii85 = {}\nascii85.__index = ascii85\n\nlocal pack, byte, char, ult = string.pack, string.byte, string.char, math.ult\n\nlocal function decode(n, c1, c2, c3, c4, c5)\n    local tuple = c5 + 85*(c4 + 85*(c3 + 85*(c2 + 85*c1)))\n    -- note that string.pack doing endian conversion\n    if n == 5 then return pack(\">I4\", tuple) end\n    if n == 4 then return pack(\">I3\", tuple >> 8) end\n    if n == 3 then return pack(\">I2\", tuple >> 16) end\n    if n == 2 then return pack(\"B\", tuple >> 24) end\nend\n\nlocal P851 = 85\nlocal P852 = 85*85\nlocal P853 = 85*85*85\nlocal P854 = 85*85*85*85\n\nlocal function encode(n, c1, c2, c3, c4)\n    c2, c3, c4 = c2 or 0, c3 or 0, c4 or 0\n    local tuple = c4 + 256*(c3 + 256*(c2 + 256*c1))\n    if tuple == 0 and n == 4 then return \'z\' end\n    local s0 = 33 + tuple // P854 % 85\n    if n == 0 then return char(s0) end\n    local s1 = 33 + tuple // P853 % 85\n    if n == 1 then return char(s0, s1) end\n    local s2 = 33 + tuple // P852 % 85\n    if n == 2 then return char(s0, s1, s2) end\n    local s3 = 33 + tuple // P851 % 85\n    if n == 3 then return char(s0, s1, s2, s3) end\n    local s4 = 33 + tuple % 85\n    if n == 4 then return char(s0, s1, s2, s3, s4) end\nend\n\nlocal function enc32(u32)\n    assert(ult(u32, 0xFFFFFFFF + 1), \"arg out of limit\")\n    local e = encode(4, u32 & 0xFF, (u32 >> 8) & 0xFF, (u32 >> 16) & 0xFF, (u32 >> 24) & 0xFF)\n    return e ~= \"z\" and e or \"!!!!!\" -- \'z\' abbrevation is not allowed for encoding numbers\nend\n\nlocal function enc24(u24)\n    assert(ult(u24, 0xFFFFFF + 1), \"arg out of limit\")\n    return encode(3, u24 & 0xFF, (u24 >> 8) & 0xFF, (u24 >> 16) & 0xFF)\nend\n\nlocal function enc16(u16)\n    assert(ult(u16, 0xFFFF + 1), \"arg out of limit\")\n    return encode(2, u16 & 0xFF, (u16 >> 8) & 0xFF)\nend\n\nlocal function enc8(u8)\n    assert(ult(u8, 0xFF+1), \"arg out of limit\")\n    return encode(1, u8)\nend\n\n-- (string, first) -> uint32, (next | nil)\nlocal function dec32(s, i)\n    i = i or 1\n    assert(#s >= i + 4)\n    local next = i + 5 < #s and i + 5 or nil\n    local c1, c2, c3, c4, c5 = byte(s, i, i + 4)\n    c1, c2, c3, c4, c5 = c1 - 33, c2 - 33, c3 - 33, c4 - 33, c5 - 33\n    local t = c5 + 85*(c4 + 85*(c3 + 85*(c2 + 85*c1)))\n    return t >> 24 & 0xFF | t >> 8 & 0xFF00 | t << 8 & 0xFF0000 | t << 24 & 0xFF000000, next\nend\n\nlocal function dec24(s, i)\n    i = i or 1\n    -- assert(#s >= i + 3)\n    local next = i + 4 < #s and i + 4 or nil\n    local c1, c2, c3, c4 = byte(s, i, i + 3)\n    c1, c2, c3, c4 = c1 - 33, c2 - 33, c3 - 33, c4 - 33\n    local t = 85*(1 + c4 + 85*(c3 + 85*(c2 + 85*c1)))\n    return t >> 24 & 0xFF | t >> 8 & 0xFF00 | t << 8 & 0xFF0000, next\nend\n\nlocal function dec16(s, i)\n    i = i or 1\n    -- assert(#s >= i + 2)\n    local next = i + 3 < #s and i + 3 or nil\n    local c1, c2, c3 = byte(s, i, i + 2)\n    c1, c2, c3 = c1 - 33, c2 - 33, c3 - 33\n    local t = P852*(1 + c3 + 85*(c2 + 85*c1))\n    return t >> 24 & 0xFF | t >> 8 & 0xFF00, next\nend\n\nlocal function dec8(s, i)\n    i = i or 1\n    -- assert(#s >= i + 1)\n    local next = i + 2 < #s and i + 2 or nil\n    local c1, c2 = byte(s, i, i + 1)\n    c1, c2 = c1 - 33, c2 - 33\n    local t = P853*(1 + c2 + 85*c1)\n    return t >> 24 & 0xFF, next\nend\n\nlocal function trim_guards(s, guarded)\n    local first, last = 1, #s\n    if guarded then\n        -- check for \'<~ ~>\' guards and trim them\n        local idx1, idx2 = s:find(\'<~\', 1, true)\n        if idx1 then\n            idx1 = idx2 + 1\n            idx2 = s:find(\'~>\', idx1, true)\n            if idx2 then\n                repeat\n                    idx2 = idx2 - 1 -- trim \'~\' and any whitespace before\n                until byte(s, idx2) >= 33\n                first, last = idx1, idx2\n            else\n                error(\"ascii85 - unbalanced \'<~\' and \'~>\'\")\n            end\n        end\n    end\n    return first, last\nend\n\n-- Encodes a string to Ascii85.\n-- @param `s` data string to be encoded.\n-- @param `[guarded]` - should be truthy if you want the encoded string to be \'<~ ~>\' guarded.\n-- @return Ascii85-encoded string.\nfunction ascii85.encode(s, guarded)\n    local out = {}\n    local i = 1\n    if guarded then out[i], i = \"<~\", i + 1 end\n    local n = #s // 4\n    local si = 1\n    for _=1, n do\n        out[i], i, si = encode(4, byte(s, si, si + 3)) , i + 1, si + 4\n    end\n    local tail = #s % 4\n    if tail == 1 then\n        out[i], i = encode(1, byte(s, si)), i + 1\n    elseif tail == 2 then\n        out[i], i = encode(2, byte(s, si, si + 1)), i + 1\n    elseif tail == 3 then\n        out[i], i = encode(3, byte(s, si, si + 2)), i + 1\n    end\n    if guarded then out[i], i = \"~>\", i + 1 end\n    return table.concat(out)\nend\n\n-- Decodes Ascii85-encoded string.\n-- @param `s` Ascii85-encoded string.\n-- @param `[guarded]` - should be truthy if the encoded string *can be* \'<~ ~>\' guarded.\n-- @return Decoded data string.\nfunction ascii85.decode(s, guarded)\n    local first, last = trim_guards(s, guarded)\n    local out = {}\n    local i = 1\n    local t = {0, 0, 0, 0, 0}\n    local n = 0\n    for sidx=first, last do\n        local c = byte(s, sidx)\n        if c >= 33 and c <= 117 then\n            t[n + 1], n = c - 33, n + 1\n            if n == 5 then\n                out[i], n, i = decode(n, t[1], t[2], t[3], t[4], t[5]), 0, i + 1\n            elseif sidx == last then -- we done, cleaning tails\n                if n == 2 then\n                    out[i] = decode(2, t[1], t[2], 85, 0, 0)\n                elseif n == 3 then\n                    out[i] = decode(3, t[1], t[2], t[3], 85, 0)\n                elseif n == 4 then\n                    out[i] = decode(4, t[1], t[2], t[3], t[4], 85)\n                end\n            end\n        elseif c == 122 --[[z]] then\n            out[i], i = \"\\0\\0\\0\\0\", i + 1\n            assert(sidx ~= last or n == 0)\n        -- else: skip all another chars\n        end\n    end\n    return table.concat(out)\nend\n\nlocal function _self_test()\n    local data = {\n        [\"\"] = \"\",\n        [\"A\"]=\"5l\",\n        [\"BC\"]=\"6:1\",\n        [\"DEF\"]=\"6q\'Q\",\n        [\"*?!@\"]=\".R,(A\",\n        [\"Man \"]=\"9jqo^\",\n        [\"7904 (base10)\"]=\"2`WQK+=L]-F(I\'[.0\",\n        [\"1337lEEt\\0\\0\\0\\0\"]=\"0f(UECdgd7z\",\n    }\n    for r,e in pairs(data) do\n        assert(ascii85.encode(r) == e, \"err encode: \" .. r)\n        assert(ascii85.decode(e) == r, \"err decode: \" .. r)\n    end\n\n    -- limits\n    for _,v in pairs{\n            {0, 0, 0, 0, 0},\n            {0xF, 0xFF, 0xFFF, 0xFFFF}\n        } do\n        local u8, u16, u24, u32 = table.unpack(v)\n        local eu8 = enc8(u8)\n        assert(#eu8 == 2)\n        assert(dec8(eu8) == u8)\n        local eu16 = enc16(u16)\n        assert(#eu16 == 3)\n        assert(dec16(eu16) == u16)\n        local eu24 = enc24(u24)\n        assert(#eu24 == 4)\n        assert(dec24(eu24) == u24)\n        local eu32 = enc32(u32)\n        assert(#eu32 == 5)\n        assert(dec32(eu32) == u32)\n    end\n\n    -- random numbers\n    for i=1, 100 do\n        local u8 = math.random(0xFF)\n        local eu8 = enc8(u8)\n        assert(#eu8 == 2)\n        assert(dec8(eu8) == u8)\n        local u16 = math.random(0xFFFF)\n        local eu16 = enc16(u16)\n        assert(#eu16 == 3)\n        assert(dec16(eu16) == u16)\n        local u24 = math.random(0xFFFFFF)\n        local eu24 = enc24(u24)\n        assert(#eu24 == 4)\n        assert(dec24(eu24) == u24)\n        local u32 = math.random(0xFFFFFFFF)\n        local eu32 = enc32(u32)\n        assert(#eu32 == 5)\n        assert(dec32(eu32) == u32)\n    end\n    print(\"ascii85 -- ok\")\nend\n_self_test()\n\n-- extra aliases\nascii85.Encode = ascii85.encode\nascii85.Decode = ascii85.decode\n\n-- fixed width integer encoding\nascii85.enc8 = enc8\nascii85.enc16 = enc16\nascii85.enc24 = enc24\nascii85.enc32 = enc32\nascii85.dec8 = dec8\nascii85.dec16 = dec16\nascii85.dec24 = dec24\nascii85.dec32 = dec32\n\n-- extra aliases\nascii85.Encode6 = ascii85.enc8\nascii85.Dncode6 = ascii85.dec8\nascii85.Encode8 = ascii85.enc8\nascii85.Dncode8 = ascii85.dec8\nascii85.Encode12 = ascii85.enc16\nascii85.Dncode12 = ascii85.dec16\nascii85.Encode16 = ascii85.enc16\nascii85.Dncode16 = ascii85.dec16\nascii85.Encode24 = ascii85.enc24\nascii85.Dncode24 = ascii85.dec24\nascii85.Encode32 = ascii85.enc32\nascii85.Dncode32 = ascii85.dec32\n\nreturn ascii85"
      }
    }
    Assets {
      Id: 9544232931398361545
      Name: "_Base64"
      PlatformAssetType: 3
      TextAsset {
        Text: "-- The MIT Licence (MIT)\r\n-- Copyright (c) 2021 Andrew Zhilin (andrew.zhilin@gmail.com)\r\n\r\nlocal base64= {}\r\nlocal char, byte, gsub, find = string.char, string.byte, string.gsub, string.find\r\n-- symbols for ref: \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\'\r\nlocal PAD = string.byte(\'=\')\r\n\r\nlocal enc do\r\n    local ENC = {[0]=\r\n        0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\r\n        0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\r\n        0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\r\n        0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,\r\n        0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,\r\n        0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,\r\n        0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33,\r\n        0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2B, 0x2F,\r\n    }\r\n    -- pass data string to _enc\r\n    local _data = nil\r\n    -- caching lambda, it saves us ~100 bytes\r\n    -- unrolled for 36->48 chars, for big strings (> 1K) it gives 3-4x less garbage\r\n    local function _enc(x, y)\r\n        local data = _data -- pass data string to inner scope\r\n        -- 36 -> 48\r\n        if y - x == 36 then\r\n            local\r\n                a1, b1, c1, a2, b2, c2, a3, b3, c3,\r\n                a4, b4, c4, a5, b5, c5, a6, b6, c6,\r\n                a7, b7, c7, a8, b8, c8, a9, b9, c9,\r\n                aa, ba, ca, ab, bb, cb, ac, bc, cc = byte(data, x, x + 35)\r\n        return char(\r\n            ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], ENC[(b1&15)<<2|c1>>6], ENC[c1&63],\r\n            ENC[a2>>2], ENC[(a2&3)<<4|b2>>4], ENC[(b2&15)<<2|c2>>6], ENC[c2&63],\r\n            ENC[a3>>2], ENC[(a3&3)<<4|b3>>4], ENC[(b3&15)<<2|c3>>6], ENC[c3&63],\r\n            ENC[a4>>2], ENC[(a4&3)<<4|b4>>4], ENC[(b4&15)<<2|c4>>6], ENC[c4&63],\r\n            ENC[a5>>2], ENC[(a5&3)<<4|b5>>4], ENC[(b5&15)<<2|c5>>6], ENC[c5&63],\r\n            ENC[a6>>2], ENC[(a6&3)<<4|b6>>4], ENC[(b6&15)<<2|c6>>6], ENC[c6&63],\r\n            ENC[a7>>2], ENC[(a7&3)<<4|b7>>4], ENC[(b7&15)<<2|c7>>6], ENC[c7&63],\r\n            ENC[a8>>2], ENC[(a8&3)<<4|b8>>4], ENC[(b8&15)<<2|c8>>6], ENC[c8&63],\r\n            ENC[a9>>2], ENC[(a9&3)<<4|b9>>4], ENC[(b9&15)<<2|c9>>6], ENC[c9&63],\r\n            ENC[aa>>2], ENC[(aa&3)<<4|ba>>4], ENC[(ba&15)<<2|ca>>6], ENC[ca&63],\r\n            ENC[ab>>2], ENC[(ab&3)<<4|bb>>4], ENC[(bb&15)<<2|cb>>6], ENC[cb&63],\r\n            ENC[ac>>2], ENC[(ac&3)<<4|bc>>4], ENC[(bc&15)<<2|cc>>6], ENC[cc&63]\r\n        )\r\n        end\r\n\r\n        local out = {}\r\n        local a1, b1, c1, a2, b2, c2, a3, b3, c3\r\n        -- 9 -> 12\r\n        while x + 8 < y do\r\n            a1, b1, c1, a2, b2, c2, a3, b3, c3 = byte(data, x, x + 8)\r\n            out[#out+1] = char(\r\n                ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], ENC[(b1&15)<<2|c1>>6], ENC[c1&63],\r\n                ENC[a2>>2], ENC[(a2&3)<<4|b2>>4], ENC[(b2&15)<<2|c2>>6], ENC[c2&63],\r\n                ENC[a3>>2], ENC[(a3&3)<<4|b3>>4], ENC[(b3&15)<<2|c3>>6], ENC[c3&63]\r\n            )\r\n            x = x + 9\r\n        end\r\n        -- 3 -> 4\r\n        while x + 2 < y do\r\n            a1, b1, c1 = byte(data, x, x + 2)\r\n            out[#out+1] = char(ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], ENC[(b1&15)<<2|c1>>6], ENC[c1&63])\r\n            x = x + 3\r\n        end\r\n        -- tail: 1..2 -> 3..2 + padding\r\n        local n = y - x\r\n        if n == 2 then\r\n            a1, b1 = byte(data, x, x + 1)\r\n            c1 = 0\r\n            out[#out+1] = char(ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], ENC[(b1&15)<<2|c1>>6], PAD)\r\n        elseif n == 1 then\r\n            a1 = byte(data, x)\r\n            b1 = 0\r\n            out[#out+1] = char(ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], PAD, PAD)\r\n        end\r\n        return table.concat(out)\r\n    end\r\n\r\n    -- there is no limiting quantifier support in lua pattens ...\r\n    local OPT36 = \"()\" .. string.rep(\'.?\', 36) .. \"()\"\r\n    enc = function(data)\r\n        _data = data -- pass data to outer scope\r\n        return (gsub(_data, OPT36, _enc))\r\n    end\r\nend\r\n\r\nlocal dec do\r\n    local DEC = {\r\n        [0x41]=0x00, [0x42]=0x01, [0x43]=0x02, [0x44]=0x03, [0x45]=0x04, [0x46]=0x05, [0x47]=0x06, [0x48]=0x07,\r\n        [0x49]=0x08, [0x4A]=0x09, [0x4B]=0x0A, [0x4C]=0x0B, [0x4D]=0x0C, [0x4E]=0x0D, [0x4F]=0x0E, [0x50]=0x0F,\r\n        [0x51]=0x10, [0x52]=0x11, [0x53]=0x12, [0x54]=0x13, [0x55]=0x14, [0x56]=0x15, [0x57]=0x16, [0x58]=0x17,\r\n        [0x59]=0x18, [0x5A]=0x19, [0x61]=0x1A, [0x62]=0x1B, [0x63]=0x1C, [0x64]=0x1D, [0x65]=0x1E, [0x66]=0x1F,\r\n        [0x67]=0x20, [0x68]=0x21, [0x69]=0x22, [0x6A]=0x23, [0x6B]=0x24, [0x6C]=0x25, [0x6D]=0x26, [0x6E]=0x27,\r\n        [0x6F]=0x28, [0x70]=0x29, [0x71]=0x2A, [0x72]=0x2B, [0x73]=0x2C, [0x74]=0x2D, [0x75]=0x2E, [0x76]=0x2F,\r\n        [0x77]=0x30, [0x78]=0x31, [0x79]=0x32, [0x7A]=0x33, [0x30]=0x34, [0x31]=0x35, [0x32]=0x36, [0x33]=0x37,\r\n        [0x34]=0x38, [0x35]=0x39, [0x36]=0x3A, [0x37]=0x3B, [0x38]=0x3C, [0x39]=0x3D, [0x2B]=0x3E, [0x2F]=0x3F,\r\n    }\r\n\r\n    local _b64str = nil\r\n    -- caching lambda, it saves us ~100 bytes\r\n    -- unrolled for 48->36 chars, for big strings (> 1K) it gives 3-4x less garbage\r\n    local function _dec(x, y)\r\n        local b64str = _b64str\r\n        -- 48 -> 36\r\n        if y - x == 48 and byte(b64str, x + 47) ~= PAD then\r\n            local\r\n                a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3,\r\n                a4, b4, c4, d4, a5, b5, c5, d5, a6, b6, c6, d6,\r\n                a7, b7, c7, d7, a8, b8, c8, d8, a9, b9, c9, d9,\r\n                aa, ba, ca, da, ab, bb, cb, db, ac, bc, cc, dc =\r\n                    byte(b64str, x, x + 47)\r\n                -- decode all\r\n                a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3,\r\n                a4, b4, c4, d4, a5, b5, c5, d5, a6, b6, c6, d6,\r\n                a7, b7, c7, d7, a8, b8, c8, d8, a9, b9, c9, d9,\r\n                aa, ba, ca, da, ab, bb, cb, db, ac, bc, cc, dc =\r\n                    DEC[a1], DEC[b1], DEC[c1], DEC[d1], DEC[a2], DEC[b2], DEC[c2], DEC[d2],\r\n                    DEC[a3], DEC[b3], DEC[c3], DEC[d3], DEC[a4], DEC[b4], DEC[c4], DEC[d4],\r\n                    DEC[a5], DEC[b5], DEC[c5], DEC[d5], DEC[a6], DEC[b6], DEC[c6], DEC[d6],\r\n                    DEC[a7], DEC[b7], DEC[c7], DEC[d7], DEC[a8], DEC[b8], DEC[c8], DEC[d8],\r\n                    DEC[a9], DEC[b9], DEC[c9], DEC[d9], DEC[aa], DEC[ba], DEC[ca], DEC[da],\r\n                    DEC[ab], DEC[bb], DEC[cb], DEC[db], DEC[ac], DEC[bc], DEC[cc], DEC[dc]\r\n            return char(\r\n                a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F,\r\n                a2<<2&0xFC|b2>>4&0x03, b2<<4&0xF0|c2>>2&0x0F, c2<<6&0xC0|d2>>0&0x3F,\r\n                a3<<2&0xFC|b3>>4&0x03, b3<<4&0xF0|c3>>2&0x0F, c3<<6&0xC0|d3>>0&0x3F,\r\n                a4<<2&0xFC|b4>>4&0x03, b4<<4&0xF0|c4>>2&0x0F, c4<<6&0xC0|d4>>0&0x3F,\r\n                a5<<2&0xFC|b5>>4&0x03, b5<<4&0xF0|c5>>2&0x0F, c5<<6&0xC0|d5>>0&0x3F,\r\n                a6<<2&0xFC|b6>>4&0x03, b6<<4&0xF0|c6>>2&0x0F, c6<<6&0xC0|d6>>0&0x3F,\r\n                a7<<2&0xFC|b7>>4&0x03, b7<<4&0xF0|c7>>2&0x0F, c7<<6&0xC0|d7>>0&0x3F,\r\n                a8<<2&0xFC|b8>>4&0x03, b8<<4&0xF0|c8>>2&0x0F, c8<<6&0xC0|d8>>0&0x3F,\r\n                a9<<2&0xFC|b9>>4&0x03, b9<<4&0xF0|c9>>2&0x0F, c9<<6&0xC0|d9>>0&0x3F,\r\n                aa<<2&0xFC|ba>>4&0x03, ba<<4&0xF0|ca>>2&0x0F, ca<<6&0xC0|da>>0&0x3F,\r\n                ab<<2&0xFC|bb>>4&0x03, bb<<4&0xF0|cb>>2&0x0F, cb<<6&0xC0|db>>0&0x3F,\r\n                ac<<2&0xFC|bc>>4&0x03, bc<<4&0xF0|cc>>2&0x0F, cc<<6&0xC0|dc>>0&0x3F\r\n            )\r\n        end\r\n\r\n        local out = {}\r\n        local a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3\r\n        -- 12 -> 9\r\n        while x + 11 < y - 4 do -- all but last 4\r\n            a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3 = byte(b64str, x, x + 11)\r\n            a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3 =\r\n                DEC[a1], DEC[b1], DEC[c1], DEC[d1], DEC[a2], DEC[b2],\r\n                DEC[c2], DEC[d2], DEC[a3], DEC[b3], DEC[c3], DEC[d3]\r\n            out[#out+1] = char(\r\n                a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F,\r\n                a2<<2&0xFC|b2>>4&0x03, b2<<4&0xF0|c2>>2&0x0F, c2<<6&0xC0|d2>>0&0x3F,\r\n                a3<<2&0xFC|b3>>4&0x03, b3<<4&0xF0|c3>>2&0x0F, c3<<6&0xC0|d3>>0&0x3F\r\n            )\r\n            x = x + 12\r\n        end\r\n        -- 4 -> 3\r\n        while x + 3 < y - 4 do -- all but last 4\r\n            a1, b1, c1, d1 = byte(b64str, x, x + 3)\r\n            a1, b1, c1, d1 = DEC[a1], DEC[b1], DEC[c1], DEC[d1]\r\n            out[#out+1] = char(a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F)\r\n            x = x + 4\r\n        end\r\n        -- last 4 -> 1..3\r\n        a1, b1, c1, d1 = byte(b64str, x, x + 3)\r\n        a1, b1, c1, d1 = DEC[a1], DEC[b1], DEC[c1], DEC[d1]\r\n        local n = c1 and d1 and 3 or c1 and 2 or 1\r\n        if n == 3 then\r\n            out[#out+1] = char(a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F)\r\n        elseif n == 2 then\r\n            out[#out+1] = char(a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F)\r\n        elseif n == 1 then\r\n            out[#out+1] = char(a1<<2&0xFC|b1>>4&0x03)\r\n        end\r\n        return table.concat(out)\r\n    end\r\n\r\n    local OPT48 = \"()\" .. string.rep(\'.?\', 48) .. \"()\"\r\n    dec = function (b64str)\r\n        if #b64str == 0 then return \"\" end\r\n        -- remove whitespace if any\r\n        if find(b64str, \"%s+\") then b64str = gsub(b64str, \"%s+\", \"\") end\r\n        assert(#b64str%4 == 0, \"invalid encoding: input length is not divisible by 4\")\r\n        _b64str = b64str -- pass to outer scope\r\n        return (gsub(b64str, OPT48, _dec)) -- coerce to 1 result\r\n    end\r\n\r\n    ----------------------------------\r\n    -- partial decode utils:\r\n    ----------------------------------\r\n\r\n    local function _test(prefix, ...)\r\n        assert(prefix and #prefix <= 3, \"max length of prefix should be 3\")\r\n        assert(select(\"#\", ...) == 3)\r\n        for i = 1, #prefix do\r\n            if byte(prefix, i) ~= select(i, ...) then return false end\r\n        end\r\n        return true\r\n    end\r\n\r\n    -- dec3 :: base64 -> byte1, byte2, byte3\r\n    local function dec3(s64)\r\n        assert(s64 and #s64 > 4, \"length of encoded string should be > 4\")\r\n        local a1, b1, c1, d1 = byte(s64, 1, 4)\r\n        a1, b1, c1, d1 = DEC[a1], DEC[b1], DEC[c1], DEC[d1]\r\n        return a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F\r\n    end\r\n\r\n    local function test_prefix(s64, prefix)\r\n        return _test(prefix, dec3(s64))\r\n    end\r\n\r\n    -- select_prefix :: base64, prefix1, prefix2, ...  -> index\r\n    local function select_prefix(s64, ...)\r\n        local n = select(\"#\", ...)\r\n        local b1, b2, b3 = dec3(s64)\r\n        for i = 1, n do\r\n            if _test(select(i, ...), b1, b2, b3) then return i end\r\n        end\r\n    end\r\n\r\n    -- exports\r\n    base64.dec3 = dec3\r\n    base64.test_prefix = test_prefix\r\n    base64.select_prefix = select_prefix\r\nend\r\n\r\nlocal function _self_test()\r\n    local data = {\r\n        [\"\"] = \"\",\r\n        [\"A\"]=\"QQ==\",\r\n        [\"BC\"]=\"QkM=\",\r\n        [\"DEF\"]=\"REVG\",\r\n        [\"*?!@\"]=\"Kj8hQA==\",\r\n        [\"Man \"]=\"TWFuIA==\",\r\n        [\"7904 (base10)\"]=\"NzkwNCAoYmFzZTEwKQ==\",\r\n        [\"1337lEEt\\0\\0\\0\\0\"]=\"MTMzN2xFRXQAAAAA\",\r\n        [\"Use our super handy online tool to decode or encode your data.\"] =\r\n            \"VXNlIG91ciBzdXBlciBoYW5keSBvbmxpbmUgdG9vbCB0byBkZWNvZGUgb3IgZW5jb2RlIHlvdXIgZGF0YS4=\",\r\n        [\"<D\\254\"] = \"PET+\"\r\n    }\r\n    for r, e in pairs(data) do\r\n        assert(enc(r) == e, string.format(\"err encode: %q -> %q\", r, enc(r)))\r\n        assert(dec(e) == r, string.format(\"err decode: %q -> %q\", r, dec(e)))\r\n    end\r\n\r\n    local s64 = enc(\"7904 (base10)\")\r\n    assert(base64.test_prefix(s64, \"7\"))\r\n    assert(base64.test_prefix(s64, \"79\"))\r\n    assert(base64.test_prefix(s64, \"790\"))\r\n    assert(base64.select_prefix(s64, \"AA\", \"BB\", \"79\", \"85\") == 3)\r\n\r\n    -- test bugfix (dec returned 2 value)\r\n    local id = \"eec0239c0d644f5bb9f59779307edb17\"\r\n    local fmt = \"c1 z c3\"\r\n    local x = string.pack(fmt, \"$\", id, \"C09\")\r\n    assert(select(2, string.unpack(fmt, x)) == id)\r\n    assert(select(2, string.unpack(fmt, dec(enc(x)))) == id)\r\n\r\n    --\r\n    print(\'base64 -- ok\')\r\nend\r\n\r\n_self_test()\r\n\r\n-- exports\r\nbase64.encode = enc\r\nbase64.decode = dec\r\n\r\nreturn base64"
      }
    }
    Assets {
      Id: 17918387935289379105
      Name: "_Spring"
      PlatformAssetType: 3
      TextAsset {
        Text: "-- Spring solver\n--\n-- Copyright 2018 Parker Stebbins (parker@fractality.io)\n-- github.com/Fraktality/Spring\n-- Distributed under the MIT license; see full notice at the end of this file.\n\nlocal Spring = {} do\n\tSpring.__index = Spring\n\n\tlocal pi = math.pi\n\tlocal exp = math.exp\n\tlocal sin = math.sin\n\tlocal cos = math.cos\n\tlocal sqrt = math.sqrt\n\n\tlocal EPS = 1e-4\n\n\tfunction Spring.New(dampingRatio, frequency, position)\n\t\tassert(type(dampingRatio) == \"number\")\n\t\tassert(type(frequency) == \"number\")\n\t\tassert(dampingRatio*frequency >= 0, \"Spring does not converge\")\n\n\t\treturn setmetatable({\n\t\t\td = dampingRatio,\n\t\t\tf = frequency,\n\t\t\tg = position,\n\t\t\tp = position,\n\t\t\tv = position*0, -- Match the original vector type\n\t\t}, Spring)\n\tend\n\n\tfunction Spring:SetGoal(newGoal)\n\t\tself.g = newGoal\n\tend\n\n\tfunction Spring:GetPosition()\n\t\treturn self.p\n\tend\n\n\tfunction Spring:GetVelocity()\n\t\treturn self.v\n\tend\n\n\tfunction Spring:Impulse(velocity)\n\t\tself.v = self.v + velocity\n\tend\n\n\tfunction Spring:Update(dt)\n\t\tlocal d = self.d\n\t\tlocal f = self.f*2*pi\n\t\tlocal g = self.g\n\t\tlocal p0 = self.p\n\t\tlocal v0 = self.v\n\n\t\tlocal offset = p0 - g\n\t\tlocal decay = exp(-d*f*dt)\n\n\t\tlocal p1, v1\n\n\t\tif d == 1 then -- Critically damped\n\t\t\tp1 = (offset*(1 + f*dt) + v0*dt)*decay + g\n\t\t\tv1 = (v0*(1 - f*dt) - offset*(f*f*dt))*decay\n\n\t\telseif d < 1 then -- Underdamped\n\t\t\tlocal c = sqrt(1 - d*d)\n\n\t\t\tlocal i = cos(f*c*dt)\n\t\t\tlocal j = sin(f*c*dt)\n\n\t\t\t-- Damping ratios approaching 1 can cause division by small numbers.\n\t\t\t-- To fix that, group terms around z=j/c and find an approximation for z.\n\t\t\t-- Start with the definition of z:\n\t\t\t--    z = sin(dt*f*c)/c\n\t\t\t-- Substitute a=dt*f:\n\t\t\t--    z = sin(a*c)/c\n\t\t\t-- Take the Maclaurin expansion of z with respect to c:\n\t\t\t--    z = a - (a^3*c^2)/6 + (a^5*c^4)/120 + O(c^6)\n\t\t\t--    z \342\211\210 a - (a^3*c^2)/6 + (a^5*c^4)/120\n\t\t\t-- Rewrite in Horner form:\n\t\t\t--    z \342\211\210 a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6\n\n\t\t\tlocal z\n\t\t\tif c > EPS then\n\t\t\t\tz = j/c\n\t\t\telse\n\t\t\t\tlocal a = dt*f\n\t\t\t\tz = a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6\n\t\t\tend\n\n\t\t\t-- Frequencies approaching 0 present a similar problem.\n\t\t\t-- We want an approximation for y as f approaches 0, where:\n\t\t\t--    y = sin(dt*f*c)/(f*c)\n\t\t\t-- Substitute b=dt*c:\n\t\t\t--    y = sin(b*c)/b\n\t\t\t-- Now reapply the process from z.\n\n\t\t\tlocal y\n\t\t\tif f*c > EPS then\n\t\t\t\ty = j/(f*c)\n\t\t\telse\n\t\t\t\tlocal b = f*c\n\t\t\t\ty = dt + ((dt*dt)*(b*b)*(b*b)/20 - b*b)*(dt*dt*dt)/6\n\t\t\tend\n\n\t\t\tp1 = (offset*(i + d*z) + v0*y)*decay + g\n\t\t\tv1 = (v0*(i - z*d) - offset*(z*f))*decay\n\n\t\telse -- Overdamped\n\t\t\tlocal c = sqrt(d*d - 1)\n\n\t\t\tlocal r1 = -f*(d - c)\n\t\t\tlocal r2 = -f*(d + c)\n\n\t\t\tlocal co2 = (v0 - offset*r1)/(2*f*c)\n\t\t\tlocal co1 = offset - co2\n\n\t\t\tlocal e1 = co1*exp(r1*dt)\n\t\t\tlocal e2 = co2*exp(r2*dt)\n\n\t\t\tp1 = e1 + e2 + g\n\t\t\tv1 = e1*r1 + e2*r2\n\t\tend\n\n\t\tself.p = p1\n\t\tself.v = v1\n\n\t\treturn p1\n\tend\nend\nreturn Spring\n"
      }
    }
    Assets {
      Id: 14454691258374778668
      Name: "_ReliableEvents"
      PlatformAssetType: 3
      TextAsset {
        Text: "local ReliableEvents = {}\r\nReliableEvents.__index = ReliableEvents\r\n\r\nlocal pack, unpack = table.pack, table.unpack\r\n\r\n-- simple queue from PIL\r\nlocal queue = {}\r\nqueue.__index = queue\r\nfunction queue.new()\r\n    return setmetatable({first=0, last=-1, q = {}}, queue)\r\nend\r\nfunction queue:empty()\r\n    return self.first > self.last\r\nend\r\nfunction queue:push(val)\r\n    local last = self.last + 1\r\n    self.last = last\r\n    self.q[last] = val\r\nend\r\nfunction queue:pop()\r\n    local first = self.first\r\n    local result = self.q[first]\r\n    self.q[first] = nil\r\n    self.first = first + 1\r\n    return result\r\nend\r\nfunction queue:peek()\r\n    return self.q[self.first]\r\nend\r\n\r\n-----------------------------------------------------------------------------\r\n-- Client-Server events\r\n-----------------------------------------------------------------------------\r\nlocal BroadcastFactory do\r\n\r\n    local txqueue = queue:new()\r\n    local FEWEST_WARNINGS_INTERVAL = 0.90 -- empirical constant\r\n\r\n    local function retry()\r\n        Task.Spawn(function()\r\n            while not txqueue:empty() do\r\n                local message = txqueue:peek()\r\n                local broadcast = Events[message.method]\r\n                local result, _ = broadcast(unpack(message))\r\n                if result == BroadcastEventResultCode.EXCEEDED_RATE_LIMIT then\r\n                    Task.Wait(FEWEST_WARNINGS_INTERVAL)\r\n                else\r\n                    txqueue:pop()\r\n                end\r\n            end\r\n        end)\r\n    end\r\n\r\n    local function _push_event(method, ...)\r\n        local event = pack(...)\r\n        event.method = method\r\n        txqueue:push(event)\r\n    end\r\n\r\n    BroadcastFactory = function(method)\r\n        return function (...)\r\n            local event = select(1, ...)\r\n            if not event or type(event) ~= \"string\" then\r\n                warn(\"Bad argument to brodcast\\n\" .. CoreDebug.GetStackTrace())\r\n                return\r\n            end\r\n            if txqueue:empty() then\r\n                local result, _ = Events[method](...)\r\n                if result == BroadcastEventResultCode.EXCEEDED_RATE_LIMIT then\r\n                    _push_event(method, ...)\r\n                    retry()\r\n                end\r\n            else\r\n                _push_event(method, ...)\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\n-----------------------------------------------------------------------------\r\n-- Local events\r\n-----------------------------------------------------------------------------\r\nlocal Broadcast do\r\n\r\n    local txqueue = queue:new()\r\n    local _in_trampoline = false\r\n\r\n    -- for the nested events, we broadcast them in breadth-first order\r\n    Broadcast = function(...)\r\n        local event = select(1, ...)\r\n        if not event or type(event) ~= \"string\" then\r\n            warn(\"Bad argument to brodcast\\n\" .. CoreDebug.GetStackTrace())\r\n            return\r\n        end\r\n        if not _in_trampoline then\r\n        _in_trampoline = true\r\n            Events.Broadcast(...)\r\n        else\r\n            txqueue:push(pack(...))\r\n            return -- !\r\n        end\r\n        while not txqueue:empty() do\r\n            local event = txqueue:pop()\r\n            Events.Broadcast(unpack(event))\r\n        end\r\n        _in_trampoline = false\r\n    end\r\nend\r\n\r\n-- exports\r\nReliableEvents.BroadcastToServer = BroadcastFactory(\"BroadcastToServer\")\r\nReliableEvents.BroadcastToPlayer = BroadcastFactory(\"BroadcastToPlayer\")\r\nReliableEvents.BroadcastToAllPlayers = BroadcastFactory(\"BroadcastToAllPlayers\")\r\nReliableEvents.Broadcast = Broadcast\r\n\r\n_test = function()\r\n    do -- test order of nested events\r\n        local out = {}\r\n        Events.Connect(\"_x_Test_A\", function()\r\n            ReliableEvents.Broadcast(\"_x_Test_B\", \"A\")\r\n            ReliableEvents.Broadcast(\"_x_Test_C\", \"A\")\r\n            out[#out+1] = \"A\"\r\n        end)\r\n        Events.Connect(\"_x_Test_B\", function()\r\n            ReliableEvents.Broadcast(\"_x_Test_C\", \"B\")\r\n            out[#out+1] = \"B\"\r\n        end)\r\n        Events.Connect(\"_x_Test_C\", function()\r\n            out[#out+1] = \"C\"\r\n        end)\r\n        ReliableEvents.Broadcast(\"_x_Test_A\")\r\n        assert(out[1] == \"A\" and out[2] == \"B\" and out[3] == \"C\" and out[4] == \"C\")\r\n    end\r\n    print(\"reliable events -- ok\")\r\nend\r\n\r\n_test()\r\n\r\nreturn ReliableEvents\r\n"
      }
    }
    Assets {
      Id: 9342788341295903362
      Name: "_PQmin"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    Min heap priority queue. Needs only `__le` metamethod to operate.\n    NOTE: It\'s x1.5 slower then naive array search for 100 entryes, but convinience is superb.\n--]]\n\nlocal PQmin = {}\nPQmin.__index = PQmin\n\nfunction PQmin.New()\n    return setmetatable({_n = 0, _pq= {}}, PQmin)\nend\n\nfunction PQmin:Peek()\n    return self._pq[1]\nend\n\nfunction PQmin:Count()\n    return self._n\nend\n\nfunction PQmin:IsEmpty()\n    return self._n == 0\nend\n\n-- for debugging\nfunction PQmin:_isMinHeap(k)\n    k = k or 1\n    if k > self._n then\n        return true\n    end\n    local left = 2*k\n    if left <= self._n and self._pq[left] < self._pq[k]then\n        return false\n    end\n    local right = left + 1\n    if right <= self._n and self._pq[right] < self._pq[k] then\n        return false\n    end\n    return self:_isMinHeap(left) and self:_isMinHeap(right)\nend\n\nlocal function swim(k, pq)\n    while true do\n        local parent = math.floor(k/2)\n        if k > 1 and pq[k] < pq[parent] then\n            local temp = pq[k]\n            pq[k] = pq[parent]\n            pq[parent] = temp\n            k = parent\n        else\n          break\n        end\n    end\nend\n\nfunction PQmin:Enqueue(el)\n    local n = self._n + 1\n    self._n = n\n    local pq = self._pq\n    table.insert(pq, n, el)\n    swim(n, pq)\n    -- assert(self:_isMinHeap())\n    return self\nend\n\nlocal function sink(n, pq)\n    local k = 1\n    while 2*k <= n do\n        local child = 2*k\n        if child < n and pq[child + 1] < pq[child] then\n            child = child + 1\n        end\n        if not (pq[child] < pq[k]) then\n            break\n        end\n        local temp = pq[k]\n        pq[k] = pq[child]\n        pq[child] = temp\n        k = child\n    end\nend\n\nfunction PQmin:Dequeue()\n    local n = self._n\n    if n == 0 then\n        return nil\n    end\n    local pq = self._pq\n    local result = pq[1]\n    pq[1], pq[n] = pq[n], nil\n    n = n - 1\n    sink(n, pq)\n    self._n = n\n    -- assert(self:_isMinHeap())\n    return result\nend\n\nfunction PQmin:Clear()\n    local n = self._n\n    if n == 0 then return end\n    for i = n, 1, -1 do\n        self._pq[i] = nil\n    end\n    assert(#self._pq == 0)\n    self._n = 0\nend\n\n-- some aliases\nPQmin.Push = PQmin.Enqueue\nPQmin.Pop = PQmin.Dequeue\n\nreturn PQmin"
      }
    }
    Assets {
      Id: 16283193609845389182
      Name: "_PQmax"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    Max heap priority queue. Needs only `__le` metamethod to operate.\n    NOTE: It\'s x1.5 slower then naive array search for 100 entryes, but convinience is superb.\n--]]\n\nlocal PQmax = {}\nPQmax.__index = PQmax\n\nfunction PQmax.New()\n    return setmetatable({_n = 0, _pq= {}}, PQmax)\nend\n\nfunction PQmax:Peek()\n    return self._pq[1]\nend\n\nfunction PQmax:Count()\n    return self._n\nend\n\nfunction PQmax:IsEmpty()\n    return self._n == 0\nend\n\n-- for debugging\nfunction PQmax:_isMaxHeap(k)\n    k = k or 1\n    if k > self._n then\n        return true\n    end\n    local left = 2*k\n    if left <= self._n and self._pq[k] < self._pq[left] then\n        return false\n    end\n    local right = left + 1\n    if right <= self._n and self._pq[k] < self._pq[right] then\n        return false\n    end\n    return self:_isMaxHeap(left) and self:_isMaxHeap(right)\nend\n\nlocal function swim(k, pq)\n    while true do\n        local parent = math.floor(k/2)\n        if k > 1 and pq[parent] < pq[k] then\n            local temp = pq[k]\n            pq[k] = pq[parent]\n            pq[parent] = temp\n            k = parent\n        else\n          break\n        end\n    end\nend\n\nfunction PQmax:Enqueue(el)\n    local n = self._n + 1\n    self._n = n\n    local pq = self._pq\n    table.insert(pq, n, el)\n    swim(n, pq)\n    -- assert(self:_isMaxHeap())\n    return self\nend\n\nlocal function sink(n, pq)\n    local k = 1\n    while 2*k <= n do\n        local child = 2*k\n        if child < n and pq[child] < pq[child + 1] then\n            child = child + 1\n        end\n        if not (pq[k] < pq[child]) then\n            break\n        end\n        local temp = pq[k]\n        pq[k] = pq[child]\n        pq[child] = temp\n        k = child\n    end\nend\n\nfunction PQmax:Dequeue()\n    local n = self._n\n    if n == 0 then\n        return nil\n    end\n    local pq = self._pq\n    local result = pq[1]\n    pq[1], pq[n] = pq[n], nil\n    n = n - 1\n    sink(n, pq)\n    self._n = n\n    -- assert(self:_isMaxHeap())\n    return result\nend\n\nfunction PQmax:Clear()\n    local n = self._n\n    if n == 0 then return end\n    for i = n, 1, -1 do\n        self._pq[i] = nil\n    end\n    assert(#self._pq == 0)\n    self._n = 0\nend\n\n-- some aliases\nPQmax.Push = PQmax.Enqueue\nPQmax.Pop = PQmax.Dequeue\n\nreturn PQmax"
      }
    }
    Assets {
      Id: 10304107291754736192
      Name: "_Maid"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    * License: MIT\n    * Based on Quenty\'s Maid:\n        https://github.com/Quenty/NevermoreEngine/blob/version2/Modules/Shared/Events/Maid.lua\n    * Manages the cleaning of events and other things.\n    * Useful for encapsulating state and make deconstructors easy.\n    * Adapted for Core by zoon (https://github.com/zoon).\n]]\n\nlocal CORE_ENV = CoreString and CoreMath\nlocal stacktrace = (CoreDebug and CoreDebug.GetStackTrace) or debug.traceback\nlocal warn = warn or print\n\nlocal Maid = {type=\"Maid\"}\nMaid.__index = Maid\n\n--- Returns a new Maid object\n-- @return Maid\nfunction Maid.New(core_obj)\n    local self = setmetatable({_tasks = {}}, Maid)\n    if CORE_ENV and core_obj then\n        self:GiveTask(core_obj.destroyEvent:Connect(self))\n    end\n    return self\nend\n\nfunction Maid:IsA(typename)\n    return getmetatable(self) == Maid and typename == \"Maid\"\nend\n\n--- Returns Maid[key] if not part of Maid metatable\n-- @return Maid[key] value\nfunction Maid:__index(index)\n    if Maid[index] then\n        return Maid[index]\n    else\n        return self._tasks[index]\n    end\nend\n\nlocal function _cleanupTask(task)\n    if task == nil then return end\n\n    if type(task) == \"function\" then\n        task()\n    elseif type(task) == \'userdata\' and CORE_ENV then\n        -- Core types:\n        if (task:IsA(\"EventListener\") or task:IsA(\"HookListener\")) and task.isConnected then\n            task:Disconnect()\n        elseif task:IsA(\"CoreObject\") and task:IsValid() then\n            task:Destroy()\n        elseif task:IsA(\"Task\") then\n            task:Cancel()\n        end\n    else\n        -- user types, assume `table type` or `userdata type` not in CORE_ENV\n        if task.Disconnect then\n            task:Disconnect()\n        elseif task.Cancel then\n            task:Cancel()\n        elseif task.Destroy then\n            task:Destroy()\n        end\n    end\nend\n\nlocal function _check(task)\n    if task and (type(task) == \"table\" or type(task) == \"userdata\") and\n        not (task.Destroy or task.Cancel or task.Disconnect) then\n        warn(\"[Maid][Warning] - Gave task without Destroy|Cancel|Disconnect\\n\\n\" .. stacktrace())\n    end\n    return task\nend\n\n--- Add a task to clean up. Tasks given to a maid will be cleaned when\n--  maid[index] is set to a different value.\n-- @usage\n-- Maid[key] = (function)         Adds a task to perform\n-- Maid[key] = (event connection) Manages an event connection\n-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.\n-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method\n-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,\n--                                it is destroyed.\nfunction Maid:__newindex(index, newTask)\n    if Maid[index] ~= nil then\n        error((\"\'%s\' is reserved\"):format(tostring(index)), 2)\n    end\n\n    local tasks = self._tasks\n    local oldTask = tasks[index]\n\n    if oldTask == newTask then\n        return\n    end\n    tasks[index] = _check(newTask)\n    _cleanupTask(oldTask)\nend\n\n\nfunction Maid:__call()\n    self:Destroy()\nend\n\n--- Same as indexing, but uses an incremented number as a key.\n-- @param task An item to clean\n-- @treturn number taskId\nfunction Maid:GiveTask(task)\n    if self.type ~= \"Maid\" then\n        error(\"Maid -- don\'t forget `:`\", 2)\n    end\n    if not task then\n        error(\"Maid -- task cannot be false or nil\", 2)\n    end\n    local taskId = #self._tasks+1\n    self[taskId] = task\n\n    return taskId\nend\n\n--[[ TODO: implement promise module and wire it here\nfunction Maid:GivePromise(promise)\n    if not promise:IsPending() then\n        return promise\n    end\n\n    local newPromise = promise.resolved(promise)\n    local id = self:GiveTask(newPromise)\n\n    -- Ensure GC\n    newPromise:Finally(function()\n        self[id] = nil\n    end)\n\n    return newPromise\nend\n--]]\n\n--- Cleans up all tasks.\nfunction Maid:Destroy()\n    local tasks = self._tasks\n\n    -- Clear out tasks table completely, even if clean up tasks add more tasks to the maid\n    local index, task = next(tasks)\n    while task ~= nil do\n        tasks[index] = nil\n        _cleanupTask(task)\n        index, task = next(tasks)\n    end\nend\n\nlocal function _test()\n    do -- resursive tasks\n        local m = Maid.New()\n        local inner1, inner2\n        m:GiveTask({Destroy = function()\n            inner1 = true\n            m.x = function() inner2 = true end\n        end})\n            m:Destroy()\n        assert(inner1)\n        assert(inner2)\n    end\n    print(\"maid -- ok\")\nend\n_test()\n\n-- utility function - destroy something with all nessesary checks\nMaid.safeDestroy = _cleanupTask\nreturn Maid"
      }
    }
    Assets {
      Id: 2361961766352951098
      Name: "_Heap"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    Heap (priority queue) with comparer\n]]\n\nlocal Heap = {}\nHeap.__index = Heap\n\nlocal function _less(a, b) return a < b end\n\nfunction Heap.New(less)\n    return setmetatable({_n = 0, _pq = {}, _comp = less or _less}, Heap)\nend\n\nfunction Heap:Peek()\n    return self._pq[1]\nend\n\nfunction Heap:Count()\n    return self._n\nend\n\nfunction Heap:Push(el)\n    local k, pq, comp = self._n + 1, self._pq, self._comp\n    self._n = k\n    table.insert(pq, k, el)\n    while true do\n        local parent = k//2\n        if k > 1 and comp(pq[k], pq[parent]) then\n            pq[k], pq[parent] = pq[parent], pq[k]\n            k = parent\n        else\n          break\n        end\n    end\nend\n\nfunction Heap:Pop()\n    if self._n == 0 then return nil end\n    local k, n, pq, comp = 1, self._n, self._pq, self._comp\n    local result = pq[1]\n    pq[1], pq[n] = pq[n], nil\n    n = n - 1\n    while 2*k <= n do\n        local child = 2*k\n        if child < n and comp(pq[child + 1], pq[child]) then\n            child = child + 1\n        end\n        if not comp(pq[child], pq[k]) then\n            break\n        end\n        pq[k], pq[child] = pq[child], pq[k]\n        k = child\n    end\n    self._n = n\n    return result\nend\n\nfunction Heap:Purge()\n    for i = self._n, 1, -1 do self._pq[i] = nil end\n    self._n = 0\nend\n\nreturn Heap"
      }
    }
    Assets {
      Id: 410319700329875550
      Name: "_Deque"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    Deque\n    A double ended queue object.\n--]]\n\nlocal Deque = {}\nDeque.__index = Deque\n\nfunction Deque.New()\n    return setmetatable({_front = 0, _back = -1}, Deque)\nend\n\nfunction Deque:Clear()\n    for i = self._front, self._back, 1 do\n        self[i] = nil\n    end\n    self._front = 0\n    self._back = -1\nend\n\nfunction Deque:Empty()\n    return self._front > self._back\nend\n\nfunction Deque:Count()\n    if not self:Empty() then\n        return self._back - self._front + 1\n    else\n        return 0\n    end\nend\n\nfunction Deque:PushBack(value)\n    self._back = self._back + 1\n    self[self._back] = value\nend\n\nfunction Deque:PushFront(value)\n    self._front = self._front - 1\n    self[self._front] = value\nend\n\nfunction Deque:Front()\n    if not self:Empty() then\n        return self[self._front]\n    else\n        return nil\n    end\nend\n\nfunction Deque:Back()\n    if not self:Empty() then\n        return self[self._back]\n    else\n        return nil\n    end\nend\n\nfunction Deque:PopBack()\n    if not self:Empty() then\n        local val = self[self._back]\n        self[self._back] = nil\n        self._back = self._back - 1\n        return val\n    else\n        return nil\n    end\nend\n\nfunction Deque:PopFront()\n    if not self:Empty() then\n        local val = self[self._front]\n        self[self._front] = nil\n        self._front = self._front + 1\n        return val\n    else\n        return nil\n    end\nend\n\n\n\n-- extra exports\nDeque.PeekFront = Deque.Front\nDeque.PeekBack = Deque.Back\nDeque.Push = Deque.PushBack\nDeque.Pop = Deque.PopFront\nDeque.IsEmpty = Deque.Empty\n\nlocal function _test()\n    local q = Deque.New()\n    assert(q:Count() == 0 and q:IsEmpty())\n    q:Push(1)\n    q:Push(2)\n    q:Push(3)\n    q:Push(4)\n    assert(q:Count() == 4 and not q:IsEmpty())\n    assert(q:Front() == 1 and q:Back() == 4)\n    q:PopFront()\n    q:PopBack()\n    assert(q:Front() == 2 and q:Back() == 3 and q:Count() == 2)\n\n\n   print(\"deque -- ok\")\nend\n_test()\n\nreturn Deque"
      }
    }
    PrimaryAssetId {
      AssetType: "None"
      AssetId: "None"
    }
  }
  SerializationVersion: 74
}
IncludesAllDependencies: true
